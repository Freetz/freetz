--- linux-2.6.13/fs/squashfs/inode.c
+++ linux-2.6.13/fs/squashfs/inode.c
@@ -1,7 +1,8 @@
 /*
  * Squashfs - a compressed read only filesystem for Linux
  *
- * Copyright (c) 2002, 2003, 2004, 2005 Phillip Lougher <phillip@lougher.demon.co.uk>
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007
+ * Phillip Lougher <phillip@lougher.demon.co.uk>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -20,279 +21,164 @@
  * inode.c
  */
 
-/*--- #define SQUASHFS_1_0_COMPATIBILITY ---*/
-#include <linux/config.h>
+//#define SQUASHFS_TRACE
 
-#include <linux/types.h>
 #include <linux/squashfs_fs.h>
 #include <linux/module.h>
-#include <linux/errno.h>
-#include <linux/slab.h>
+#include <linux/zlib.h>
 #include <linux/fs.h>
-#include <linux/smp_lock.h>
-#include <linux/slab.h>
 #include <linux/squashfs_fs_sb.h>
 #include <linux/squashfs_fs_i.h>
 #include <linux/buffer_head.h>
 #include <linux/vfs.h>
-#include <linux/init.h>
-#include <linux/dcache.h>
-#include <asm/uaccess.h>
-#include <linux/wait.h>
-#include <asm/semaphore.h>
-#include <linux/zlib.h>
-#include <linux/blkdev.h>
 #include <linux/vmalloc.h>
-#include <linux/LzmaDecode.h>
+#include <linux/smp_lock.h>
 
-/*--- #define SQUASH_FS_TRACE ---*/
+#include "squashfs.h"
 
-#ifdef SQUASH_FS_TRACE
-#define TRACE(s, args...)				printk(KERN_NOTICE "SQUASHFS: "s, ## args)
-#else
-#define TRACE(s, args...)				{}
+#if 1
+#define mutex_init	init_MUTEX
+#define mutex_lock	down
+#define mutex_unlock	up
 #endif
+#define squashfs_cached_blks	SQUASHFS_CACHED_BLKS
 
-#define ERROR(s, args...)				printk(KERN_ERR "SQUASHFS error: "s, ## args)
-
-#define SERROR(s, args...)				/* if(!silent) */printk(KERN_ERR "SQUASHFS error: "s, ## args)
-#define WARNING(s, args...)				printk(KERN_WARNING "SQUASHFS: "s, ## args)
+#ifdef CONFIG_SQUASHFS_BYTESWAPPED
+#define SQUASHFS_IS_BYTESWAPPED(msblk) ((msblk)->swap)
+#else
+#define SQUASHFS_IS_BYTESWAPPED(msblk) 0
+#endif
 
+static void vfs_read_inode(struct inode *i);
+static struct dentry *squashfs_get_parent(struct dentry *child);
+static int squashfs_read_inode(struct inode *i, squashfs_inode_t inode);
 static int squashfs_statfs(struct super_block *, struct kstatfs *);
 static int squashfs_symlink_readpage(struct file *file, struct page *page);
+static long long read_blocklist(struct inode *inode, int index,
+				int readahead_blks, char *block_list,
+				unsigned short **block_p, unsigned int *bsize);
 static int squashfs_readpage(struct file *file, struct page *page);
-static int squashfs_readpage4K(struct file *file, struct page *page);
 static int squashfs_readdir(struct file *, void *, filldir_t);
-static struct dentry *squashfs_lookup(struct inode *, struct dentry *, struct nameidata *);
-static unsigned int read_data(struct super_block *s, char *buffer,
-		unsigned int index, unsigned int length, unsigned int *next_index);
-static int squashfs_get_cached_block(struct super_block *s, char *buffer,
-		unsigned int block, unsigned int offset, int length,
-		unsigned int *next_block, unsigned int *next_offset);
-static struct inode *squashfs_iget(struct super_block *s, squashfs_inode inode);
-static unsigned int read_blocklist(struct inode *inode, int index, int readahead_blks,
-		char *block_list, unsigned short **block_p, unsigned int *bsize);
-static void squashfs_put_super(struct super_block *s);
-static struct super_block *squashfs_get_sb(struct file_system_type *, int, const char *, void *);
+static struct dentry *squashfs_lookup(struct inode *, struct dentry *,
+				struct nameidata *);
+static int squashfs_remount(struct super_block *s, int *flags, char *data);
+static void squashfs_put_super(struct super_block *);
+static struct super_block *squashfs_get_sb(struct file_system_type *,int, const char *, void *);
 static struct inode *squashfs_alloc_inode(struct super_block *sb);
 static void squashfs_destroy_inode(struct inode *inode);
 static int init_inodecache(void);
 static void destroy_inodecache(void);
-#if defined(CONFIG_NFSD) || defined(CONFIG_NFSD_MODULE)
-static struct dentry *squashfs_get_parent(struct dentry *child);
-/*--- static struct dentry *squashfs_get_dentry(struct super_block *sb, void *inump); ---*/
-#endif
 
-#ifdef SQUASHFS_1_0_COMPATIBILITY
-static int squashfs_readpage_lessthan4K(struct file *file, struct page *page);
-static struct inode *squashfs_iget_1(struct super_block *s, squashfs_inode inode);
-static unsigned int read_blocklist_1(struct inode *inode, int index, int readahead_blks,
-		char *block_list, unsigned short **block_p, unsigned int *bsize);
-#endif
-
-DECLARE_MUTEX(read_data_mutex);
-
-static z_stream stream;
-static int use_lzma;
-static CLzmaDecoderState lzma_decoder_state;
-
-static struct file_system_type squashfs_fs_type = {
+static const struct file_system_type squashfs_fs_type = {
 	.owner = THIS_MODULE,
 	.name = "squashfs",
 	.get_sb = squashfs_get_sb,
 	.kill_sb = kill_block_super,
 	.fs_flags = FS_REQUIRES_DEV
-	};
+};
 
-static unsigned char squashfs_filetype_table[] = {
+static const unsigned char squashfs_filetype_table[] = {
 	DT_UNKNOWN, DT_DIR, DT_REG, DT_LNK, DT_BLK, DT_CHR, DT_FIFO, DT_SOCK
 };
 
-static struct super_operations squashfs_ops = {
+static const struct super_operations squashfs_super_ops = {
 	.alloc_inode = squashfs_alloc_inode,
 	.destroy_inode = squashfs_destroy_inode,
 	.statfs = squashfs_statfs,
 	.put_super = squashfs_put_super,
-    .read_inode = make_bad_inode,
+	.remount_fs = squashfs_remount
 };
 
-#if defined(CONFIG_NFSD) || defined(CONFIG_NFSD_MODULE)
-static struct export_operations squashfs_export_ops = {
-	/*--- .get_dentry	= squashfs_get_dentry, ---*/
-	.get_parent = squashfs_get_parent,
-};
-#endif
-
-static struct address_space_operations squashfs_symlink_aops = {
-	.readpage = squashfs_symlink_readpage
+static const struct super_operations squashfs_export_super_ops = {
+	.alloc_inode = squashfs_alloc_inode,
+	.destroy_inode = squashfs_destroy_inode,
+	.statfs = squashfs_statfs,
+	.put_super = squashfs_put_super,
+	.read_inode = vfs_read_inode
 };
 
-static struct address_space_operations squashfs_aops = {
-	.readpage = squashfs_readpage
+static const struct export_operations squashfs_export_ops = {
+	.get_parent = squashfs_get_parent
 };
 
-static struct address_space_operations squashfs_aops_4K = {
-	.readpage = squashfs_readpage4K
+SQSH_EXTERN const struct address_space_operations squashfs_symlink_aops = {
+	.readpage = squashfs_symlink_readpage
 };
 
-#ifdef SQUASHFS_1_0_COMPATIBILITY
-static struct address_space_operations squashfs_aops_lessthan4K = {
-	.readpage = squashfs_readpage_lessthan4K
+SQSH_EXTERN const struct address_space_operations squashfs_aops = {
+	.readpage = squashfs_readpage
 };
-#endif
 
-static struct file_operations squashfs_dir_ops = {
+static const struct file_operations squashfs_dir_ops = {
 	.read = generic_read_dir,
 	.readdir = squashfs_readdir
 };
 
-static struct inode_operations squashfs_dir_inode_ops = {
+SQSH_EXTERN struct inode_operations squashfs_dir_inode_ops = {
 	.lookup = squashfs_lookup
 };
+#define squashfs_fs_type *(struct file_system_type *)(&squashfs_fs_type)
+#define squashfs_super_ops *(struct super_operations *)(&squashfs_super_ops)
+#define squashfs_export_super_ops *(struct super_operations *)(&squashfs_export_super_ops)
+#define squashfs_export_ops *(struct export_operations *)(&squashfs_export_ops)
+#define squashfs_symlink_aops *(struct address_space_operations *)(&squashfs_symlink_aops)
+#define squashfs_aops *(struct address_space_operations *)(&squashfs_aops)
+#define squashfs_dir_ops *(struct file_operations *)(&squashfs_dir_ops)
+#define squashfs_dir_inode_ops *(struct inode_operations *)(&squashfs_dir_inode_ops)
 
-
-static inline struct squashfs_inode_info *SQUASHFS_I(struct inode *inode)
-{
-	return list_entry(inode, struct squashfs_inode_info, vfs_inode);
-}
-
-/*------------------------------------------------------------------------------------------*\
-\*------------------------------------------------------------------------------------------*/
-#if defined(CONFIG_NFSD) || defined(CONFIG_NFSD_MODULE)
-struct dentry *squashfs_get_parent(struct dentry *child)
+static void *kzalloc(int size, int flags)
 {
-	struct dentry *parent;
-	struct inode *inode;
-	struct dentry dotdot;
-    struct dentry *d_entry;
-
-	dotdot.d_name.name = "..";
-	dotdot.d_name.len = 2;
-
-    d_entry = squashfs_lookup(child->d_inode, &dotdot, NULL);
-    if (d_entry)
-        inode = d_entry->d_inode;
-    else {
-        printk("[squashfs_get_parent] no entry\n");
-        return ERR_PTR(-ENOENT);
-    }
+      void *buff = kmalloc(size, flags);
 
-	if ((int)inode <= 0) {
-        printk("[squashfs_get_parent] no inode found 0x%p\n", inode);
-		return ERR_PTR(-EACCES);
-    }
-
-	parent = d_alloc_anon(inode);
-	if (!parent) {
-		iput(inode);
-		parent = ERR_PTR(-ENOMEM);
-	}
+      if(buff != NULL)
+              memset(buff, 0, size);
 
-    TRACE("[squashfs_get_parent] 0x%p %s\n", parent, parent->d_iname);
-	return parent;
+      return buff;
 } 
 
-/*--- squashfs_iget kann an dieser Stelle nicht genutzt werden, da die i_ino des VFS ---*/
-/*--- nicht identisch mit der des Squashfs ist. Squashfs nutzt 32k Blöcke die für das VFS ---*/
-/*--- auf 4k Blöcke gemappt werden. ---*/ 
-#if 0
-static struct dentry *squashfs_get_dentry(struct super_block *sb, void *inump) {
-
-	struct inode *inode = NULL;
-	struct dentry *result;
-	__u32 *fh = inump;
-
-    printk("[squashfs_get_dentry] ino 0x%x\n", fh[0]);
-	inode = iget(sb, fh[0]);
-	if (!inode || is_bad_inode(inode) || inode->i_generation != fh[1]) {
-		if (inode)
-			iput(inode);
-		inode = NULL;
-        printk("[squashfs_get_dentry] no inode try again\n");
-	}
-
-    if (!inode) {
-        printk("[squashfs_get_dentry] call squashfs_iget 0x%x\n", fh[0]);
-        inode = squashfs_iget(sb, fh[0]);
-    }
-    if (!inode) {
-        printk("[squashfs_get_dentry] iget called no inode\n");
-        return ERR_PTR(-ESTALE);
-    }
-
-	/* now to find a dentry.
-	 * If possible, get a well-connected one
-	 */
-	result = d_alloc_anon(inode);
-	if (result == NULL) {
-		iput(inode);
-		return ERR_PTR(-ENOMEM);
-	}
-    return result;
-
-}
-#endif 
-#endif
 
 static struct buffer_head *get_block_length(struct super_block *s,
 				int *cur_index, int *offset, int *c_byte)
 {
-	squashfs_sb_info *msblk = s->s_fs_info;
-	unsigned short temp;
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	uint16_t temp_sh;
+	unsigned char temp[3];
+	unsigned int temp_len = 2 + !!SQUASHFS_CHECK_DATA(msblk->sblk.flags);
+	unsigned int avail_bytes;
 	struct buffer_head *bh;
 
-	if (!(bh = sb_bread(s, *cur_index)))
+	bh = sb_bread(s, *cur_index);
+	if (!bh)
 		goto out;
 
-	if (msblk->devblksize - *offset == 1) {
-		if (msblk->swap)
-			((unsigned char *) &temp)[1] = *((unsigned char *)
-				(bh->b_data + *offset));
-		else
-			((unsigned char *) &temp)[0] = *((unsigned char *)
-				(bh->b_data + *offset));
+	avail_bytes = min((unsigned int)(msblk->devblksize - *offset), temp_len);
+	memcpy(temp, bh->b_data + *offset, avail_bytes);
+	*offset += temp_len;
+	if (*offset >= msblk->devblksize) {
 		brelse(bh);
-		if (!(bh = sb_bread(s, ++(*cur_index))))
+		++(*cur_index);
+		bh = sb_bread(s, *cur_index);
+		if (!bh)
 			goto out;
-		if (msblk->swap)
-			((unsigned char *) &temp)[0] = *((unsigned char *)
-				bh->b_data); 
-		else
-			((unsigned char *) &temp)[1] = *((unsigned char *)
-				bh->b_data); 
-		*c_byte = temp;
-		*offset = 1;
-	} else {
-		if (msblk->swap) {
-			((unsigned char *) &temp)[1] = *((unsigned char *)
-				(bh->b_data + *offset));
-			((unsigned char *) &temp)[0] = *((unsigned char *)
-				(bh->b_data + *offset + 1)); 
-		} else {
-			((unsigned char *) &temp)[0] = *((unsigned char *)
-				(bh->b_data + *offset));
-			((unsigned char *) &temp)[1] = *((unsigned char *)
-				(bh->b_data + *offset + 1)); 
+		*offset -= msblk->devblksize;
+		memcpy(temp + avail_bytes, bh->b_data, *offset);
 		}
-		*c_byte = temp;
-		*offset += 2;
+	if (SQUASHFS_IS_BYTESWAPPED(msblk)) {
+		((uint8_t *)&temp_sh)[0] = temp[1];
+		((uint8_t *)&temp_sh)[1] = temp[0];
 	}
-
-	if (SQUASHFS_CHECK_DATA(msblk->sBlk.flags)) {
-		if (*offset == msblk->devblksize) {
-			brelse(bh);
-			if (!(bh = sb_bread(s, ++(*cur_index))))
-				goto out;
-			*offset = 0;
+	else {
+		((uint8_t *)&temp_sh)[0] = temp[0];
+		((uint8_t *)&temp_sh)[1] = temp[1];
 		}
-		if (*((unsigned char *) (bh->b_data + *offset)) !=
-						SQUASHFS_MARKER_BYTE) {
+	*c_byte = temp_sh;
+	if (SQUASHFS_CHECK_DATA(msblk->sblk.flags)) {
+		if (temp[2] != SQUASHFS_MARKER_BYTE) {
 			ERROR("Metadata block marker corrupt @ %x\n",
 						*cur_index);
 			brelse(bh);
 			goto out;
 		}
-		(*offset)++;
 	}
 	return bh;
 
@@ -300,951 +186,1167 @@
 	return NULL;
 }
 
+struct read_data_state {
+	struct _ILzmaInCallback		Callback;
+	struct squashfs_sb_info *	msblk;
+	struct buffer_head **		bh;
+	size_t				bh_used;
+	size_t				bh_cur;
+	size_t				bh_freed;
+	size_t				offset;
+	size_t				bytes;
+	size_t				c_byte;
+};
 
-static unsigned int read_data(struct super_block *s, char *buffer,
-		unsigned int index, unsigned int length, unsigned int *next_index)
+static int
+read_block (void *object, const unsigned char **buffer, size_t *bufferSize)
 {
-	squashfs_sb_info *msBlk = (squashfs_sb_info *)s->s_fs_info;
-	struct buffer_head *bh[((SQUASHFS_FILE_MAX_SIZE - 1) >> msBlk->devblksize_log2) + 2];
-	unsigned int offset = index & ((1 << msBlk->devblksize_log2) - 1);
-	unsigned int cur_index = index >> msBlk->devblksize_log2;
-	int bytes, avail_bytes, b = 0, k;
-	char *c_buffer;
-	unsigned int compressed;
-	unsigned int c_byte = length;
-
-	if(c_byte) {
-		bytes = msBlk->devblksize - offset;
-		compressed = SQUASHFS_COMPRESSED_BLOCK(c_byte);
-		c_buffer = compressed ? msBlk->read_data : buffer;
-		c_byte = SQUASHFS_COMPRESSED_SIZE_BLOCK(c_byte);
+	struct read_data_state *rds = (struct read_data_state *)object;
+	struct squashfs_sb_info *msblk = rds->msblk;
+	size_t avail_bytes = min(rds->c_byte - rds->bytes, msblk->devblksize - rds->offset);
+	struct buffer_head *b = rds->bh[rds->bh_cur];
+
+	TRACE("%s: 1: free %d, cur %d, ofs %x, bytes %x, c_byte %x, avail %x\n",
+	      __FUNCTION__, rds->bh_freed, rds->bh_cur,
+	      rds->offset, rds->bytes, rds->c_byte, avail_bytes);
+	if (rds->bh_freed < rds->bh_cur) {
+		brelse(rds->bh[rds->bh_freed]);
+		rds->bh_freed++;
+	}
+
+	wait_on_buffer(b);
+	if(!buffer_uptodate(b))
+		return -1;
+
+	*buffer = b->b_data + rds->offset;
+	*bufferSize = avail_bytes;
+	rds->bytes += avail_bytes;
+	rds->offset = 0;
+	rds->bh_cur++;
+	TRACE("%s: 2: free %d, cur %d, ofs %x, bytes %x, c_byte %x, avail %x\n",
+	      __FUNCTION__, rds->bh_freed, rds->bh_cur,
+	      rds->offset, rds->bytes, rds->c_byte, avail_bytes);
+	return 0;
+}
 
-		TRACE("Block @ 0x%x, %scompressed size %d\n", index, compressed ? "" : "un", (unsigned int) c_byte);
+SQSH_EXTERN unsigned int squashfs_read_data(struct super_block *s, char *buffer,
+			long long index, unsigned int length,
+			long long *next_index, int srclength)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	unsigned int cur_index = index >> msblk->devblksize_log2;
+	int avail_bytes, blocks_read = 0, cur_offset, end_offset;
+	unsigned int compressed;
+	unsigned int out_size;
+	struct read_data_state rds;
+	rds.offset = index & ((1 << msblk->devblksize_log2) - 1);
+
+	rds.Callback.Read = read_block;
+	rds.msblk = msblk;
+	rds.bh = kmalloc(((sblk->block_size >> msblk->devblksize_log2) + 1) *
+								sizeof(struct buffer_head *), GFP_KERNEL);
+	rds.bh_used = 0;
+	rds.bh_cur = 0;
+	rds.bh_freed = 0;
+	rds.bytes = 0;
+	if (rds.bh == NULL)
+		goto read_failure;
+	if (index < 0)
+		goto read_failure;
 
-		if(!(bh[0] = sb_getblk(s, cur_index)))
-			goto block_release;
-		for(b = 1; bytes < c_byte; b++) {
-			if(!(bh[b] = sb_getblk(s, ++cur_index)))
-				goto block_release;
-			bytes += msBlk->devblksize;
-		}
-		ll_rw_block(READ, b, bh);
-	} else {
-		if(!(bh[0] = get_block_length(s, &cur_index, &offset, &c_byte)))
+	if (!length) {
+		if (index + 2 > sblk->bytes_used)
 			goto read_failure;
 
-		bytes = msBlk->devblksize - offset;
-		compressed = SQUASHFS_COMPRESSED(c_byte);
-		c_buffer = compressed ? msBlk->read_data : buffer;
-		c_byte = SQUASHFS_COMPRESSED_SIZE(c_byte);
+		rds.bh[0] = get_block_length(s, &cur_index, &rds.offset, &rds.c_byte);
+		if (rds.bh[0] == NULL)
+			goto read_failure;
+		compressed = SQUASHFS_COMPRESSED(rds.c_byte);
+		rds.c_byte = SQUASHFS_COMPRESSED_SIZE(rds.c_byte);
 
-		TRACE("Block @ 0x%x, %scompressed size %d\n", index, compressed ? "" : "un", (unsigned int) c_byte);
+		TRACE("Block @ 0x%llx, %scompressed size %d\n", index, compressed
+					? "" : "un", (unsigned int) rds.c_byte);
 
-		for(b = 1; bytes < c_byte; b++) {
-			if(!(bh[b] = sb_getblk(s, ++cur_index)))
-				goto block_release;
-			bytes += msBlk->devblksize;
-		}
-		ll_rw_block(READ, b - 1, bh + 1);
+		rds.bh_used++;
+		cur_index++;
+		cur_offset = msblk->devblksize;
 	}
+	else {
+		compressed = SQUASHFS_COMPRESSED_BLOCK(length);
+		rds.c_byte = SQUASHFS_COMPRESSED_SIZE_BLOCK(length);
 
-	if(compressed)
-		down(&read_data_mutex);
+		TRACE("Block @ 0x%llx, %scompressed size %d, src size %d\n", index,
+					compressed ? "" : "un", (unsigned int) rds.c_byte, srclength);
 
-	for(bytes = 0, k = 0; k < b; k++) {
-		avail_bytes = (c_byte - bytes) > (msBlk->devblksize - offset) ? msBlk->devblksize - offset : c_byte - bytes;
-		wait_on_buffer(bh[k]);
-		if (!buffer_uptodate(bh[k]))
+		cur_offset = 0;
+	}
+	if (rds.c_byte > srclength || index + rds.c_byte > sblk->bytes_used)
+		goto read_failure;
+
+	blocks_read = rds.bh_used;
+	end_offset = rds.offset + rds.c_byte;
+	while (cur_offset < end_offset) {
+		rds.bh[rds.bh_used] = sb_getblk(s, cur_index);
+		if (rds.bh[rds.bh_used] == NULL)
 			goto block_release;
-		memcpy(c_buffer + bytes, bh[k]->b_data + offset, avail_bytes);
-		bytes += avail_bytes;
-		offset = 0;
-		brelse(bh[k]);
+		rds.bh_used++;
+		cur_index++;
+		cur_offset += msblk->devblksize;
 	}
+	ll_rw_block(READ, rds.bh_used - blocks_read, rds.bh + blocks_read);
 
+	if (compressed) {
+		int zlib_err = 0;
 	/*
 	 * uncompress block
 	 */
-	if(compressed) {
-        if (use_lzma) {
-            int result;
-            unsigned int processed_in = 0, processed_out = 0;
-
-            result = LzmaDecode(&lzma_decoder_state, c_buffer, c_byte, &processed_in, buffer, msBlk->read_size, &processed_out);
-            if ((result != LZMA_RESULT_OK) || !processed_in) { 
-                ERROR("<LzmaDecode returned Error 0x%x>\n",result);
-                bytes = 0;
-            } else {
-                bytes = processed_out;
+
+		mutex_lock(&msblk->read_data_mutex);
+		zlib_err = LzmaDecode(&msblk->lzma_decoder_state,
+#ifdef _LZMA_IN_CB
+				      &rds.Callback,
+#else
+				      msblk->stream.next_in,
+				      msblk->stream.avail_in,
+				      &processed_in,
+#endif
+				      buffer,
+				      srclength,
+				      &out_size);
+
+		if ((zlib_err != LZMA_RESULT_OK)) {
+			ERROR("<LzmaDecode returned Error 0x%x>\n", zlib_err);
+			goto release_mutex;
             }
-            up(&read_data_mutex);
+		mutex_unlock(&msblk->read_data_mutex);
         } else {
-            int zlib_err;
-
-            stream.next_in = c_buffer;
-            stream.avail_in = c_byte;
-            stream.next_out = buffer;
-            stream.avail_out = msBlk->read_size;
-            if(((zlib_err = zlib_inflateInit(&stream)) != Z_OK) ||
-                    ((zlib_err = zlib_inflate(&stream, Z_FINISH)) != Z_STREAM_END) ||
-                    ((zlib_err = zlib_inflateEnd(&stream)) != Z_OK)) {
-                ERROR("zlib_fs returned unexpected result 0x%x\n", zlib_err);
-                bytes = 0;
-            } else
-                bytes = stream.total_out;
-            up(&read_data_mutex);
+		TRACE("uncompressed: %d\n", rds.c_byte);
+		while (rds.bytes < rds.c_byte) {
+			const unsigned char *src;
+			size_t bytes = rds.bytes;
+			if (rds.Callback.Read (&rds.Callback, &src, &avail_bytes))
+				goto block_release;
+			TRACE("Read -> %p %d, @%x\n", src, avail_bytes, bytes);
+			memcpy(buffer + bytes, src, avail_bytes);
         }
+		out_size = rds.bytes;
     }
 
-	if(next_index)
-		*next_index = index + c_byte + (length ? 0 : (SQUASHFS_CHECK_DATA(msBlk->sBlk.flags) ? 3 : 2));
+	if (next_index)
+		*next_index = index + rds.c_byte + (length ? 0 :
+				(SQUASHFS_CHECK_DATA(msblk->sblk.flags) ? 3 : 2));
 
-	return bytes;
+	for (; rds.bh_freed < rds.bh_used; rds.bh_freed++)
+		brelse(rds.bh[rds.bh_freed]);
+	kfree(rds.bh);
+	return out_size;
+
+release_mutex:
+	mutex_unlock(&msblk->read_data_mutex);
 
 block_release:
-	while(--b >= 0) brelse(bh[b]);
+	for (; rds.bh_freed < rds.bh_used; rds.bh_freed++)
+		brelse(rds.bh[rds.bh_freed]);
 
 read_failure:
 	ERROR("sb_bread failed reading block 0x%x\n", cur_index);
+	kfree(rds.bh);
 	return 0;
 }
 
 
-static int squashfs_get_cached_block(struct super_block *s, char *buffer,
-		unsigned int block, unsigned int offset, int length,
-		unsigned int *next_block, unsigned int *next_offset)
+SQSH_EXTERN int squashfs_get_cached_block(struct super_block *s, void *buffer,
+				long long block, unsigned int offset,
+				int length, long long *next_block,
+				unsigned int *next_offset)
 {
-	squashfs_sb_info *msBlk = (squashfs_sb_info *)s->s_fs_info;
+	struct squashfs_sb_info *msblk = s->s_fs_info;
 	int n, i, bytes, return_length = length;
-	unsigned int next_index;
+	long long next_index;
 
-	TRACE("Entered squashfs_get_cached_block [%x:%x]\n", block, offset);
+	TRACE("Entered squashfs_get_cached_block [%llx:%x]\n", block, offset);
 
-	for(;;) {
-		for(i = 0; i < SQUASHFS_CACHED_BLKS; i++) 
-			if(msBlk->block_cache[i].block == block)
+	while (1) {
+		for (i = 0; i < squashfs_cached_blks; i++) 
+			if (msblk->block_cache[i].block == block)
 				break; 
 		
-		down(&msBlk->block_cache_mutex);
-		if(i == SQUASHFS_CACHED_BLKS) {
-			/* read inode header block */
-			for(i = msBlk->next_cache, n = SQUASHFS_CACHED_BLKS; n ; n --, i = (i + 1) % SQUASHFS_CACHED_BLKS)
-				if(msBlk->block_cache[i].block != SQUASHFS_USED_BLK)
-					break;
-			if(n == 0) {
-				wait_queue_t wait;
+		mutex_lock(&msblk->block_cache_mutex);
 
-				init_waitqueue_entry(&wait, current);
-				add_wait_queue(&msBlk->waitq, &wait);
- 				up(&msBlk->block_cache_mutex);
-				set_current_state(TASK_UNINTERRUPTIBLE);
-				schedule();
-				set_current_state(TASK_RUNNING);
-				remove_wait_queue(&msBlk->waitq, &wait);
+		if (i == squashfs_cached_blks) {
+			/* read inode header block */
+			if (msblk->unused_cache_blks == 0) {
+				mutex_unlock(&msblk->block_cache_mutex);
+				wait_event(msblk->waitq, msblk->unused_cache_blks);
 				continue;
 			}
-			msBlk->next_cache = (i + 1) % SQUASHFS_CACHED_BLKS;
 
-			if(msBlk->block_cache[i].block == SQUASHFS_INVALID_BLK) {
-				if(!(msBlk->block_cache[i].data = (unsigned char *)
-							kmalloc(SQUASHFS_METADATA_SIZE, GFP_KERNEL))) {
+			i = msblk->next_cache;
+			for (n = 0; n < squashfs_cached_blks; n++) {
+				if (msblk->block_cache[i].block != SQUASHFS_USED_BLK)
+					break;
+				i = (i + 1) % squashfs_cached_blks;
+			}
+
+			msblk->next_cache = (i + 1) % squashfs_cached_blks;
+
+			if (msblk->block_cache[i].block == SQUASHFS_INVALID_BLK) {
+				msblk->block_cache[i].data = vmalloc(SQUASHFS_METADATA_SIZE);
+				if (msblk->block_cache[i].data == NULL) {
 					ERROR("Failed to allocate cache block\n");
-					up(&msBlk->block_cache_mutex);
-					return 0;
+					mutex_unlock(&msblk->block_cache_mutex);
+					goto out;
 				}
 			}
 	
-			msBlk->block_cache[i].block = SQUASHFS_USED_BLK;
-			up(&msBlk->block_cache_mutex);
-			if(!(msBlk->block_cache[i].length = read_data(s, msBlk->block_cache[i].data, block, 0,
-							&next_index))) {
-				ERROR("Unable to read cache block [%x:%x]\n", block, offset);
-				return 0;
+			msblk->block_cache[i].block = SQUASHFS_USED_BLK;
+			msblk->unused_cache_blks --;
+			mutex_unlock(&msblk->block_cache_mutex);
+
+			msblk->block_cache[i].length = squashfs_read_data(s,
+				msblk->block_cache[i].data, block, 0, &next_index,
+				SQUASHFS_METADATA_SIZE);
+
+			if (msblk->block_cache[i].length == 0) {
+				ERROR("Unable to read cache block [%llx:%x]\n", block, offset);
+				mutex_lock(&msblk->block_cache_mutex);
+				msblk->block_cache[i].block = SQUASHFS_INVALID_BLK;
+				msblk->unused_cache_blks ++;
+				smp_mb();
+				vfree(msblk->block_cache[i].data);
+				wake_up(&msblk->waitq);
+				mutex_unlock(&msblk->block_cache_mutex);
+				goto out;
 			}
-			down(&msBlk->block_cache_mutex);
-			wake_up(&msBlk->waitq);
-			msBlk->block_cache[i].block = block;
-			msBlk->block_cache[i].next_index = next_index;
-			TRACE("Read cache block [%x:%x] len %d length %d\n", block, offset, msBlk->block_cache[i].length, length);
+
+			mutex_lock(&msblk->block_cache_mutex);
+			msblk->block_cache[i].block = block;
+			msblk->block_cache[i].next_index = next_index;
+			msblk->unused_cache_blks ++;
+			smp_mb();
+			wake_up(&msblk->waitq);
+			TRACE("Read cache block [%llx:%x]\n", block, offset);
 		}
 
-		if(msBlk->block_cache[i].block != block) {
-			up(&msBlk->block_cache_mutex);
+		if (msblk->block_cache[i].block != block) {
+			mutex_unlock(&msblk->block_cache_mutex);
 			continue;
 		}
 
-        if(offset > msBlk->block_cache[i].length) {
-            printk("ERROR: squashfs_get_cached_block bytes2copy < 0\n");
-			up(&msBlk->block_cache_mutex);
-            return 0;
-        }
+		bytes = msblk->block_cache[i].length - offset;
 
-		if((bytes = msBlk->block_cache[i].length - offset) >= length) {
-			if(buffer)
-				memcpy(buffer, msBlk->block_cache[i].data + offset, length);
-			if(msBlk->block_cache[i].length - offset == length) {
-				*next_block = msBlk->block_cache[i].next_index;
+		if (bytes < 1) {
+			mutex_unlock(&msblk->block_cache_mutex);
+			goto out;
+		} else if (bytes >= length) {
+			if (buffer)
+				memcpy(buffer, msblk->block_cache[i].data + offset, length);
+			if (msblk->block_cache[i].length - offset == length) {
+				*next_block = msblk->block_cache[i].next_index;
 				*next_offset = 0;
 			} else {
 				*next_block = block;
 				*next_offset = offset + length;
 			}
-			up(&msBlk->block_cache_mutex);
-			return return_length;
+			mutex_unlock(&msblk->block_cache_mutex);
+			goto finish;
 		} else {
-			if(buffer) {
-				memcpy(buffer, msBlk->block_cache[i].data + offset, bytes);
-				buffer += bytes;
+			if (buffer) {
+				memcpy(buffer, msblk->block_cache[i].data + offset, bytes);
+				buffer = (char *) buffer + bytes;
 			}
-			block = msBlk->block_cache[i].next_index;
-			up(&msBlk->block_cache_mutex);
+			block = msblk->block_cache[i].next_index;
+			mutex_unlock(&msblk->block_cache_mutex);
 			length -= bytes;
 			offset = 0;
 		}
 	}
+
+finish:
+	return return_length;
+out:
+	return 0;
 }
 
 
-static int get_fragment_location(struct super_block *s, unsigned int fragment, unsigned int *fragment_start_block, unsigned int *fragment_size)
-{
-	squashfs_sb_info *msBlk = (squashfs_sb_info *)s->s_fs_info;
-	unsigned int start_block = msBlk->fragment_index[SQUASHFS_FRAGMENT_INDEX(fragment)];
+static int get_fragment_location(struct super_block *s, unsigned int fragment,
+				long long *fragment_start_block,
+				unsigned int *fragment_size)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	long long start_block =
+		msblk->fragment_index[SQUASHFS_FRAGMENT_INDEX(fragment)];
 	int offset = SQUASHFS_FRAGMENT_INDEX_OFFSET(fragment);
-	squashfs_fragment_entry fragment_entry;
+	struct squashfs_fragment_entry fragment_entry;
 
-	if(msBlk->swap) {
-		squashfs_fragment_entry sfragment_entry;
+	if (SQUASHFS_IS_BYTESWAPPED(msblk)) {
+		struct squashfs_fragment_entry sfragment_entry;
 
-		if(!squashfs_get_cached_block(s, (char *) &sfragment_entry, start_block, offset,
+		if (!squashfs_get_cached_block(s, &sfragment_entry, start_block, offset,
 					sizeof(sfragment_entry), &start_block, &offset))
-			return 0;
+			goto out;
 		SQUASHFS_SWAP_FRAGMENT_ENTRY(&fragment_entry, &sfragment_entry);
 	} else
-		if(!squashfs_get_cached_block(s, (char *) &fragment_entry, start_block, offset,
+		if (!squashfs_get_cached_block(s, &fragment_entry, start_block, offset,
 					sizeof(fragment_entry), &start_block, &offset))
-			return 0;
+			goto out;
 
 	*fragment_start_block = fragment_entry.start_block;
 	*fragment_size = fragment_entry.size;
 
 	return 1;
+
+out:
+	return 0;
 }
 
 
-void release_cached_fragment(squashfs_sb_info *msBlk, struct squashfs_fragment_cache *fragment)
+SQSH_EXTERN void release_cached_fragment(struct squashfs_sb_info *msblk,
+				struct squashfs_fragment_cache *fragment)
 {
-	down(&msBlk->fragment_mutex);
+	mutex_lock(&msblk->fragment_mutex);
 	fragment->locked --;
-	wake_up(&msBlk->fragment_wait_queue);
-	up(&msBlk->fragment_mutex);
+	if (fragment->locked == 0) {
+		msblk->unused_frag_blks ++;
+		smp_mb();
+		wake_up(&msblk->fragment_wait_queue);
+	}
+	mutex_unlock(&msblk->fragment_mutex);
 }
 
 
-struct squashfs_fragment_cache *get_cached_fragment(struct super_block *s, unsigned int start_block, int length)
+SQSH_EXTERN
+struct squashfs_fragment_cache *get_cached_fragment(struct super_block *s,
+				long long start_block, int length)
 {
 	int i, n;
-	squashfs_sb_info *msBlk = (squashfs_sb_info *)s->s_fs_info;
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	while (1) {
+		mutex_lock(&msblk->fragment_mutex);
+
+		for (i = 0; i < SQUASHFS_CACHED_FRAGMENTS &&
+				msblk->fragment[i].block != start_block; i++);
 
-	for(;;) {
-		down(&msBlk->fragment_mutex);
-		for(i = 0; i < SQUASHFS_CACHED_FRAGMENTS && msBlk->fragment[i].block != start_block; i++);
-		if(i == SQUASHFS_CACHED_FRAGMENTS) {
-			for(i = msBlk->next_fragment, n = SQUASHFS_CACHED_FRAGMENTS;
-				n && msBlk->fragment[i].locked; n--, i = (i + 1) % SQUASHFS_CACHED_FRAGMENTS);
-
-			if(n == 0) {
-				wait_queue_t wait;
-
-				init_waitqueue_entry(&wait, current);
-				add_wait_queue(&msBlk->fragment_wait_queue, &wait);
-				up(&msBlk->fragment_mutex);
-				set_current_state(TASK_UNINTERRUPTIBLE);
-				schedule();
-				set_current_state(TASK_RUNNING);
-				remove_wait_queue(&msBlk->fragment_wait_queue, &wait);
+		if (i == SQUASHFS_CACHED_FRAGMENTS) {
+			if (msblk->unused_frag_blks == 0) {
+				mutex_unlock(&msblk->fragment_mutex);
+				wait_event(msblk->fragment_wait_queue, msblk->unused_frag_blks);
 				continue;
 			}
-			msBlk->next_fragment = (msBlk->next_fragment + 1) % SQUASHFS_CACHED_FRAGMENTS;
 			
-			if(msBlk->fragment[i].data == NULL)
-				if(!(msBlk->fragment[i].data = (unsigned char *)
-							SQUASHFS_ALLOC(SQUASHFS_FILE_MAX_SIZE))) {
-					ERROR("Failed to allocate fragment cache block\n");
-					up(&msBlk->fragment_mutex);
-					return NULL;
+			i = msblk->next_fragment;
+			for (n = 0; n < SQUASHFS_CACHED_FRAGMENTS; n++) {
+				if (msblk->fragment[i].locked == 0)
+					break;
+				i = (i + 1) % SQUASHFS_CACHED_FRAGMENTS;
 				}
 
-			msBlk->fragment[i].block = SQUASHFS_INVALID_BLK;
-			msBlk->fragment[i].locked = 1;
-			up(&msBlk->fragment_mutex);
-			if(!(msBlk->fragment[i].length = read_data(s, msBlk->fragment[i].data, start_block, length,
-							NULL))) {
-				ERROR("Unable to read fragment cache block [%x]\n", start_block);
-				msBlk->fragment[i].locked = 0;
-				return NULL;
+			msblk->next_fragment = (msblk->next_fragment + 1) %
+				SQUASHFS_CACHED_FRAGMENTS;
+			
+			if (msblk->fragment[i].data == NULL) {
+				msblk->fragment[i].data = vmalloc(sblk->block_size);
+				if (msblk->fragment[i].data == NULL) {
+					ERROR("Failed to allocate fragment cache block\n");
+					mutex_unlock(&msblk->fragment_mutex);
+					goto out;
 			}
-			msBlk->fragment[i].block = start_block;
-			TRACE("New fragment %d, start block %d, locked %d\n", i, msBlk->fragment[i].block, msBlk->fragment[i].locked);
-			return &msBlk->fragment[i];
 		}
 
-		msBlk->fragment[i].locked ++;
-		up(&msBlk->fragment_mutex);
+			msblk->unused_frag_blks --;
+			msblk->fragment[i].block = SQUASHFS_INVALID_BLK;
+			msblk->fragment[i].locked = 1;
+			mutex_unlock(&msblk->fragment_mutex);
+
+			msblk->fragment[i].length = squashfs_read_data(s,
+				msblk->fragment[i].data, start_block, length, NULL,
+				sblk->block_size);
+
+			if (msblk->fragment[i].length == 0) {
+				ERROR("Unable to read fragment cache block [%llx]\n", start_block);
+				msblk->fragment[i].locked = 0;
+				msblk->unused_frag_blks ++;
+				smp_mb();
+				wake_up(&msblk->fragment_wait_queue);
+				goto out;
+			}
 		
-		TRACE("Got fragment %d, start block %d, locked %d\n", i, msBlk->fragment[i].block, msBlk->fragment[i].locked);
-		return &msBlk->fragment[i];
+			mutex_lock(&msblk->fragment_mutex);
+			msblk->fragment[i].block = start_block;
+			TRACE("New fragment %d, start block %lld, locked %d\n",
+				i, msblk->fragment[i].block, msblk->fragment[i].locked);
+			mutex_unlock(&msblk->fragment_mutex);
+			break;
 	}
+
+		if (msblk->fragment[i].locked == 0)
+			msblk->unused_frag_blks --;
+		msblk->fragment[i].locked++;
+		mutex_unlock(&msblk->fragment_mutex);
+		TRACE("Got fragment %d, start block %lld, locked %d\n", i,
+			msblk->fragment[i].block, msblk->fragment[i].locked);
+		break;
+	}
+
+	return &msblk->fragment[i];
+
+out:
+	return NULL;
 }
 
 
-#ifdef SQUASHFS_1_0_COMPATIBILITY
-static struct inode *squashfs_iget_1(struct super_block *s, squashfs_inode inode)
+static void squashfs_new_inode(struct squashfs_sb_info *msblk, struct inode *i,
+		struct squashfs_base_inode_header *inodeb)
 {
-	struct inode *i = new_inode(s);
-	squashfs_sb_info *msBlk = (squashfs_sb_info *)s->s_fs_info;
-	squashfs_super_block *sBlk = &msBlk->sBlk;
-	unsigned int block = SQUASHFS_INODE_BLK(inode) + sBlk->inode_table_start;
-	unsigned int offset = SQUASHFS_INODE_OFFSET(inode);
-	unsigned int next_block, next_offset;
-	squashfs_base_inode_header_1 inodeb;
+	i->i_ino = inodeb->inode_number;
+	i->i_mtime.tv_sec = inodeb->mtime;
+	i->i_atime.tv_sec = inodeb->mtime;
+	i->i_ctime.tv_sec = inodeb->mtime;
+	i->i_uid = msblk->uid[inodeb->uid];
+	i->i_mode = inodeb->mode;
+	i->i_size = 0;
 
-	TRACE("Entered squashfs_iget_1\n");
+	if (inodeb->guid == SQUASHFS_GUIDS)
+		i->i_gid = i->i_uid;
+	else
+		i->i_gid = msblk->guid[inodeb->guid];
+}
 
-	if(msBlk->swap) {
-		squashfs_base_inode_header_1 sinodeb;
 
-		if(!squashfs_get_cached_block(s, (char *) &sinodeb, block,  offset,
-					sizeof(sinodeb), &next_block, &next_offset))
-			goto failed_read;
-		SQUASHFS_SWAP_BASE_INODE_HEADER_1(&inodeb, &sinodeb, sizeof(sinodeb));
-	} else
-		if(!squashfs_get_cached_block(s, (char *) &inodeb, block,  offset,
-					sizeof(inodeb), &next_block, &next_offset))
-			goto failed_read;
+static squashfs_inode_t squashfs_inode_lookup(struct super_block *s, int ino)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	long long start = msblk->inode_lookup_table[SQUASHFS_LOOKUP_BLOCK(ino - 1)];
+	int offset = SQUASHFS_LOOKUP_BLOCK_OFFSET(ino - 1);
+	squashfs_inode_t inode;
 
-	i->i_nlink = 1;
+	TRACE("Entered squashfs_inode_lookup, inode_number = %d\n", ino);
 
-	i->i_mtime.tv_sec = sBlk->mkfs_time;
-	i->i_atime.tv_sec = sBlk->mkfs_time;
-	i->i_ctime.tv_sec = sBlk->mkfs_time;
+	if (SQUASHFS_IS_BYTESWAPPED(msblk)) {
+		squashfs_inode_t sinode;
 
-	if(inodeb.inode_type != SQUASHFS_IPC_TYPE)
-		i->i_uid = msBlk->uid[((inodeb.inode_type - 1) / SQUASHFS_TYPES) * 16 + inodeb.uid];
-	i->i_ino = SQUASHFS_MK_VFS_INODE(block - sBlk->inode_table_start, offset);
+		if (!squashfs_get_cached_block(s, &sinode, start, offset,
+					sizeof(sinode), &start, &offset))
+			goto out;
+		SQUASHFS_SWAP_INODE_T((&inode), &sinode);
+	} else if (!squashfs_get_cached_block(s, &inode, start, offset,
+					sizeof(inode), &start, &offset))
+			goto out;
 
-	i->i_mode = inodeb.mode;
+	TRACE("squashfs_inode_lookup, inode = 0x%llx\n", inode);
 
-	switch(inodeb.inode_type == SQUASHFS_IPC_TYPE ? SQUASHFS_IPC_TYPE : (inodeb.inode_type - 1) % SQUASHFS_TYPES + 1) {
-		case SQUASHFS_FILE_TYPE: {
-			squashfs_reg_inode_header_1 inodep;
+	return inode;
 
-			if(msBlk->swap) {
-				squashfs_reg_inode_header_1 sinodep;
+out:
+	return SQUASHFS_INVALID_BLK;
+}
 
-				if(!squashfs_get_cached_block(s, (char *) &sinodep, block,  offset, sizeof(sinodep),
-							&next_block, &next_offset))
-					goto failed_read;
-				SQUASHFS_SWAP_REG_INODE_HEADER_1(&inodep, &sinodep);
-			} else
-				if(!squashfs_get_cached_block(s, (char *) &inodep, block,  offset, sizeof(inodep),
-							&next_block, &next_offset))
-					goto failed_read;
 
-			i->i_size = inodep.file_size;
-			i->i_fop = &generic_ro_fops;
-			if(sBlk->block_size > 4096)
-				i->i_data.a_ops = &squashfs_aops;
-			else if(sBlk->block_size == 4096)
-				i->i_data.a_ops = &squashfs_aops_4K;
-			else
-				i->i_data.a_ops = &squashfs_aops_lessthan4K;
-			i->i_mode |= S_IFREG;
-			i->i_mtime.tv_sec = inodep.mtime;
-			i->i_atime.tv_sec = inodep.mtime;
-			i->i_ctime.tv_sec = inodep.mtime;
-			i->i_blocks = ((i->i_size - 1) >> 9) + 1;
-			i->i_blksize = PAGE_CACHE_SIZE;
-			SQUASHFS_I(i)->u.s1.fragment_start_block = SQUASHFS_INVALID_BLK;
-			SQUASHFS_I(i)->u.s1.fragment_offset = 0;
-			SQUASHFS_I(i)->start_block = inodep.start_block;
-			SQUASHFS_I(i)->block_list_start = next_block;
-			SQUASHFS_I(i)->offset = next_offset;
-			TRACE("File inode %x:%x, start_block %x, block_list_start %x, offset %x\n",
-					SQUASHFS_INODE_BLK(inode), offset, inodep.start_block, next_block, next_offset);
-			break;
-		}
-		case SQUASHFS_DIR_TYPE: {
-			squashfs_dir_inode_header_1 inodep;
+static void vfs_read_inode(struct inode *i)
+{
+	struct squashfs_sb_info *msblk = i->i_sb->s_fs_info;
+	squashfs_inode_t inode = squashfs_inode_lookup(i->i_sb, i->i_ino);
 
-			if(msBlk->swap) {
-				squashfs_dir_inode_header_1 sinodep;
+	TRACE("Entered vfs_read_inode\n");
 
-				if(!squashfs_get_cached_block(s, (char *) &sinodep, block,  offset, sizeof(sinodep),
-							&next_block, &next_offset))
-					goto failed_read;
-				SQUASHFS_SWAP_DIR_INODE_HEADER_1(&inodep, &sinodep);
-			} else
-				if(!squashfs_get_cached_block(s, (char *) &inodep, block,  offset, sizeof(inodep),
-							&next_block, &next_offset))
-					goto failed_read;
+	if(inode != SQUASHFS_INVALID_BLK)
+		(msblk->read_inode)(i, inode);
+}
 
-			i->i_size = inodep.file_size;
-			i->i_op = &squashfs_dir_inode_ops;
-			i->i_fop = &squashfs_dir_ops;
-			i->i_mode |= S_IFDIR;
-			i->i_mtime.tv_sec = inodep.mtime;
-			i->i_atime.tv_sec = inodep.mtime;
-			i->i_ctime.tv_sec = inodep.mtime;
-			SQUASHFS_I(i)->start_block = inodep.start_block;
-			SQUASHFS_I(i)->offset = inodep.offset;
-			SQUASHFS_I(i)->u.s2.directory_index_count = 0;
-			TRACE("Directory inode %x:%x, start_block %x, offset %x\n", SQUASHFS_INODE_BLK(inode), offset,
-					inodep.start_block, inodep.offset);
-			break;
-		}
-		case SQUASHFS_SYMLINK_TYPE: {
-			squashfs_symlink_inode_header_1 inodep;
 	
-			if(msBlk->swap) {
-				squashfs_symlink_inode_header_1 sinodep;
+static struct dentry *squashfs_get_parent(struct dentry *child)
+{
+	struct inode *i = child->d_inode;
+	struct inode *parent = iget(i->i_sb, SQUASHFS_I(i)->u.s2.parent_inode);
+	struct dentry *rv;
 
-				if(!squashfs_get_cached_block(s, (char *) &sinodep, block,  offset, sizeof(sinodep),
-							&next_block, &next_offset))
-					goto failed_read;
-				SQUASHFS_SWAP_SYMLINK_INODE_HEADER_1(&inodep, &sinodep);
-			} else
-				if(!squashfs_get_cached_block(s, (char *) &inodep, block,  offset, sizeof(inodep),
-							&next_block, &next_offset))
-					goto failed_read;
+	TRACE("Entered squashfs_get_parent\n");
 
-			i->i_size = inodep.symlink_size;
-			i->i_op = &page_symlink_inode_operations;
-			i->i_data.a_ops = &squashfs_symlink_aops;
-			i->i_mode |= S_IFLNK;
-			SQUASHFS_I(i)->start_block = next_block;
-			SQUASHFS_I(i)->offset = next_offset;
-			TRACE("Symbolic link inode %x:%x, start_block %x, offset %x\n",
-				SQUASHFS_INODE_BLK(inode), offset, next_block, next_offset);
-			break;
+	if(parent == NULL) {
+		rv = ERR_PTR(-EACCES);
+		goto out;
 		 }
-		 case SQUASHFS_BLKDEV_TYPE:
-		 case SQUASHFS_CHRDEV_TYPE: {
-			squashfs_dev_inode_header_1 inodep;
 
-			if(msBlk->swap) {
-				squashfs_dev_inode_header_1 sinodep;
+	rv = d_alloc_anon(parent);
+	if(rv == NULL)
+		rv = ERR_PTR(-ENOMEM);
 
-				if(!squashfs_get_cached_block(s, (char *) &sinodep, block,  offset, sizeof(sinodep),
-							&next_block, &next_offset))
-					goto failed_read;
-				SQUASHFS_SWAP_DEV_INODE_HEADER_1(&inodep, &sinodep);
-			} else	
-				if(!squashfs_get_cached_block(s, (char *) &inodep, block,  offset, sizeof(inodep),
-							&next_block, &next_offset))
-					goto failed_read;
+out:
+	return rv;
+}
 
-			i->i_size = 0;
-			i->i_mode |= (inodeb.inode_type == SQUASHFS_CHRDEV_TYPE) ? S_IFCHR : S_IFBLK;
-			init_special_inode(i, i->i_mode, old_decode_dev(inodep.rdev));
-			TRACE("Device inode %x:%x, rdev %x\n", SQUASHFS_INODE_BLK(inode), offset, inodep.rdev);
-			break;
-		 }
-		 case SQUASHFS_IPC_TYPE: {
-			squashfs_ipc_inode_header_1 inodep;
 
-			if(msBlk->swap) {
-				squashfs_ipc_inode_header_1 sinodep;
+SQSH_EXTERN struct inode *squashfs_iget(struct super_block *s,
+				squashfs_inode_t inode, unsigned int inode_number)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct inode *i = iget_locked(s, inode_number);
 
-				if(!squashfs_get_cached_block(s, (char *) &sinodep, block,  offset, sizeof(sinodep),
-							&next_block, &next_offset))
-					goto failed_read;
-				SQUASHFS_SWAP_IPC_INODE_HEADER_1(&inodep, &sinodep);
-			} else	
-				if(!squashfs_get_cached_block(s, (char *) &inodep, block,  offset, sizeof(inodep),
-							&next_block, &next_offset))
-					goto failed_read;
+	TRACE("Entered squashfs_iget\n");
 
-			i->i_size = 0;
-			i->i_mode |= (inodep.type == SQUASHFS_FIFO_TYPE) ? S_IFIFO : S_IFSOCK;
-			i->i_uid = msBlk->uid[inodep.offset * 16 + inodeb.uid];
-			init_special_inode(i, i->i_mode, 0);
-			break;
-		 }
-		 default:
-			ERROR("Unknown inode type %d in squashfs_iget!\n", inodeb.inode_type);
-				goto failed_read1;
+	if(i && (i->i_state & I_NEW)) {
+		(msblk->read_inode)(i, inode);
+		unlock_new_inode(i);
 	}
 	
-	if(inodeb.guid == 15)
-		i->i_gid = i->i_uid;
-	else
-		i->i_gid = msBlk->guid[inodeb.guid];
-
-	insert_inode_hash(i);
 	return i;
-
-failed_read:
-	ERROR("Unable to read inode [%x:%x]\n", block, offset);
-
-failed_read1:
-	return NULL;
 }
-#endif
 
 
-static struct inode *squashfs_iget(struct super_block *s, squashfs_inode inode)
+static int squashfs_read_inode(struct inode *i, squashfs_inode_t inode)
 {
-	struct inode *i = new_inode(s);
-	squashfs_sb_info *msBlk = (squashfs_sb_info *)s->s_fs_info;
-	squashfs_super_block *sBlk = &msBlk->sBlk;
-	unsigned int block = SQUASHFS_INODE_BLK(inode) + sBlk->inode_table_start;
+	struct super_block *s = i->i_sb;
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	long long block = SQUASHFS_INODE_BLK(inode) + sblk->inode_table_start;
 	unsigned int offset = SQUASHFS_INODE_OFFSET(inode);
-	unsigned int next_block, next_offset;
-	squashfs_base_inode_header inodeb;
-
-	TRACE("[squashfs_iget] 0x%Lx block 0x%x offset 0x%x inode_table_start 0x%x\n", inode, block, offset, sBlk->inode_table_start);
-
-	if(msBlk->swap) {
-		squashfs_base_inode_header sinodeb;
-
-		if(!squashfs_get_cached_block(s, (char *) &sinodeb, block,  offset,
-					sizeof(sinodeb), &next_block, &next_offset))
+	long long next_block;
+	unsigned int next_offset;
+	union squashfs_inode_header id, sid;
+	struct squashfs_base_inode_header *inodeb = &id.base, *sinodeb = &sid.base;
+
+	TRACE("Entered squashfs_read_inode\n");
+
+	if (SQUASHFS_IS_BYTESWAPPED(msblk)) {
+		if (!squashfs_get_cached_block(s, sinodeb, block, offset,
+					sizeof(*sinodeb), &next_block, &next_offset))
 			goto failed_read;
-		SQUASHFS_SWAP_BASE_INODE_HEADER(&inodeb, &sinodeb, sizeof(sinodeb));
+		SQUASHFS_SWAP_BASE_INODE_HEADER(inodeb, sinodeb, sizeof(*sinodeb));
 	} else
-		if(!squashfs_get_cached_block(s, (char *) &inodeb, block,  offset,
-					sizeof(inodeb), &next_block, &next_offset)) {
+		if (!squashfs_get_cached_block(s, inodeb, block, offset,
+					sizeof(*inodeb), &next_block, &next_offset))
 			goto failed_read;
-        }
 
-	i->i_nlink = 1;
+	squashfs_new_inode(msblk, i, inodeb);
 
-	i->i_mtime.tv_sec = sBlk->mkfs_time;
-	i->i_atime.tv_sec = sBlk->mkfs_time;
-	i->i_ctime.tv_sec = sBlk->mkfs_time;
-
-	i->i_uid = msBlk->uid[inodeb.uid];
-	i->i_ino = SQUASHFS_MK_VFS_INODE(block - sBlk->inode_table_start, offset);
+	switch(inodeb->inode_type) {
+		case SQUASHFS_FILE_TYPE: {
+			unsigned int frag_size;
+			long long frag_blk;
+			struct squashfs_reg_inode_header *inodep = &id.reg;
+			struct squashfs_reg_inode_header *sinodep = &sid.reg;
+				
+			if (SQUASHFS_IS_BYTESWAPPED(msblk)) {
+				if (!squashfs_get_cached_block(s, sinodep, block, offset,
+						sizeof(*sinodep), &next_block, &next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_REG_INODE_HEADER(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, inodep, block, offset,
+						sizeof(*inodep), &next_block, &next_offset))
+					goto failed_read;
 
-	i->i_mode = inodeb.mode;
+			frag_blk = SQUASHFS_INVALID_BLK;
 
-	switch(inodeb.inode_type) {
-		case SQUASHFS_FILE_TYPE: {
-			squashfs_reg_inode_header inodep;
+			if (inodep->fragment != SQUASHFS_INVALID_FRAG)
+					if(!get_fragment_location(s, inodep->fragment, &frag_blk,
+												&frag_size))
+						goto failed_read;
 
-			if(msBlk->swap) {
-				squashfs_reg_inode_header sinodep;
+			i->i_nlink = 1;
+			i->i_size = inodep->file_size;
+			i->i_fop = &generic_ro_fops;
+			i->i_mode |= S_IFREG;
+			i->i_blocks = ((i->i_size - 1) >> 9) + 1;
+			SQUASHFS_I(i)->u.s1.fragment_start_block = frag_blk;
+			SQUASHFS_I(i)->u.s1.fragment_size = frag_size;
+			SQUASHFS_I(i)->u.s1.fragment_offset = inodep->offset;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->u.s1.block_list_start = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+			i->i_data.a_ops = &squashfs_aops;
 
-				if(!squashfs_get_cached_block(s, (char *) &sinodep, block,  offset, sizeof(sinodep),
-							&next_block, &next_offset))
+			TRACE("File inode %x:%x, start_block %llx, "
+					"block_list_start %llx, offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->start_block, next_block,
+					next_offset);
+			break;
+		}
+		case SQUASHFS_LREG_TYPE: {
+			unsigned int frag_size;
+			long long frag_blk;
+			struct squashfs_lreg_inode_header *inodep = &id.lreg;
+			struct squashfs_lreg_inode_header *sinodep = &sid.lreg;
+				
+			if (SQUASHFS_IS_BYTESWAPPED(msblk)) {
+				if (!squashfs_get_cached_block(s, sinodep, block, offset,
+						sizeof(*sinodep), &next_block, &next_offset))
 					goto failed_read;
-				SQUASHFS_SWAP_REG_INODE_HEADER(&inodep, &sinodep);
+				SQUASHFS_SWAP_LREG_INODE_HEADER(inodep, sinodep);
 			} else
-				if(!squashfs_get_cached_block(s, (char *) &inodep, block,  offset, sizeof(inodep),
-							&next_block, &next_offset))
+				if (!squashfs_get_cached_block(s, inodep, block, offset,
+						sizeof(*inodep), &next_block, &next_offset))
 					goto failed_read;
 
-			SQUASHFS_I(i)->u.s1.fragment_start_block = SQUASHFS_INVALID_BLK;
-			if(inodep.fragment != SQUASHFS_INVALID_BLK && !get_fragment_location(s, inodep.fragment,
-							&SQUASHFS_I(i)->u.s1.fragment_start_block, &SQUASHFS_I(i)->u.s1.fragment_size))
+			frag_blk = SQUASHFS_INVALID_BLK;
+
+			if (inodep->fragment != SQUASHFS_INVALID_FRAG)
+				if (!get_fragment_location(s, inodep->fragment, &frag_blk,
+												 &frag_size))
 				goto failed_read;
 
-			SQUASHFS_I(i)->u.s1.fragment_offset = inodep.offset;
-			i->i_size = inodep.file_size;
+			i->i_nlink = inodep->nlink;
+			i->i_size = inodep->file_size;
 			i->i_fop = &generic_ro_fops;
-			if(sBlk->block_size > 4096)
-				i->i_data.a_ops = &squashfs_aops;
-			else
-				i->i_data.a_ops = &squashfs_aops_4K;
 			i->i_mode |= S_IFREG;
-			i->i_mtime.tv_sec = inodep.mtime;
-			i->i_atime.tv_sec = inodep.mtime;
-			i->i_ctime.tv_sec = inodep.mtime;
 			i->i_blocks = ((i->i_size - 1) >> 9) + 1;
-			i->i_blksize = PAGE_CACHE_SIZE;
-			SQUASHFS_I(i)->start_block = inodep.start_block;
-			SQUASHFS_I(i)->block_list_start = next_block;
+			SQUASHFS_I(i)->u.s1.fragment_start_block = frag_blk;
+			SQUASHFS_I(i)->u.s1.fragment_size = frag_size;
+			SQUASHFS_I(i)->u.s1.fragment_offset = inodep->offset;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->u.s1.block_list_start = next_block;
 			SQUASHFS_I(i)->offset = next_offset;
-			TRACE("File inode %x:%x, start_block %x, block_list_start %x, offset %x\n",
-					SQUASHFS_INODE_BLK(inode), offset, inodep.start_block, next_block, next_offset);
+			i->i_data.a_ops = &squashfs_aops;
+
+			TRACE("File inode %x:%x, start_block %llx, "
+					"block_list_start %llx, offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->start_block, next_block,
+					next_offset);
 			break;
 		}
 		case SQUASHFS_DIR_TYPE: {
-			squashfs_dir_inode_header inodep;
+			struct squashfs_dir_inode_header *inodep = &id.dir;
+			struct squashfs_dir_inode_header *sinodep = &sid.dir;
 
-			if(msBlk->swap) {
-				squashfs_dir_inode_header sinodep;
-
-				if(!squashfs_get_cached_block(s, (char *) &sinodep, block,  offset, sizeof(sinodep),
-							&next_block, &next_offset))
+			if (SQUASHFS_IS_BYTESWAPPED(msblk)) {
+				if (!squashfs_get_cached_block(s, sinodep, block, offset,
+						sizeof(*sinodep), &next_block, &next_offset))
 					goto failed_read;
-				SQUASHFS_SWAP_DIR_INODE_HEADER(&inodep, &sinodep);
+				SQUASHFS_SWAP_DIR_INODE_HEADER(inodep, sinodep);
 			} else
-				if(!squashfs_get_cached_block(s, (char *) &inodep, block,  offset, sizeof(inodep),
-							&next_block, &next_offset))
+				if (!squashfs_get_cached_block(s, inodep, block, offset,
+						sizeof(*inodep), &next_block, &next_offset))
 					goto failed_read;
 
-			i->i_size = inodep.file_size;
+			i->i_nlink = inodep->nlink;
+			i->i_size = inodep->file_size;
 			i->i_op = &squashfs_dir_inode_ops;
 			i->i_fop = &squashfs_dir_ops;
 			i->i_mode |= S_IFDIR;
-			i->i_mtime.tv_sec = inodep.mtime;
-			i->i_atime.tv_sec = inodep.mtime;
-			i->i_ctime.tv_sec = inodep.mtime;
-			SQUASHFS_I(i)->start_block = inodep.start_block;
-			SQUASHFS_I(i)->offset = inodep.offset;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->offset = inodep->offset;
 			SQUASHFS_I(i)->u.s2.directory_index_count = 0;
-			TRACE("Directory inode %x:%x, start_block %x, offset %x\n", SQUASHFS_INODE_BLK(inode), offset,
-					inodep.start_block, inodep.offset);
+			SQUASHFS_I(i)->u.s2.parent_inode = inodep->parent_inode;
+
+			TRACE("Directory inode %x:%x, start_block %x, offset "
+					"%x\n", SQUASHFS_INODE_BLK(inode),
+					offset, inodep->start_block,
+					inodep->offset);
 			break;
 		}
 		case SQUASHFS_LDIR_TYPE: {
-			squashfs_ldir_inode_header inodep;
+			struct squashfs_ldir_inode_header *inodep = &id.ldir;
+			struct squashfs_ldir_inode_header *sinodep = &sid.ldir;
 
-			if(msBlk->swap) {
-				squashfs_ldir_inode_header sinodep;
-
-				if(!squashfs_get_cached_block(s, (char *) &sinodep, block,  offset, sizeof(sinodep),
-							&next_block, &next_offset))
+			if (SQUASHFS_IS_BYTESWAPPED(msblk)) {
+				if (!squashfs_get_cached_block(s, sinodep, block, offset,
+						sizeof(*sinodep), &next_block, &next_offset))
 					goto failed_read;
-				SQUASHFS_SWAP_LDIR_INODE_HEADER(&inodep, &sinodep);
+				SQUASHFS_SWAP_LDIR_INODE_HEADER(inodep, sinodep);
 			} else
-				if(!squashfs_get_cached_block(s, (char *) &inodep, block,  offset, sizeof(inodep),
-							&next_block, &next_offset))
+				if (!squashfs_get_cached_block(s, inodep, block, offset,
+						sizeof(*inodep), &next_block, &next_offset))
 					goto failed_read;
 
-			i->i_size = inodep.file_size;
+			i->i_nlink = inodep->nlink;
+			i->i_size = inodep->file_size;
 			i->i_op = &squashfs_dir_inode_ops;
 			i->i_fop = &squashfs_dir_ops;
 			i->i_mode |= S_IFDIR;
-			i->i_mtime.tv_sec = inodep.mtime;
-			i->i_atime.tv_sec = inodep.mtime;
-			i->i_ctime.tv_sec = inodep.mtime;
-			SQUASHFS_I(i)->start_block = inodep.start_block;
-			SQUASHFS_I(i)->offset = inodep.offset;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->offset = inodep->offset;
 			SQUASHFS_I(i)->u.s2.directory_index_start = next_block;
 			SQUASHFS_I(i)->u.s2.directory_index_offset = next_offset;
-			SQUASHFS_I(i)->u.s2.directory_index_count = inodep.i_count;
-			TRACE("Long directory inode %x:%x, start_block %x, offset %x\n", SQUASHFS_INODE_BLK(inode), offset,
-					inodep.start_block, inodep.offset);
+			SQUASHFS_I(i)->u.s2.directory_index_count = inodep->i_count;
+			SQUASHFS_I(i)->u.s2.parent_inode = inodep->parent_inode;
+
+			TRACE("Long directory inode %x:%x, start_block %x, offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->start_block, inodep->offset);
 			break;
 		}
 		case SQUASHFS_SYMLINK_TYPE: {
-			squashfs_symlink_inode_header inodep;
-	
-			if(msBlk->swap) {
-				squashfs_symlink_inode_header sinodep;
+			struct squashfs_symlink_inode_header *inodep = &id.symlink;
+			struct squashfs_symlink_inode_header *sinodep = &sid.symlink;
 
-				if(!squashfs_get_cached_block(s, (char *) &sinodep, block,  offset, sizeof(sinodep),
-							&next_block, &next_offset))
+			if (SQUASHFS_IS_BYTESWAPPED(msblk)) {
+				if (!squashfs_get_cached_block(s, sinodep, block, offset,
+						sizeof(*sinodep), &next_block, &next_offset))
 					goto failed_read;
-				SQUASHFS_SWAP_SYMLINK_INODE_HEADER(&inodep, &sinodep);
+				SQUASHFS_SWAP_SYMLINK_INODE_HEADER(inodep, sinodep);
 			} else
-				if(!squashfs_get_cached_block(s, (char *) &inodep, block,  offset, sizeof(inodep),
-							&next_block, &next_offset))
+				if (!squashfs_get_cached_block(s, inodep, block, offset,
+						sizeof(*inodep), &next_block, &next_offset))
 					goto failed_read;
 
-			i->i_size = inodep.symlink_size;
+			i->i_nlink = inodep->nlink;
+			i->i_size = inodep->symlink_size;
 			i->i_op = &page_symlink_inode_operations;
 			i->i_data.a_ops = &squashfs_symlink_aops;
 			i->i_mode |= S_IFLNK;
 			SQUASHFS_I(i)->start_block = next_block;
 			SQUASHFS_I(i)->offset = next_offset;
-			TRACE("Symbolic link inode %x:%x, start_block %x, offset %x\n",
-				SQUASHFS_INODE_BLK(inode), offset, next_block, next_offset);
+
+			TRACE("Symbolic link inode %x:%x, start_block %llx, offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					next_block, next_offset);
 			break;
 		 }
 		 case SQUASHFS_BLKDEV_TYPE:
 		 case SQUASHFS_CHRDEV_TYPE: {
-			squashfs_dev_inode_header inodep;
-
-			if(msBlk->swap) {
-				squashfs_dev_inode_header sinodep;
+			struct squashfs_dev_inode_header *inodep = &id.dev;
+			struct squashfs_dev_inode_header *sinodep = &sid.dev;
 
-				if(!squashfs_get_cached_block(s, (char *) &sinodep, block,  offset, sizeof(sinodep),
-							&next_block, &next_offset))
+			if (SQUASHFS_IS_BYTESWAPPED(msblk)) {
+				if (!squashfs_get_cached_block(s, sinodep, block, offset,
+						sizeof(*sinodep), &next_block, &next_offset))
 					goto failed_read;
-				SQUASHFS_SWAP_DEV_INODE_HEADER(&inodep, &sinodep);
+				SQUASHFS_SWAP_DEV_INODE_HEADER(inodep, sinodep);
 			} else	
-				if(!squashfs_get_cached_block(s, (char *) &inodep, block,  offset, sizeof(inodep),
-							&next_block, &next_offset))
+				if (!squashfs_get_cached_block(s, inodep, block, offset,
+						sizeof(*inodep), &next_block, &next_offset))
 					goto failed_read;
 
-			i->i_size = 0;
-			i->i_mode |= (inodeb.inode_type == SQUASHFS_CHRDEV_TYPE) ? S_IFCHR : S_IFBLK;
-			init_special_inode(i, i->i_mode, old_decode_dev(inodep.rdev));
-			TRACE("Device inode %x:%x, rdev %x\n", SQUASHFS_INODE_BLK(inode), offset, inodep.rdev);
+			i->i_nlink = inodep->nlink;
+			i->i_mode |= (inodeb->inode_type == SQUASHFS_CHRDEV_TYPE) ?
+					S_IFCHR : S_IFBLK;
+			init_special_inode(i, i->i_mode, old_decode_dev(inodep->rdev));
+
+			TRACE("Device inode %x:%x, rdev %x\n",
+					SQUASHFS_INODE_BLK(inode), offset, inodep->rdev);
 			break;
 		 }
 		 case SQUASHFS_FIFO_TYPE:
 		 case SQUASHFS_SOCKET_TYPE: {
-			i->i_size = 0;
-			i->i_mode |= (inodeb.inode_type == SQUASHFS_FIFO_TYPE) ? S_IFIFO : S_IFSOCK;
+			struct squashfs_ipc_inode_header *inodep = &id.ipc;
+			struct squashfs_ipc_inode_header *sinodep = &sid.ipc;
+
+			if (SQUASHFS_IS_BYTESWAPPED(msblk)) {
+				if (!squashfs_get_cached_block(s, sinodep, block, offset,
+						sizeof(*sinodep), &next_block, &next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_IPC_INODE_HEADER(inodep, sinodep);
+			} else	
+				if (!squashfs_get_cached_block(s, inodep, block, offset,
+						sizeof(*inodep), &next_block, &next_offset))
+					goto failed_read;
+
+			i->i_nlink = inodep->nlink;
+			i->i_mode |= (inodeb->inode_type == SQUASHFS_FIFO_TYPE)
+							? S_IFIFO : S_IFSOCK;
 			init_special_inode(i, i->i_mode, 0);
 			break;
 		 }
 		 default:
-			ERROR("Unknown inode type %d in squashfs_iget!\n", inodeb.inode_type);
+			ERROR("Unknown inode type %d in squashfs_iget!\n",
+					inodeb->inode_type);
 				goto failed_read1;
 	}
 	
-	if(inodeb.guid == SQUASHFS_GUIDS)
-		i->i_gid = i->i_uid;
-	else
-		i->i_gid = msBlk->guid[inodeb.guid];
-	insert_inode_hash(i);
-	return i;
+	return 1;
 
 failed_read:
-	ERROR("Unable to read inode [%x:%x]\n", block, offset);
+	ERROR("Unable to read inode [%llx:%x]\n", block, offset);
+
+failed_read1:
+	make_bad_inode(i);
+	return 0;
+}
+
+
+static int read_inode_lookup_table(struct super_block *s)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	unsigned int length = SQUASHFS_LOOKUP_BLOCK_BYTES(sblk->inodes);
+
+	TRACE("In read_inode_lookup_table, length %d\n", length);
+
+	/* Allocate inode lookup table */
+	msblk->inode_lookup_table = kmalloc(length, GFP_KERNEL);
+	if (msblk->inode_lookup_table == NULL) {
+		ERROR("Failed to allocate inode lookup table\n");
+		return 0;
+	}
+   
+	if (!squashfs_read_data(s, (char *) msblk->inode_lookup_table,
+			sblk->lookup_table_start, length |
+			SQUASHFS_COMPRESSED_BIT_BLOCK, NULL, length)) {
+		ERROR("unable to read inode lookup table\n");
+		return 0;
+	}
+
+	if (SQUASHFS_IS_BYTESWAPPED(msblk)) {
+		int i;
+		long long block;
+
+		for (i = 0; i < SQUASHFS_LOOKUP_BLOCKS(sblk->inodes); i++) {
+			/* XXX */
+			SQUASHFS_SWAP_LOOKUP_BLOCKS((&block),
+						&msblk->inode_lookup_table[i], 1);
+			msblk->inode_lookup_table[i] = block;
+		}
+	}
+
+	return 1;
+}
+
+
+static int read_fragment_index_table(struct super_block *s)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	unsigned int length = SQUASHFS_FRAGMENT_INDEX_BYTES(sblk->fragments);
+
+	if(length == 0)
+		return 1;
+
+	/* Allocate fragment index table */
+	msblk->fragment_index = kmalloc(length, GFP_KERNEL);
+	if (msblk->fragment_index == NULL) {
+		ERROR("Failed to allocate fragment index table\n");
+		return 0;
+	}
+   
+	if (!squashfs_read_data(s, (char *) msblk->fragment_index,
+			sblk->fragment_table_start, length |
+			SQUASHFS_COMPRESSED_BIT_BLOCK, NULL, length)) {
+		ERROR("unable to read fragment index table\n");
+		return 0;
+	}
+
+	if (SQUASHFS_IS_BYTESWAPPED(msblk)) {
+		int i;
+		long long fragment;
+
+		for (i = 0; i < SQUASHFS_FRAGMENT_INDEXES(sblk->fragments); i++) {
+			/* XXX */
+			SQUASHFS_SWAP_FRAGMENT_INDEXES((&fragment),
+						&msblk->fragment_index[i], 1);
+			msblk->fragment_index[i] = fragment;
+		}
+	}
+
+	return 1;
+}
+
+
+static int readahead_metadata(struct super_block *s)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	int i;
+
+	//squashfs_cached_blks = SQUASHFS_CACHED_BLKS;
+
+	/* Init inode_table block pointer array */
+	msblk->block_cache = kmalloc(sizeof(struct squashfs_cache) *
+					squashfs_cached_blks, GFP_KERNEL);
+	if (msblk->block_cache == NULL) {
+		ERROR("Failed to allocate block cache\n");
+		goto failed;
+	}
+
+	for (i = 0; i < squashfs_cached_blks; i++)
+		msblk->block_cache[i].block = SQUASHFS_INVALID_BLK;
+
+	msblk->next_cache = 0;
+	msblk->unused_cache_blks = squashfs_cached_blks;
+
+	return 1;
+
+failed:
+	return 0;
+}
+
+
+static int supported_squashfs_filesystem(struct squashfs_sb_info *msblk, int silent)
+{
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	msblk->read_inode = squashfs_read_inode;
+	msblk->read_blocklist = read_blocklist;
+	msblk->read_fragment_index_table = read_fragment_index_table;
+
+	if (sblk->s_major == 1) {
+		if (!squashfs_1_0_supported(msblk)) {
+			SERROR("Major/Minor mismatch, Squashfs 1.0 filesystems "
+				"are unsupported\n");
+			SERROR("Please recompile with Squashfs 1.0 support enabled\n");
+			return 0;
+		}
+	} else if (sblk->s_major == 2) {
+		if (!squashfs_2_0_supported(msblk)) {
+			SERROR("Major/Minor mismatch, Squashfs 2.0 filesystems "
+				"are unsupported\n");
+			SERROR("Please recompile with Squashfs 2.0 support enabled\n");
+			return 0;
+		}
+	} else if (sblk->s_major != SQUASHFS_MAJOR || 
+		   (sblk->s_minor > SQUASHFS_MINOR && 
+		    sblk->s_minor != SQUASHFS_MINOR_LZMA)) {
+		SERROR("Major/Minor mismatch, trying to mount newer %d.%d "
+				"filesystem\n", sblk->s_major, sblk->s_minor);
+		SERROR("Please update your kernel\n");
+		return 0;
+	}
 
-failed_read1:
-	return NULL;
+	return 1;
 }
 
 
-static int squashfs_fill_super(struct super_block *s,
-		void *data, int silent)
+static int squashfs_fill_super(struct super_block *s, void *data, int silent)
 {
-	squashfs_sb_info *msBlk;
-	squashfs_super_block *sBlk;
+	struct squashfs_sb_info *msblk;
+	struct squashfs_super_block *sblk;
 	int i;
 	char b[BDEVNAME_SIZE];
+	struct inode *root;
 
-	TRACE("Entered squashfs_read_superblock\n");
+	TRACE("Entered squashfs_fill_superblock\n");
 
-	if(!(s->s_fs_info = (void *) kmalloc(sizeof(squashfs_sb_info), GFP_KERNEL))) {
+	s->s_fs_info = kzalloc(sizeof(struct squashfs_sb_info), GFP_KERNEL);
+	if (s->s_fs_info == NULL) {
 		ERROR("Failed to allocate superblock\n");
-		return -ENOMEM;
+		goto failure;
 	}
-	msBlk = (squashfs_sb_info *) s->s_fs_info;
-	sBlk = &msBlk->sBlk;
-	
-	msBlk->devblksize = sb_min_blocksize(s, BLOCK_SIZE);
-	msBlk->devblksize_log2 = ffz(~msBlk->devblksize);
-
-	init_MUTEX(&msBlk->read_page_mutex);
-	init_MUTEX(&msBlk->block_cache_mutex);
-	init_MUTEX(&msBlk->fragment_mutex);
-	
-	init_waitqueue_head(&msBlk->waitq);
-	init_waitqueue_head(&msBlk->fragment_wait_queue);
+	msblk = s->s_fs_info;
+#ifdef CONFIG_SQUASH_ZLIB
+	msblk->stream.workspace = vmalloc(zlib_inflate_workspacesize());
+	if (msblk->stream.workspace == NULL) {
+		ERROR("Failed to allocate zlib workspace\n");
+		goto failure;
+	}
+#endif
+	sblk = &msblk->sblk;
 
-	if(!read_data(s, (char *) sBlk, SQUASHFS_START, sizeof(squashfs_super_block) | SQUASHFS_COMPRESSED_BIT_BLOCK, NULL)) {
+#undef BLOCK_SIZE
+#define BLOCK_SIZE PAGE_SIZE
+	msblk->devblksize = sb_min_blocksize(s, BLOCK_SIZE);
+	msblk->devblksize_log2 = ffz(~msblk->devblksize);
+
+	mutex_init(&msblk->read_data_mutex);
+	mutex_init(&msblk->read_page_mutex);
+	mutex_init(&msblk->block_cache_mutex);
+	mutex_init(&msblk->fragment_mutex);
+	mutex_init(&msblk->meta_index_mutex);
+
+	init_waitqueue_head(&msblk->waitq);
+	init_waitqueue_head(&msblk->fragment_wait_queue);
+
+	/* sblk->bytes_used is checked in squashfs_read_data to ensure reads are not
+ 	 * beyond filesystem end.  As we're using squashfs_read_data to read sblk here,
+ 	 * first set sblk->bytes_used to a useful value */
+	sblk->bytes_used = sizeof(struct squashfs_super_block);
+	if (!squashfs_read_data(s, (char *) sblk, SQUASHFS_START,
+					sizeof(struct squashfs_super_block) |
+					SQUASHFS_COMPRESSED_BIT_BLOCK, NULL, sizeof(struct squashfs_super_block))) {
 		SERROR("unable to read superblock\n");
 		goto failed_mount;
 	}
 
 	/* Check it is a SQUASHFS superblock */
-	msBlk->swap = 0;
-	if((s->s_magic = sBlk->s_magic) != SQUASHFS_MAGIC) {
-		if(sBlk->s_magic == SQUASHFS_MAGIC_SWAP) {
-			squashfs_super_block sblk;
-			WARNING("Mounting a different endian SQUASHFS filesystem on %s\n", bdevname(s->s_bdev, b));
-			SQUASHFS_SWAP_SUPER_BLOCK(&sblk, sBlk);
-			memcpy(sBlk, &sblk, sizeof(squashfs_super_block));
-			msBlk->swap = 1;
+	if ((s->s_magic = sblk->s_magic) != SQUASHFS_MAGIC) {
+		if (
+#ifdef CONFIG_SQUASHFS_BYTESWAPPED
+		    sblk->s_magic == SQUASHFS_MAGIC_SWAP ||
+#endif
+		    0) {
+			struct squashfs_super_block ssblk;
+
+			WARNING("Mounting a different endian SQUASHFS filesystem on %s\n",
+				bdevname(s->s_bdev, b));
+
+			SQUASHFS_SWAP_SUPER_BLOCK(&ssblk, sblk);
+			memcpy(sblk, &ssblk, sizeof(struct squashfs_super_block));
+			msblk->swap = 1;
 		} else  {
-			SERROR("Can't find a SQUASHFS superblock on %s\n", bdevname(s->s_bdev, b));
+			SERROR("Can't find a SQUASHFS superblock on %s\n",
+							bdevname(s->s_bdev, b));
 			goto failed_mount;
 		}
 	}
 
 	/* Check the MAJOR & MINOR versions */
-#ifdef SQUASHFS_1_0_COMPATIBILITY
-	if((sBlk->s_major != 1) && (sBlk->s_major != 2 || sBlk->s_minor > SQUASHFS_MINOR)) {
-		SERROR("Major/Minor mismatch, filesystem is (%d:%d), I support (1 : x) or (2 : <= %d)\n",
-				sBlk->s_major, sBlk->s_minor, SQUASHFS_MINOR);
+	if(!supported_squashfs_filesystem(msblk, silent))
 		goto failed_mount;
-	}
-	if(sBlk->s_major == 1)
-		sBlk->block_size = sBlk->block_size_1;
-#else
-	if(sBlk->s_major != SQUASHFS_MAJOR || ((sBlk->s_minor > SQUASHFS_MINOR) && (sBlk->s_minor != SQUASHFS_MINOR_LZMA))) {
-		SERROR("Major/Minor mismatch, filesystem is (%d:%d), I support (%d: <= %d)\n",
-				sBlk->s_major, sBlk->s_minor, SQUASHFS_MAJOR, SQUASHFS_MINOR);
+
+	/* Check the filesystem does not extend beyond the end of the
+	   block device */
+	if(sblk->bytes_used < 0 || sblk->bytes_used > i_size_read(s->s_bdev->bd_inode))
+		goto failed_mount;
+
+	/* Check the root inode for sanity */
+	if (SQUASHFS_INODE_OFFSET(sblk->root_inode) > SQUASHFS_METADATA_SIZE)
 		goto failed_mount;
-	}
-#endif
 
 	TRACE("Found valid superblock on %s\n", bdevname(s->s_bdev, b));
-	TRACE("Inodes are %scompressed\n", SQUASHFS_UNCOMPRESSED_INODES(sBlk->flags) ? "un" : "");
-	TRACE("Data is %scompressed\n", SQUASHFS_UNCOMPRESSED_DATA(sBlk->flags) ? "un" : "");
-	TRACE("Check data is %s present in the filesystem\n", SQUASHFS_CHECK_DATA(sBlk->flags) ? "" : "not");
-	TRACE("Filesystem size %d bytes\n", sBlk->bytes_used);
-	TRACE("Block size %d\n", sBlk->block_size);
-	TRACE("Number of inodes %d\n", sBlk->inodes);
-	if(sBlk->s_major > 1)
-		TRACE("Number of fragments %d\n", sBlk->fragments);
-	TRACE("Number of uids %d\n", sBlk->no_uids);
-	TRACE("Number of gids %d\n", sBlk->no_guids);
-	TRACE("sBlk->inode_table_start %x\n", sBlk->inode_table_start);
-	TRACE("sBlk->directory_table_start %x\n", sBlk->directory_table_start);
-    if(sBlk->s_major > 1)
-        TRACE("sBlk->fragment_table_start %x\n", sBlk->fragment_table_start);
-	TRACE("sBlk->uid_start %x\n", sBlk->uid_start);
-    if (sBlk->s_minor == SQUASHFS_MINOR_LZMA) {
-        printk("use lzma compression \n");
-        vfree(stream.workspace);    /*--- alloc new buffer for decompression, free zlib ---*/ 
-        lzma_decoder_state.Properties.lc = 3;  /*--- parameter mit denen komprimiert wurde ---*/
-        lzma_decoder_state.Properties.lp = 0;
-        lzma_decoder_state.Properties.pb = 2;
-        TRACE("alloc %d Bytes memory for lzma\n", LzmaGetNumProbs(&lzma_decoder_state.Properties) * sizeof(CProb));
-        lzma_decoder_state.Probs = (CProb *)vmalloc(LzmaGetNumProbs(&lzma_decoder_state.Properties) * sizeof(CProb));
-        if (!lzma_decoder_state.Probs) {
+	TRACE("Inodes are %scompressed\n", SQUASHFS_UNCOMPRESSED_INODES(sblk->flags)
+					? "un" : "");
+	TRACE("Data is %scompressed\n", SQUASHFS_UNCOMPRESSED_DATA(sblk->flags)
+					? "un" : "");
+	TRACE("Check data is %spresent in the filesystem\n",
+					SQUASHFS_CHECK_DATA(sblk->flags) ?  "" : "not ");
+	TRACE("Filesystem size %lld bytes\n", sblk->bytes_used);
+	TRACE("Block size %d\n", sblk->block_size);
+	TRACE("Number of inodes %d\n", sblk->inodes);
+	if (sblk->s_major > 1)
+		TRACE("Number of fragments %d\n", sblk->fragments);
+	TRACE("Number of uids %d\n", sblk->no_uids);
+	TRACE("Number of gids %d\n", sblk->no_guids);
+	TRACE("sblk->inode_table_start %llx\n", sblk->inode_table_start);
+	TRACE("sblk->directory_table_start %llx\n", sblk->directory_table_start);
+	if (sblk->s_major > 1)
+		TRACE("sblk->fragment_table_start %llx\n", sblk->fragment_table_start);
+	TRACE("sblk->uid_start %llx\n", sblk->uid_start);
+
+	if(sblk->s_minor == SQUASHFS_MINOR_LZMA) {
+		int NumProbs;
+		msblk->lzma_decoder_state.Properties.lc = 3;  /*--- parameter mit denen komprimiert wurde ---*/
+		msblk->lzma_decoder_state.Properties.lp = 0;
+		msblk->lzma_decoder_state.Properties.pb = 2;
+		NumProbs = LzmaGetNumProbs(&msblk->lzma_decoder_state.Properties);
+		printk ("NumProbs = %d / %d -> %d\n", NumProbs, sizeof(CProb), NumProbs * sizeof(CProb));
+		msblk->lzma_decoder_state.Probs = (CProb *)vmalloc(NumProbs * sizeof(CProb));
+		if (!msblk->lzma_decoder_state.Probs) {
             ERROR("Failed to allocate memory for lzma\n");
             goto failed_mount;
         }
-        use_lzma = 1;
+		//msblk->use_lzma = 1;
+	} else {
+		//msblk->use_lzma = 0;
+		goto failed_mount;
     }
-
+	s->s_maxbytes = MAX_LFS_FILESIZE;
 	s->s_flags |= MS_RDONLY;
-	s->s_op = &squashfs_ops;
-#if defined(CONFIG_NFSD) || defined(CONFIG_NFSD_MODULE)
-    s->s_export_op = &squashfs_export_ops;
-#endif
+	s->s_op = &squashfs_super_ops;
 
-	/* Init inode_table block pointer array */
-	if(!(msBlk->block_cache = (squashfs_cache *) kmalloc(sizeof(squashfs_cache) * SQUASHFS_CACHED_BLKS, GFP_KERNEL))) {
-		ERROR("Failed to allocate block cache\n");
+	if (readahead_metadata(s) == 0)
 		goto failed_mount;
-	}
-
-	for(i = 0; i < SQUASHFS_CACHED_BLKS; i++)
-		msBlk->block_cache[i].block = SQUASHFS_INVALID_BLK;
-
-	msBlk->next_cache = 0;
-
-	/* Allocate read_data block */
-	msBlk->read_size = (sBlk->block_size < SQUASHFS_METADATA_SIZE) ? SQUASHFS_METADATA_SIZE : sBlk->block_size;
-	if(!(msBlk->read_data = (char *) kmalloc(msBlk->read_size, GFP_KERNEL))) {
-		ERROR("Failed to allocate read_data block\n");
-		goto failed_mount1;
-	}
 
 	/* Allocate read_page block */
-	if(sBlk->block_size > PAGE_CACHE_SIZE) {
-		if(!(msBlk->read_page = (char *) kmalloc(sBlk->block_size, GFP_KERNEL))) {
-			ERROR("Failed to allocate read_page block\n");
-			goto failed_mount2;
+	msblk->read_page = vmalloc(sblk->block_size);
+	if (msblk->read_page == NULL) {
+		ERROR("Failed to allocate read_page block (%d)\n", sblk->block_size);
+		goto failed_mount;
 		}
-	} else
-		msBlk->read_page = NULL;
 
 	/* Allocate uid and gid tables */
-	if(!(msBlk->uid = (squashfs_uid *) kmalloc((sBlk->no_uids + sBlk->no_guids) * sizeof(squashfs_uid), GFP_KERNEL))) {
+	msblk->uid = kmalloc((sblk->no_uids + sblk->no_guids) *
+					sizeof(unsigned int), GFP_KERNEL);
+	if (msblk->uid == NULL) {
 		ERROR("Failed to allocate uid/gid table\n");
-		goto failed_mount3;
+		goto failed_mount;
 	}
-	msBlk->guid = msBlk->uid + sBlk->no_uids;
+	msblk->guid = msblk->uid + sblk->no_uids;
    
-	if(msBlk->swap) {
-		squashfs_uid suid[sBlk->no_uids + sBlk->no_guids];
+	if (SQUASHFS_IS_BYTESWAPPED(msblk)) {
+		unsigned int suid[sblk->no_uids + sblk->no_guids];
 
-		if(!read_data(s, (char *) &suid, sBlk->uid_start, ((sBlk->no_uids + sBlk->no_guids) *
-				sizeof(squashfs_uid)) | SQUASHFS_COMPRESSED_BIT_BLOCK, NULL)) {
-			SERROR("unable to read uid/gid table\n");
-			goto failed_mount4;
+		if (!squashfs_read_data(s, (char *) &suid, sblk->uid_start,
+					((sblk->no_uids + sblk->no_guids) *
+					 sizeof(unsigned int)) |
+					SQUASHFS_COMPRESSED_BIT_BLOCK, NULL, (sblk->no_uids + sblk->no_guids) * sizeof(unsigned int))) {
+			ERROR("unable to read uid/gid table\n");
+			goto failed_mount;
 		}
-		SQUASHFS_SWAP_DATA(msBlk->uid, suid, (sBlk->no_uids + sBlk->no_guids), (sizeof(squashfs_uid) * 8));
+
+		SQUASHFS_SWAP_DATA(msblk->uid, suid, (sblk->no_uids +
+			sblk->no_guids), (sizeof(unsigned int) * 8));
 	} else
-		if(!read_data(s, (char *) msBlk->uid, sBlk->uid_start, ((sBlk->no_uids + sBlk->no_guids) *
-				sizeof(squashfs_uid)) | SQUASHFS_COMPRESSED_BIT_BLOCK, NULL)) {
-			SERROR("unable to read uid/gid table\n");
-			goto failed_mount4;
+		if (!squashfs_read_data(s, (char *) msblk->uid, sblk->uid_start,
+					((sblk->no_uids + sblk->no_guids) *
+					 sizeof(unsigned int)) |
+					SQUASHFS_COMPRESSED_BIT_BLOCK, NULL, (sblk->no_uids + sblk->no_guids) * sizeof(unsigned int))) {
+			ERROR("unable to read uid/gid table\n");
+			goto failed_mount;
 		}
 
 
-#ifdef SQUASHFS_1_0_COMPATIBILITY
-	if(sBlk->s_major == 1) {
-		msBlk->iget = squashfs_iget_1;
-		msBlk->read_blocklist = read_blocklist_1;
-		msBlk->fragment = NULL;
-		msBlk->fragment_index = NULL;
+	if (sblk->s_major == 1 && squashfs_1_0_supported(msblk))
 		goto allocate_root;
-	}
-#endif
-	msBlk->iget = squashfs_iget;
-	msBlk->read_blocklist = read_blocklist;
 
-	if(!(msBlk->fragment = (struct squashfs_fragment_cache *) kmalloc(sizeof(struct squashfs_fragment_cache) * SQUASHFS_CACHED_FRAGMENTS, GFP_KERNEL))) {
+	msblk->fragment = kzalloc(sizeof(struct squashfs_fragment_cache) *
+				SQUASHFS_CACHED_FRAGMENTS, GFP_KERNEL);
+	if (msblk->fragment == NULL) {
 		ERROR("Failed to allocate fragment block cache\n");
-		goto failed_mount4;
+		goto failed_mount;
 	}
 
-	for(i = 0; i < SQUASHFS_CACHED_FRAGMENTS; i++) {
-		msBlk->fragment[i].locked = 0;
-		msBlk->fragment[i].block = SQUASHFS_INVALID_BLK;
-		msBlk->fragment[i].data = NULL;
+	for (i = 0; i < SQUASHFS_CACHED_FRAGMENTS; i++) {
+		msblk->fragment[i].block = SQUASHFS_INVALID_BLK;
 	}
 
-	msBlk->next_fragment = 0;
+	msblk->next_fragment = 0;
+	msblk->unused_frag_blks = SQUASHFS_CACHED_FRAGMENTS;
 
-	/* Allocate fragment index table */
-	if(!(msBlk->fragment_index = (squashfs_fragment_index *) kmalloc(SQUASHFS_FRAGMENT_INDEX_BYTES(sBlk->fragments), GFP_KERNEL))) {
-		ERROR("Failed to allocate uid/gid table\n");
-		goto failed_mount5;
-	}
+	/* Allocate and read fragment index table */
+	if (msblk->read_fragment_index_table(s) == 0)
+		goto failed_mount;
    
-	if(SQUASHFS_FRAGMENT_INDEX_BYTES(sBlk->fragments) &&
-	 	!read_data(s, (char *) msBlk->fragment_index, sBlk->fragment_table_start,
-		SQUASHFS_FRAGMENT_INDEX_BYTES(sBlk->fragments) | SQUASHFS_COMPRESSED_BIT_BLOCK, NULL)) {
-			SERROR("unable to read fragment index table\n");
-			goto failed_mount6;
-	}
+	if(sblk->s_major < 3 || sblk->lookup_table_start == SQUASHFS_INVALID_BLK)
+		goto allocate_root;
 
-	if(msBlk->swap) {
-		int i;
-		squashfs_fragment_index fragment;
+	/* Allocate and read inode lookup table */
+	if (read_inode_lookup_table(s) == 0)
+		goto failed_mount;
 
-		for(i = 0; i < SQUASHFS_FRAGMENT_INDEXES(sBlk->fragments); i++) {
-			SQUASHFS_SWAP_FRAGMENT_INDEXES((&fragment), &msBlk->fragment_index[i], 1);
-			msBlk->fragment_index[i] = fragment;
-		}
-	}
+	s->s_op = &squashfs_export_super_ops;
+	s->s_export_op = &squashfs_export_ops;
 
-#ifdef SQUASHFS_1_0_COMPATIBILITY
 allocate_root:
-#endif
-	if(!(s->s_root = d_alloc_root((msBlk->iget)(s, sBlk->root_inode)))) {
+	root = new_inode(s);
+	if ((msblk->read_inode)(root, sblk->root_inode) == 0)
+		goto failed_mount;
+	insert_inode_hash(root);
+
+	s->s_root = d_alloc_root(root);
+	if (s->s_root == NULL) {
 		ERROR("Root inode create failed\n");
-		goto failed_mount5;
+		iput(root);
+		goto failed_mount;
 	}
 
-	TRACE("Leaving squashfs_read_super\n");
+	TRACE("Leaving squashfs_fill_super\n");
 	return 0;
 
-failed_mount6:
-	kfree(msBlk->fragment_index);
-failed_mount5:
-	kfree(msBlk->fragment);
-failed_mount4:
-	kfree(msBlk->uid);
-failed_mount3:
-	kfree(msBlk->read_page);
-failed_mount2:
-	kfree(msBlk->read_data);
-failed_mount1:
-	kfree(msBlk->block_cache);
 failed_mount:
+	kfree(msblk->inode_lookup_table);
+	kfree(msblk->fragment_index);
+	kfree(msblk->fragment);
+	kfree(msblk->uid);
+	vfree(msblk->read_page);
+	kfree(msblk->block_cache);
+	kfree(msblk->fragment_index_2);
+	//vfree(msblk->stream.workspace);
 	kfree(s->s_fs_info);
 	s->s_fs_info = NULL;
 	return -EINVAL;
+
+failure:
+	return -ENOMEM;
 }
 
 
 static int squashfs_statfs(struct super_block *s, struct kstatfs *buf)
 {
-	squashfs_super_block *sBlk = &((squashfs_sb_info *)s->s_fs_info)->sBlk;
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
 
 	TRACE("Entered squashfs_statfs\n");
+
 	buf->f_type = SQUASHFS_MAGIC;
-	buf->f_bsize = sBlk->block_size;
-	buf->f_blocks = ((sBlk->bytes_used - 1) >> sBlk->block_log) + 1;
+	buf->f_bsize = sblk->block_size;
+	buf->f_blocks = ((sblk->bytes_used - 1) >> sblk->block_log) + 1;
 	buf->f_bfree = buf->f_bavail = 0;
-	buf->f_files = sBlk->inodes;
+	buf->f_files = sblk->inodes;
 	buf->f_ffree = 0;
 	buf->f_namelen = SQUASHFS_NAME_LEN;
+
 	return 0;
 }
 
@@ -1252,31 +1354,37 @@
 static int squashfs_symlink_readpage(struct file *file, struct page *page)
 {
 	struct inode *inode = page->mapping->host;
-	int index = page->index << PAGE_CACHE_SHIFT, length, bytes;
-	unsigned int block = SQUASHFS_I(inode)->start_block;
+	int index = page->index << PAGE_CACHE_SHIFT, length, bytes, avail_bytes;
+	long long block = SQUASHFS_I(inode)->start_block;
 	int offset = SQUASHFS_I(inode)->offset;
 	void *pageaddr = kmap(page);
 
-	TRACE("Entered squashfs_symlink_readpage, page index %d, start block %x, offset %x\n",
-		page->index, SQUASHFS_I(inode)->start_block, SQUASHFS_I(inode)->offset);
-
-	for(length = 0; length < index; length += bytes) {
-		if(!(bytes = squashfs_get_cached_block(inode->i_sb, NULL, block, offset,
-					PAGE_CACHE_SIZE, &block, &offset))) {
-			ERROR("Unable to read symbolic link [%x:%x]\n", block, offset);
+	TRACE("Entered squashfs_symlink_readpage, page index %ld, start block "
+				"%llx, offset %x\n", page->index,
+				SQUASHFS_I(inode)->start_block,
+				SQUASHFS_I(inode)->offset);
+
+	for (length = 0; length < index; length += bytes) {
+		bytes = squashfs_get_cached_block(inode->i_sb, NULL, block,
+				offset, PAGE_CACHE_SIZE, &block, &offset);
+		if (bytes == 0) {
+			ERROR("Unable to read symbolic link [%llx:%x]\n", block, offset);
 			goto skip_read;
 		}
 	}
 
-	if(length != index) {
+	if (length != index) {
 		ERROR("(squashfs_symlink_readpage) length != index\n");
 		bytes = 0;
 		goto skip_read;
 	}
 
-	bytes = (inode->i_size - length) > PAGE_CACHE_SIZE ? PAGE_CACHE_SIZE : inode->i_size - length;
-	if(!(bytes = squashfs_get_cached_block(inode->i_sb, pageaddr, block, offset, bytes, &block, &offset)))
-		ERROR("Unable to read symbolic link [%x:%x]\n", block, offset);
+	avail_bytes = min_t(int, i_size_read(inode) - length, PAGE_CACHE_SIZE);
+
+	bytes = squashfs_get_cached_block(inode->i_sb, pageaddr, block, offset,
+		avail_bytes, &block, &offset);
+	if (bytes == 0)
+		ERROR("Unable to read symbolic link [%llx:%x]\n", block, offset);
 
 skip_read:
 	memset(pageaddr + bytes, 0, PAGE_CACHE_SIZE - bytes);
@@ -1289,546 +1397,728 @@
 }
 
 
-#define SIZE 256
+struct meta_index *locate_meta_index(struct inode *inode, int index, int offset)
+{
+	struct meta_index *meta = NULL;
+	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
+	int i;
 
-#ifdef SQUASHFS_1_0_COMPATIBILITY
-static unsigned int read_blocklist_1(struct inode *inode, int index, int readahead_blks,
-		char *block_list, unsigned short **block_p, unsigned int *bsize)
-{
-	squashfs_sb_info *msBlk = (squashfs_sb_info *)inode->i_sb->s_fs_info;
-	unsigned short *block_listp;
-	int i = 0;
-	int block_ptr = SQUASHFS_I(inode)->block_list_start;
-	int offset = SQUASHFS_I(inode)->offset;
-	unsigned int block = SQUASHFS_I(inode)->start_block;
+	mutex_lock(&msblk->meta_index_mutex);
 
-	for(;;) {
-		int blocks = (index + readahead_blks - i);
-		if(blocks > (SIZE >> 1)) {
-			if((index - i) <= (SIZE >> 1))
-				blocks = index - i;
-			else
-				blocks = SIZE >> 1;
+	TRACE("locate_meta_index: index %d, offset %d\n", index, offset);
+
+	if(msblk->meta_index == NULL)
+		goto not_allocated;
+
+	for (i = 0; i < SQUASHFS_META_NUMBER; i ++) {
+		if (msblk->meta_index[i].inode_number == inode->i_ino &&
+				msblk->meta_index[i].offset >= offset &&
+				msblk->meta_index[i].offset <= index &&
+				msblk->meta_index[i].locked == 0) {
+			TRACE("locate_meta_index: entry %d, offset %d\n", i,
+					msblk->meta_index[i].offset);
+			meta = &msblk->meta_index[i];
+			offset = meta->offset;
+		}
 		}
 
-		if(msBlk->swap) {
-			unsigned char sblock_list[SIZE];
-			if(!squashfs_get_cached_block(inode->i_sb, (char *) sblock_list, block_ptr, offset, blocks << 1, &block_ptr, &offset)) {
-				ERROR("Unable to read block list [%d:%x]\n", block_ptr, offset);
-				return 0;
+	if (meta)
+		meta->locked = 1;
+
+not_allocated:
+	mutex_unlock(&msblk->meta_index_mutex);
+
+	return meta;
+}
+
+
+struct meta_index *empty_meta_index(struct inode *inode, int offset, int skip)
+{
+	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
+	struct meta_index *meta = NULL;
+	int i;
+
+	mutex_lock(&msblk->meta_index_mutex);
+
+	TRACE("empty_meta_index: offset %d, skip %d\n", offset, skip);
+
+	if(msblk->meta_index == NULL) {
+		msblk->meta_index = kmalloc(sizeof(struct meta_index) *
+					SQUASHFS_META_NUMBER, GFP_KERNEL);
+		if (msblk->meta_index == NULL) {
+			ERROR("Failed to allocate meta_index\n");
+			goto failed;
 			}
-			SQUASHFS_SWAP_SHORTS(((unsigned short *)block_list), ((unsigned short *)sblock_list), blocks);
-		} else
-			if(!squashfs_get_cached_block(inode->i_sb, (char *) block_list, block_ptr, offset, blocks << 1, &block_ptr, &offset)) {
-				ERROR("Unable to read block list [%d:%x]\n", block_ptr, offset);
-				return 0;
+		for(i = 0; i < SQUASHFS_META_NUMBER; i++) {
+			msblk->meta_index[i].inode_number = 0;
+			msblk->meta_index[i].locked = 0;
 			}
-		for(block_listp = (unsigned short *) block_list; i < index && blocks; i ++, block_listp ++, blocks --)
-			block += SQUASHFS_COMPRESSED_SIZE(*block_listp);
-		if(blocks >= readahead_blks)
-			break;
+		msblk->next_meta_index = 0;
 	}
 
-	if(bsize)
-		*bsize = SQUASHFS_COMPRESSED_SIZE(*block_listp) | (!SQUASHFS_COMPRESSED(*block_listp) ? SQUASHFS_COMPRESSED_BIT_BLOCK : 0);
-	else
-		*block_p = block_listp;
-	return block;
+	for(i = SQUASHFS_META_NUMBER; i &&
+			msblk->meta_index[msblk->next_meta_index].locked; i --)
+		msblk->next_meta_index = (msblk->next_meta_index + 1) %
+			SQUASHFS_META_NUMBER;
+
+	if(i == 0) {
+		TRACE("empty_meta_index: failed!\n");
+		goto failed;
+	}
+
+	TRACE("empty_meta_index: returned meta entry %d, %p\n",
+			msblk->next_meta_index,
+			&msblk->meta_index[msblk->next_meta_index]);
+
+	meta = &msblk->meta_index[msblk->next_meta_index];
+	msblk->next_meta_index = (msblk->next_meta_index + 1) %
+			SQUASHFS_META_NUMBER;
+
+	meta->inode_number = inode->i_ino;
+	meta->offset = offset;
+	meta->skip = skip;
+	meta->entries = 0;
+	meta->locked = 1;
+
+failed:
+	mutex_unlock(&msblk->meta_index_mutex);
+	return meta;
+}
+
+
+void release_meta_index(struct inode *inode, struct meta_index *meta)
+{
+	meta->locked = 0;
+	smp_mb();
 }
-#endif
 
 
-static unsigned int read_blocklist(struct inode *inode, int index, int readahead_blks,
-		char *block_list, unsigned short **block_p, unsigned int *bsize)
+static int read_block_index(struct super_block *s, int blocks, char *block_list,
+		long long *start_block, int *offset)
 {
-	squashfs_sb_info *msBlk = (squashfs_sb_info *)inode->i_sb->s_fs_info;
+	struct squashfs_sb_info *msblk = s->s_fs_info;
 	unsigned int *block_listp;
-	int i = 0;
-	int block_ptr = SQUASHFS_I(inode)->block_list_start;
-	int offset = SQUASHFS_I(inode)->offset;
-	unsigned int block = SQUASHFS_I(inode)->start_block;
+	int block = 0;
 
-	for(;;) {
-		int blocks = (index + readahead_blks - i);
-		if(blocks > (SIZE >> 2)) {
-			if((index - i) <= (SIZE >> 2))
-				blocks = index - i;
-			else
-				blocks = SIZE >> 2;
+	(void)msblk;
+	if (SQUASHFS_IS_BYTESWAPPED(msblk)) {
+		char sblock_list[blocks << 2];
+
+		if (!squashfs_get_cached_block(s, sblock_list, *start_block,
+				*offset, blocks << 2, start_block, offset)) {
+			ERROR("Fail reading block list [%llx:%x]\n", *start_block, *offset);
+			goto failure;
 		}
-
-		if(msBlk->swap) {
-			unsigned char sblock_list[SIZE];
-			if(!squashfs_get_cached_block(inode->i_sb, (char *) sblock_list, block_ptr, offset, blocks << 2, &block_ptr, &offset)) {
-				ERROR("Unable to read block list [%d:%x]\n", block_ptr, offset);
-				return 0;
+		SQUASHFS_SWAP_INTS(((unsigned int *)block_list),
+				((unsigned int *)sblock_list), blocks);
+	} else {
+		if (!squashfs_get_cached_block(s, block_list, *start_block,
+				*offset, blocks << 2, start_block, offset)) {
+			ERROR("Fail reading block list [%llx:%x]\n", *start_block, *offset);
+			goto failure;
 			}
-			SQUASHFS_SWAP_INTS(((unsigned int *)block_list), ((unsigned int *)sblock_list), blocks);
-		} else
-			if(!squashfs_get_cached_block(inode->i_sb, (char *) block_list, block_ptr, offset, blocks << 2, &block_ptr, &offset)) {
-				ERROR("Unable to read block list [%d:%x]\n", block_ptr, offset);
-				return 0;
 			}
-		for(block_listp = (unsigned int *) block_list; i < index && blocks; i ++, block_listp ++, blocks --)
+
+	for (block_listp = (unsigned int *) block_list; blocks;
+				block_listp++, blocks --)
 			block += SQUASHFS_COMPRESSED_SIZE_BLOCK(*block_listp);
-		if(blocks >= readahead_blks)
-			break;
-	}
 
-	*bsize = *block_listp;
 	return block;
+
+failure:
+	return -1;
 }
 
 
-static int squashfs_readpage(struct file *file, struct page *page)
-{
-	struct inode *inode = page->mapping->host;
-	squashfs_sb_info *msBlk = (squashfs_sb_info *)inode->i_sb->s_fs_info;
-	squashfs_super_block *sBlk = &msBlk->sBlk;
-	unsigned char block_list[SIZE];
-	unsigned int bsize, block, i = 0, bytes = 0, byte_offset = 0;
-	int index = page->index >> (sBlk->block_log - PAGE_CACHE_SHIFT);
- 	void *pageaddr = kmap(page);
-	struct squashfs_fragment_cache *fragment = NULL;
-	char *data_ptr = msBlk->read_page;
+#define SIZE 256
 	
-	int mask = (1 << (sBlk->block_log - PAGE_CACHE_SHIFT)) - 1;
-	int start_index = page->index & ~mask;
-	int end_index = start_index | mask;
+static inline int calculate_skip(int blocks) {
+	int skip = (blocks - 1) / ((SQUASHFS_SLOTS * SQUASHFS_META_ENTRIES + 1) * SQUASHFS_META_INDEXES);
+	return skip >= 7 ? 7 : skip + 1;
+}
 
-	TRACE("Entered squashfs_readpage, page index %x, start block %x\n", (unsigned int) page->index,
-		SQUASHFS_I(inode)->start_block);
 
-	if(page->index >= ((inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT)) {
-		goto skip_read;
-	}
+static int get_meta_index(struct inode *inode, int index,
+		long long *index_block, int *index_offset,
+		long long *data_block, char *block_list)
+{
+	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	int skip = calculate_skip(i_size_read(inode) >> sblk->block_log);
+	int offset = 0;
+	struct meta_index *meta;
+	struct meta_entry *meta_entry;
+	long long cur_index_block = SQUASHFS_I(inode)->u.s1.block_list_start;
+	int cur_offset = SQUASHFS_I(inode)->offset;
+	long long cur_data_block = SQUASHFS_I(inode)->start_block;
+	int i;
 
-	if(SQUASHFS_I(inode)->u.s1.fragment_start_block == SQUASHFS_INVALID_BLK || index < (inode->i_size >> sBlk->block_log)) {
-		if((block = (msBlk->read_blocklist)(inode, index, 1, block_list, NULL, &bsize)) == 0)
-			goto skip_read;
+	index /= SQUASHFS_META_INDEXES * skip;
 
-		down(&msBlk->read_page_mutex);
-		if(!(bytes = read_data(inode->i_sb, msBlk->read_page, block, bsize, NULL))) {
-			ERROR("Unable to read page, block %x, size %x\n", block, bsize);
-			up(&msBlk->read_page_mutex);
-			goto skip_read;
-		}
+	while (offset < index) {
+		meta = locate_meta_index(inode, index, offset + 1);
+
+		if (meta == NULL) {
+			meta = empty_meta_index(inode, offset + 1, skip);
+			if (meta == NULL)
+				goto all_done;
 	} else {
-		if((fragment = get_cached_fragment(inode->i_sb, SQUASHFS_I(inode)->u.s1.fragment_start_block, SQUASHFS_I(inode)->u.s1.fragment_size)) == NULL) {
-			ERROR("Unable to read page, block %x, size %x\n", SQUASHFS_I(inode)->u.s1.fragment_start_block, (int) SQUASHFS_I(inode)->u.s1.fragment_size);
-			goto skip_read;
-		}
-		bytes = SQUASHFS_I(inode)->u.s1.fragment_offset + (inode->i_size & (sBlk->block_size - 1));
-		byte_offset = SQUASHFS_I(inode)->u.s1.fragment_offset;
-		data_ptr = fragment->data;
+			if(meta->entries == 0)
+				goto failed;
+			/* XXX */
+			offset = index < meta->offset + meta->entries ? index :
+				meta->offset + meta->entries - 1;
+			/* XXX */
+			meta_entry = &meta->meta_entry[offset - meta->offset];
+			cur_index_block = meta_entry->index_block + sblk->inode_table_start;
+			cur_offset = meta_entry->offset;
+			cur_data_block = meta_entry->data_block;
+			TRACE("get_meta_index: offset %d, meta->offset %d, "
+				"meta->entries %d\n", offset, meta->offset, meta->entries);
+			TRACE("get_meta_index: index_block 0x%llx, offset 0x%x"
+				" data_block 0x%llx\n", cur_index_block,
+				cur_offset, cur_data_block);
 	}
 
-	for(i = start_index; i <= end_index && byte_offset < bytes; i++, byte_offset += PAGE_CACHE_SIZE) {
-		struct page *push_page;
-		int available_bytes = (bytes - byte_offset) > PAGE_CACHE_SIZE ? PAGE_CACHE_SIZE : bytes - byte_offset;
+		for (i = meta->offset + meta->entries; i <= index &&
+				i < meta->offset + SQUASHFS_META_ENTRIES; i++) {
+			int blocks = skip * SQUASHFS_META_INDEXES;
 
-		TRACE("bytes %d, i %d, byte_offset %d, available_bytes %d\n", bytes, i, byte_offset, available_bytes);
+			while (blocks) {
+				int block = blocks > (SIZE >> 2) ? (SIZE >> 2) : blocks;
+				int res = read_block_index(inode->i_sb, block, block_list,
+					&cur_index_block, &cur_offset);
 
-		if(i == page->index)  {
-			memcpy(pageaddr, data_ptr + byte_offset, available_bytes);
-			memset(pageaddr + available_bytes, 0, PAGE_CACHE_SIZE - available_bytes);
-			kunmap(page);
-			flush_dcache_page(page);
-			SetPageUptodate(page);
-			unlock_page(page);
-		} else if((push_page = grab_cache_page_nowait(page->mapping, i))) {
- 			void *pageaddr = kmap(push_page);
-			memcpy(pageaddr, data_ptr + byte_offset, available_bytes);
-			memset(pageaddr + available_bytes, 0, PAGE_CACHE_SIZE - available_bytes);
-			kunmap(push_page);
-			flush_dcache_page(push_page);
-			SetPageUptodate(push_page);
-			unlock_page(push_page);
-			page_cache_release(push_page);
+				if (res == -1)
+					goto failed;
+
+				cur_data_block += res;
+				blocks -= block;
 		}
+
+			meta_entry = &meta->meta_entry[i - meta->offset];
+			meta_entry->index_block = cur_index_block - sblk->inode_table_start;
+			meta_entry->offset = cur_offset;
+			meta_entry->data_block = cur_data_block;
+			meta->entries ++;
+			offset ++;
 	}
 
-	if(SQUASHFS_I(inode)->u.s1.fragment_start_block == SQUASHFS_INVALID_BLK || index < (inode->i_size >> sBlk->block_log))
-		up(&msBlk->read_page_mutex);
-	else
-		release_cached_fragment(msBlk, fragment);
+		TRACE("get_meta_index: meta->offset %d, meta->entries %d\n",
+				meta->offset, meta->entries);
 
-	return 0;
+		release_meta_index(inode, meta);
+	}
 
-skip_read:
-	memset(pageaddr + bytes, 0, PAGE_CACHE_SIZE - bytes);
-	kunmap(page);
-	flush_dcache_page(page);
-	SetPageUptodate(page);
-	unlock_page(page);
+all_done:
+	*index_block = cur_index_block;
+	*index_offset = cur_offset;
+	*data_block = cur_data_block;
 
-	return 0;
+	return offset * SQUASHFS_META_INDEXES * skip;
+
+failed:
+	release_meta_index(inode, meta);
+	return -1;
 }
 
 
-static int squashfs_readpage4K(struct file *file, struct page *page)
+static long long read_blocklist(struct inode *inode, int index,
+				int readahead_blks, char *block_list,
+				unsigned short **block_p, unsigned int *bsize)
 {
-	struct inode *inode = page->mapping->host;
-	squashfs_sb_info *msBlk = (squashfs_sb_info *)inode->i_sb->s_fs_info;
-	squashfs_super_block *sBlk = &msBlk->sBlk;
-	unsigned char block_list[SIZE];
-	unsigned int bsize, block, bytes = 0;
- 	void *pageaddr = kmap(page);
-	
-	TRACE("Entered squashfs_readpage4K, page index %x, start block %x\n", (unsigned int) page->index,
-		SQUASHFS_I(inode)->start_block);
+	long long block_ptr;
+	int offset;
+	long long block;
+	int res = get_meta_index(inode, index, &block_ptr, &offset, &block,
+		block_list);
 
-	if(page->index >= ((inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT)) {
-		goto skip_read;
-	}
+	TRACE("read_blocklist: res %d, index %d, block_ptr 0x%llx, offset"
+		       " 0x%x, block 0x%llx\n", res, index, block_ptr, offset, block);
 
-	if(SQUASHFS_I(inode)->u.s1.fragment_start_block == SQUASHFS_INVALID_BLK || page->index < (inode->i_size >> sBlk->block_log)) {
-		block = (msBlk->read_blocklist)(inode, page->index, 1, block_list, NULL, &bsize);
+	if(res == -1)
+		goto failure;
 
-		if(!(bytes = read_data(inode->i_sb, pageaddr, block, bsize, NULL)))
-			ERROR("Unable to read page, block %x, size %x\n", block, bsize);
-	} else {
-		struct squashfs_fragment_cache *fragment;
+	index -= res;
 
-		if((fragment = get_cached_fragment(inode->i_sb, SQUASHFS_I(inode)->u.s1.fragment_start_block, SQUASHFS_I(inode)->u.s1.fragment_size)) == NULL)
-			ERROR("Unable to read page, block %x, size %x\n", SQUASHFS_I(inode)->u.s1.fragment_start_block, (int) SQUASHFS_I(inode)->u.s1.fragment_size);
-		else {
-			bytes = inode->i_size & (sBlk->block_size - 1);
-			memcpy(pageaddr, fragment->data + SQUASHFS_I(inode)->u.s1.fragment_offset, bytes);
-			release_cached_fragment(msBlk, fragment);
-		}
+	while (index) {
+		int blocks = index > (SIZE >> 2) ? (SIZE >> 2) : index;
+		int res = read_block_index(inode->i_sb, blocks, block_list,
+			&block_ptr, &offset);
+		if (res == -1)
+			goto failure;
+		block += res;
+		index -= blocks;
 	}
 
-skip_read:
-	memset(pageaddr + bytes, 0, PAGE_CACHE_SIZE - bytes);
-	kunmap(page);
-	flush_dcache_page(page);
-	SetPageUptodate(page);
-	unlock_page(page);
+	if (read_block_index(inode->i_sb, 1, block_list, &block_ptr, &offset) == -1)
+		goto failure;
+	*bsize = *((unsigned int *) block_list);
+
+	return block;
 
+failure:
 	return 0;
 }
 
 
-#ifdef SQUASHFS_1_0_COMPATIBILITY
-static int squashfs_readpage_lessthan4K(struct file *file, struct page *page)
+static int squashfs_readpage(struct file *file, struct page *page)
 {
 	struct inode *inode = page->mapping->host;
-	squashfs_sb_info *msBlk = (squashfs_sb_info *)inode->i_sb->s_fs_info;
-	squashfs_super_block *sBlk = &msBlk->sBlk;
-	unsigned char block_list[SIZE];
-	unsigned short *block_listp, block, bytes = 0;
-	int index = page->index << (PAGE_CACHE_SHIFT - sBlk->block_log);
-	int file_blocks = ((inode->i_size - 1) >> sBlk->block_log) + 1;
-	int readahead_blks = 1 << (PAGE_CACHE_SHIFT - sBlk->block_log);
- 	void *pageaddr = kmap(page);
+	struct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	unsigned char *block_list = NULL;
+	long long block;
+	unsigned int bsize, i;
+	int bytes;
+	int index = page->index >> (sblk->block_log - PAGE_CACHE_SHIFT);
+ 	void *pageaddr;
+	struct squashfs_fragment_cache *fragment = NULL;
+	char *data_ptr = msblk->read_page;
 	
-	int i_end = index + (1 << (PAGE_CACHE_SHIFT - sBlk->block_log));
-	int byte;
+	int mask = (1 << (sblk->block_log - PAGE_CACHE_SHIFT)) - 1;
+	int start_index = page->index & ~mask;
+	int end_index = start_index | mask;
+	int file_end = i_size_read(inode) >> sblk->block_log;
+	int sparse = 0;
 
-	TRACE("Entered squashfs_readpage_lessthan4K, page index %x, start block %x\n", (unsigned int) page->index,
-		SQUASHFS_I(inode)->start_block);
+	TRACE("Entered squashfs_readpage, page index %lx, start block %llx\n",
+					page->index, SQUASHFS_I(inode)->start_block);
+
+	if (page->index >= ((i_size_read(inode) + PAGE_CACHE_SIZE - 1) >>
+					PAGE_CACHE_SHIFT))
+		goto out;
 
-	block = read_blocklist_1(inode, index, readahead_blks, block_list, &block_listp, NULL);
+	if (SQUASHFS_I(inode)->u.s1.fragment_start_block == SQUASHFS_INVALID_BLK
+					|| index < file_end) {
+		block_list = kmalloc(SIZE, GFP_KERNEL);
+		if (block_list == NULL) {
+			ERROR("Failed to allocate block_list\n");
+			goto error_out;
+		}
+
+		block = (msblk->read_blocklist)(inode, index, 1, block_list, NULL, &bsize);
+		if (block == 0)
+			goto error_out;
+
+		if (bsize == 0) { /* hole */
+			bytes = index == file_end ?
+				(i_size_read(inode) & (sblk->block_size - 1)) : sblk->block_size;
+			sparse = 1;
+		} else {
+			mutex_lock(&msblk->read_page_mutex);
 
-	if(i_end > file_blocks)
-		i_end = file_blocks;
+			bytes = squashfs_read_data(inode->i_sb, msblk->read_page, block,
+				bsize, NULL, sblk->block_size);
 
-	while(index < i_end) {
-		int c_byte = !SQUASHFS_COMPRESSED(*block_listp) ? SQUASHFS_COMPRESSED_SIZE(*block_listp) | SQUASHFS_COMPRESSED_BIT_BLOCK : *block_listp;
-		if(!(byte = read_data(inode->i_sb, pageaddr, block, c_byte, NULL))) {
-			ERROR("Unable to read page, block %x, size %x\n", block, *block_listp);
-			goto skip_read;
+			if (bytes == 0) {
+				ERROR("Unable to read page, block %llx, size %x\n", block, bsize);
+				mutex_unlock(&msblk->read_page_mutex);
+				goto error_out;
+			}
+		}
+	} else {
+		fragment = get_cached_fragment(inode->i_sb,
+					SQUASHFS_I(inode)-> u.s1.fragment_start_block,
+					SQUASHFS_I(inode)->u.s1.fragment_size);
+
+		if (fragment == NULL) {
+			ERROR("Unable to read page, block %llx, size %x\n",
+					SQUASHFS_I(inode)->u.s1.fragment_start_block,
+					(int) SQUASHFS_I(inode)->u.s1.fragment_size);
+			goto error_out;
 		}
-		block += SQUASHFS_COMPRESSED_SIZE(*block_listp);
-		pageaddr += byte;
-		bytes += byte;
-		index ++;
-		block_listp ++;
+		bytes = i_size_read(inode) & (sblk->block_size - 1);
+		data_ptr = fragment->data + SQUASHFS_I(inode)->u.s1.fragment_offset;
 	}
 
-skip_read:
-	memset(pageaddr, 0, PAGE_CACHE_SIZE - bytes);
-	kunmap(page);
+	for (i = start_index; i <= end_index && bytes > 0; i++,
+						bytes -= PAGE_CACHE_SIZE, data_ptr += PAGE_CACHE_SIZE) {
+		struct page *push_page;
+		int avail = sparse ? 0 : min_t(unsigned int, bytes, PAGE_CACHE_SIZE);
+
+		TRACE("bytes %d, i %d, available_bytes %d\n", bytes, i, avail);
+
+		push_page = (i == page->index) ? page :
+			grab_cache_page_nowait(page->mapping, i);
+
+		if (!push_page)
+			continue;
+
+		if (PageUptodate(push_page))
+			goto skip_page;
+
+ 		pageaddr = kmap_atomic(push_page, KM_USER0);
+		memcpy(pageaddr, data_ptr, avail);
+		memset(pageaddr + avail, 0, PAGE_CACHE_SIZE - avail);
+		kunmap_atomic(pageaddr, KM_USER0);
+		flush_dcache_page(push_page);
+		SetPageUptodate(push_page);
+skip_page:
+		unlock_page(push_page);
+		if(i != page->index)
+			page_cache_release(push_page);
+	}
+
+	if (SQUASHFS_I(inode)->u.s1.fragment_start_block == SQUASHFS_INVALID_BLK
+					|| index < file_end) {
+		if (!sparse)
+			mutex_unlock(&msblk->read_page_mutex);
+		kfree(block_list);
+	} else
+		release_cached_fragment(msblk, fragment);
+
+	return 0;
+
+error_out:
+	SetPageError(page);
+out:
+	pageaddr = kmap_atomic(page, KM_USER0);
+	memset(pageaddr, 0, PAGE_CACHE_SIZE);
+	kunmap_atomic(pageaddr, KM_USER0);
 	flush_dcache_page(page);
+	if (!PageError(page))
 	SetPageUptodate(page);
 	unlock_page(page);
 
+	kfree(block_list);
 	return 0;
 }
-#endif
 
 
-static int get_dir_index_using_offset(struct super_block *s, unsigned int *next_block,
-	unsigned int *next_offset, unsigned int index_start, unsigned int index_offset,
-	int i_count, long long f_pos)
+static int get_dir_index_using_offset(struct super_block *s,
+				long long *next_block, unsigned int *next_offset,
+				long long index_start, unsigned int index_offset, int i_count,
+				long long f_pos)
 {
-	squashfs_sb_info *msBlk = (squashfs_sb_info *)s->s_fs_info;
-	squashfs_super_block *sBlk = &msBlk->sBlk;
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
 	int i, length = 0;
-	squashfs_dir_index index;
+	struct squashfs_dir_index index;
 
-	TRACE("Entered get_dir_index_using_offset, i_count %d, f_pos %d\n", i_count, (unsigned int) f_pos);
-
-	if(f_pos == 0)
-		return 0;
+	TRACE("Entered get_dir_index_using_offset, i_count %d, f_pos %d\n",
+					i_count, (unsigned int) f_pos);
 
-	for(i = 0; i < i_count; i++) {
-		if(msBlk->swap) {
-			squashfs_dir_index sindex;
-			squashfs_get_cached_block(s, (char *) &sindex, index_start, index_offset,
+	f_pos =- 3;
+	if (f_pos == 0)
+		goto finish;
+
+	for (i = 0; i < i_count; i++) {
+		if (SQUASHFS_IS_BYTESWAPPED(msblk)) {
+			struct squashfs_dir_index sindex;
+			squashfs_get_cached_block(s, &sindex, index_start, index_offset,
 				sizeof(sindex), &index_start, &index_offset);
 			SQUASHFS_SWAP_DIR_INDEX(&index, &sindex);
 		} else
-			squashfs_get_cached_block(s, (char *) &index, index_start, index_offset,
+			squashfs_get_cached_block(s, &index, index_start, index_offset,
 				sizeof(index), &index_start, &index_offset);
 
-		if(index.index > f_pos)
+		if (index.index > f_pos)
 			break;
 
 		squashfs_get_cached_block(s, NULL, index_start, index_offset,
 				index.size + 1, &index_start, &index_offset);
 
 		length = index.index;
-		*next_block = index.start_block + sBlk->directory_table_start;
+		*next_block = index.start_block + sblk->directory_table_start;
 	}
 
 	*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;
-	return length;
+
+finish:
+	return length + 3;
 }
 
 
-static int get_dir_index_using_name(struct super_block *s, unsigned int *next_block,
-	unsigned int *next_offset, unsigned int index_start, unsigned int index_offset,
-	int i_count, const char *name, int size)
+static int get_dir_index_using_name(struct super_block *s,
+				long long *next_block, unsigned int *next_offset,
+				long long index_start, unsigned int index_offset, int i_count,
+				const char *name, int size)
 {
-	squashfs_sb_info *msBlk = (squashfs_sb_info *)s->s_fs_info;
-	squashfs_super_block *sBlk = &msBlk->sBlk;
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
 	int i, length = 0;
-	char buffer[sizeof(squashfs_dir_index) + SQUASHFS_NAME_LEN + 1];
-	squashfs_dir_index *index = (squashfs_dir_index *) buffer;
-	char str[SQUASHFS_NAME_LEN + 1];
+	struct squashfs_dir_index *index;
+	char *str;
 
 	TRACE("Entered get_dir_index_using_name, i_count %d\n", i_count);
     
-    /*------------------------------------------------------------------------------------------*\
-     * mapom: auf calle's anregung
-    \*------------------------------------------------------------------------------------------*/
-    if(size > SQUASHFS_NAME_LEN) {
-        printk(KERN_ERR "squashfs: name to long\n");
-        return -ENAMETOOLONG;
+	str = kmalloc(sizeof(struct squashfs_dir_index) +
+		(SQUASHFS_NAME_LEN + 1) * 2, GFP_KERNEL);
+	if (str == NULL) {
+		ERROR("Failed to allocate squashfs_dir_index\n");
+		goto failure;
     }
 
+	index = (struct squashfs_dir_index *) (str + SQUASHFS_NAME_LEN + 1);
 	strncpy(str, name, size);
 	str[size] = '\0';
 
-	for(i = 0; i < i_count; i++) {
-		if(msBlk->swap) {
-			squashfs_dir_index sindex;
-			squashfs_get_cached_block(s, (char *) &sindex, index_start, index_offset,
+	for (i = 0; i < i_count; i++) {
+		if (SQUASHFS_IS_BYTESWAPPED(msblk)) {
+			struct squashfs_dir_index sindex;
+			squashfs_get_cached_block(s, &sindex, index_start, index_offset,
 				sizeof(sindex), &index_start, &index_offset);
 			SQUASHFS_SWAP_DIR_INDEX(index, &sindex);
 		} else
-			squashfs_get_cached_block(s, (char *) index, index_start, index_offset,
-				sizeof(squashfs_dir_index), &index_start, &index_offset);
+			squashfs_get_cached_block(s, index, index_start, index_offset,
+				sizeof(struct squashfs_dir_index), &index_start, &index_offset);
 
 		squashfs_get_cached_block(s, index->name, index_start, index_offset,
 				index->size + 1, &index_start, &index_offset);
 
 		index->name[index->size + 1] = '\0';
 
-		if(strcmp(index->name, str) > 0)
+		if (strcmp(index->name, str) > 0)
 			break;
 
 		length = index->index;
-		*next_block = index->start_block + sBlk->directory_table_start;
+		*next_block = index->start_block + sblk->directory_table_start;
 	}
 
 	*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;
-	return length;
+	kfree(str);
+
+failure:
+	return length + 3;
 }
 
 		
 static int squashfs_readdir(struct file *file, void *dirent, filldir_t filldir)
 {
 	struct inode *i = file->f_dentry->d_inode;
-	squashfs_sb_info *msBlk = (squashfs_sb_info *)i->i_sb->s_fs_info;
-	squashfs_super_block *sBlk = &msBlk->sBlk;
-	int next_block = SQUASHFS_I(i)->start_block + sBlk->directory_table_start, next_offset =
-		SQUASHFS_I(i)->offset, length = 0, dirs_read = 0, dir_count;
-	squashfs_dir_header dirh;
-	char buffer[sizeof(squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1];
-	squashfs_dir_entry *dire = (squashfs_dir_entry *) buffer;
-
-	TRACE("Entered squashfs_readdir [%x:%x]\n", next_block, next_offset);
+	struct squashfs_sb_info *msblk = i->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	long long next_block = SQUASHFS_I(i)->start_block +
+		sblk->directory_table_start;
+	int next_offset = SQUASHFS_I(i)->offset, length = 0, dir_count;
+	struct squashfs_dir_header dirh;
+	struct squashfs_dir_entry *dire;
+
+	TRACE("Entered squashfs_readdir [%llx:%x]\n", next_block, next_offset);
+
+	dire = kmalloc(sizeof(struct squashfs_dir_entry) +
+		SQUASHFS_NAME_LEN + 1, GFP_KERNEL);
+	if (dire == NULL) {
+		ERROR("Failed to allocate squashfs_dir_entry\n");
+		goto finish;
+	}
+
+	while(file->f_pos < 3) {
+		char *name;
+		int size, i_ino;
+
+		if(file->f_pos == 0) {
+			name = ".";
+			size = 1;
+			i_ino = i->i_ino;
+		} else {
+			name = "..";
+			size = 2;
+			i_ino = SQUASHFS_I(i)->u.s2.parent_inode;
+		}
+		TRACE("Calling filldir(%x, %s, %d, %d, %d, %d)\n",
+				(unsigned int) dirent, name, size, (int)
+				file->f_pos, i_ino, squashfs_filetype_table[1]);
 
-	lock_kernel();
+		if (filldir(dirent, name, size, file->f_pos, i_ino,
+				squashfs_filetype_table[1]) < 0) {
+				TRACE("Filldir returned less than 0\n");
+			goto finish;
+		}
+		file->f_pos += size;
+	}
 
-	length = get_dir_index_using_offset(i->i_sb, &next_block, &next_offset, SQUASHFS_I(i)->u.s2.directory_index_start,
-		SQUASHFS_I(i)->u.s2.directory_index_offset, SQUASHFS_I(i)->u.s2.directory_index_count, file->f_pos);
+	length = get_dir_index_using_offset(i->i_sb, &next_block, &next_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_start,
+				SQUASHFS_I(i)->u.s2.directory_index_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_count, file->f_pos);
 
-	while(length < i->i_size) {
+	while (length < i_size_read(i)) {
 		/* read directory header */
-		if(msBlk->swap) {
-			squashfs_dir_header sdirh;
-			if(!squashfs_get_cached_block(i->i_sb, (char *) &sdirh, next_block,
+		if (SQUASHFS_IS_BYTESWAPPED(msblk)) {
+			struct squashfs_dir_header sdirh;
+			
+			if (!squashfs_get_cached_block(i->i_sb, &sdirh, next_block,
 						next_offset, sizeof(sdirh), &next_block, &next_offset))
 				goto failed_read;
+
 			length += sizeof(sdirh);
 			SQUASHFS_SWAP_DIR_HEADER(&dirh, &sdirh);
 		} else {
-			if(!squashfs_get_cached_block(i->i_sb, (char *) &dirh, next_block,
+			if (!squashfs_get_cached_block(i->i_sb, &dirh, next_block,
 						next_offset, sizeof(dirh), &next_block, &next_offset))
 				goto failed_read;
+
 			length += sizeof(dirh);
 		}
 
 		dir_count = dirh.count + 1;
-		while(dir_count--) {
-			if(msBlk->swap) {
-				squashfs_dir_entry sdire;
-				if(!squashfs_get_cached_block(i->i_sb, (char *) &sdire, next_block,
+		while (dir_count--) {
+			if (SQUASHFS_IS_BYTESWAPPED(msblk)) {
+				struct squashfs_dir_entry sdire;
+				if (!squashfs_get_cached_block(i->i_sb, &sdire, next_block,
 							next_offset, sizeof(sdire), &next_block, &next_offset))
 					goto failed_read;
+				
 				length += sizeof(sdire);
 				SQUASHFS_SWAP_DIR_ENTRY(dire, &sdire);
 			} else {
-				if(!squashfs_get_cached_block(i->i_sb, (char *) dire, next_block,
+				if (!squashfs_get_cached_block(i->i_sb, dire, next_block,
 							next_offset, sizeof(*dire), &next_block, &next_offset))
 					goto failed_read;
+
 				length += sizeof(*dire);
 			}
 
-			if(!squashfs_get_cached_block(i->i_sb, dire->name, next_block,
+			if (!squashfs_get_cached_block(i->i_sb, dire->name, next_block,
 						next_offset, dire->size + 1, &next_block, &next_offset))
 				goto failed_read;
+
 			length += dire->size + 1;
 
-			if(file->f_pos >= length)
+			if (file->f_pos >= length)
 				continue;
 
 			dire->name[dire->size + 1] = '\0';
 
-			TRACE("Calling filldir(%x, %s, %d, %d, %x:%x, %d)\n", (unsigned int) dirent,
-			dire->name, dire->size + 1, (int) file->f_pos,
-			dirh.start_block, dire->offset, squashfs_filetype_table[dire->type]);
-
-			if(filldir(dirent, dire->name, dire->size + 1, file->f_pos, SQUASHFS_MK_VFS_INODE(dirh.start_block,
-							dire->offset), squashfs_filetype_table[dire->type]) < 0) {
+			TRACE("Calling filldir(%x, %s, %d, %d, %x:%x, %d, %d)\n",
+					(unsigned int) dirent, dire->name, dire->size + 1,
+					(int) file->f_pos, dirh.start_block, dire->offset,
+					dirh.inode_number + dire->inode_number,
+					squashfs_filetype_table[dire->type]);
+
+			if (filldir(dirent, dire->name, dire->size + 1, file->f_pos,
+					dirh.inode_number + dire->inode_number,
+					squashfs_filetype_table[dire->type]) < 0) {
 				TRACE("Filldir returned less than 0\n");
-				unlock_kernel();
-#if defined(CONFIG_NFSD) || defined(CONFIG_NFSD_MODULE)
-                return 0;
-#else
-				return dirs_read;
-#endif
+				goto finish;
 			}
-
 			file->f_pos = length;
-			dirs_read ++;
 		}
 	}
 
-	unlock_kernel();
-	return dirs_read;
+finish:
+	kfree(dire);
+	return 0;
 
 failed_read:
-	unlock_kernel();
-	ERROR("Unable to read directory block [%x:%x]\n", next_block, next_offset);
+	ERROR("Unable to read directory block [%llx:%x]\n", next_block,
+		next_offset);
+	kfree(dire);
 	return 0;
 }
 
 
-static struct dentry *squashfs_lookup(struct inode *i, struct dentry *dentry, struct nameidata *nd)
+static struct dentry *squashfs_lookup(struct inode *i, struct dentry *dentry,
+				struct nameidata *nd)
 {
-	const unsigned char *name =dentry->d_name.name;
+	const unsigned char *name = dentry->d_name.name;
 	int len = dentry->d_name.len;
 	struct inode *inode = NULL;
-	squashfs_sb_info *msBlk = (squashfs_sb_info *)i->i_sb->s_fs_info;
-	squashfs_super_block *sBlk = &msBlk->sBlk;
-	int next_block = SQUASHFS_I(i)->start_block + sBlk->directory_table_start, next_offset =
-		SQUASHFS_I(i)->offset, length = 0, dir_count;
-	squashfs_dir_header dirh;
-	char buffer[sizeof(squashfs_dir_entry) + SQUASHFS_NAME_LEN];
-	squashfs_dir_entry *dire = (squashfs_dir_entry *) buffer;
-	int squashfs_2_1 = sBlk->s_major == 2 && sBlk->s_minor == 1;
-
-	TRACE("Entered squashfs_lookup [%x:%x]\n", next_block, next_offset);
-
-     /*------------------------------------------------------------------------------------------*\
-     * mapom: auf calle's anregung
-    \*------------------------------------------------------------------------------------------*/
-    if(dentry->d_name.len > SQUASHFS_NAME_LEN) {
-        printk(KERN_ERR "squashfs: (squashfs_looup) name to long\n");
-        return ERR_PTR(-ENAMETOOLONG);
-    }
+	struct squashfs_sb_info *msblk = i->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	long long next_block = SQUASHFS_I(i)->start_block +
+				sblk->directory_table_start;
+	int next_offset = SQUASHFS_I(i)->offset, length = 0, dir_count;
+	struct squashfs_dir_header dirh;
+	struct squashfs_dir_entry *dire;
+
+	TRACE("Entered squashfs_lookup [%llx:%x]\n", next_block, next_offset);
+
+	dire = kmalloc(sizeof(struct squashfs_dir_entry) +
+		SQUASHFS_NAME_LEN + 1, GFP_KERNEL);
+	if (dire == NULL) {
+		ERROR("Failed to allocate squashfs_dir_entry\n");
+		goto exit_lookup;
+	}
+
+	if (len > SQUASHFS_NAME_LEN)
+		goto exit_lookup;
+
+	length = get_dir_index_using_name(i->i_sb, &next_block, &next_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_start,
+				SQUASHFS_I(i)->u.s2.directory_index_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_count, name, len);
 
-	lock_kernel();
-
-	length = get_dir_index_using_name(i->i_sb, &next_block, &next_offset, SQUASHFS_I(i)->u.s2.directory_index_start,
-		SQUASHFS_I(i)->u.s2.directory_index_offset, SQUASHFS_I(i)->u.s2.directory_index_count, name, len);
-
-	while(length < i->i_size) {
+	while (length < i_size_read(i)) {
 		/* read directory header */
-		if(msBlk->swap) {
-			squashfs_dir_header sdirh;
-			if(!squashfs_get_cached_block(i->i_sb, (char *) &sdirh, next_block, next_offset,
-						sizeof(sdirh), &next_block, &next_offset))
+		if (SQUASHFS_IS_BYTESWAPPED(msblk)) {
+			struct squashfs_dir_header sdirh;
+			if (!squashfs_get_cached_block(i->i_sb, &sdirh, next_block,
+					 next_offset, sizeof(sdirh), &next_block, &next_offset))
 				goto failed_read;
+
 			length += sizeof(sdirh);
 			SQUASHFS_SWAP_DIR_HEADER(&dirh, &sdirh);
 		} else {
-			if(!squashfs_get_cached_block(i->i_sb, (char *) &dirh, next_block, next_offset,
-						sizeof(dirh), &next_block, &next_offset))
+			if (!squashfs_get_cached_block(i->i_sb, &dirh, next_block,
+					next_offset, sizeof(dirh), &next_block, &next_offset))
 				goto failed_read;
+
 			length += sizeof(dirh);
 		}
 
 		dir_count = dirh.count + 1;
-		while(dir_count--) {
-			if(msBlk->swap) {
-				squashfs_dir_entry sdire;
-				if(!squashfs_get_cached_block(i->i_sb, (char *) &sdire,
-							next_block,next_offset, sizeof(sdire), &next_block, &next_offset))
+		while (dir_count--) {
+			if (SQUASHFS_IS_BYTESWAPPED(msblk)) {
+				struct squashfs_dir_entry sdire;
+				if (!squashfs_get_cached_block(i->i_sb, &sdire, next_block,
+						next_offset, sizeof(sdire), &next_block, &next_offset))
 					goto failed_read;
+				
 				length += sizeof(sdire);
 				SQUASHFS_SWAP_DIR_ENTRY(dire, &sdire);
 			} else {
-				if(!squashfs_get_cached_block(i->i_sb, (char *) dire,
-							next_block,next_offset, sizeof(*dire), &next_block, &next_offset))
+				if (!squashfs_get_cached_block(i->i_sb, dire, next_block,
+						next_offset, sizeof(*dire), &next_block, &next_offset))
 					goto failed_read;
+
 				length += sizeof(*dire);
 			}
 
-			if(!squashfs_get_cached_block(i->i_sb, dire->name,
-						next_block, next_offset, dire->size + 1, &next_block, &next_offset))
+			if (!squashfs_get_cached_block(i->i_sb, dire->name, next_block,
+					next_offset, dire->size + 1, &next_block, &next_offset))
 				goto failed_read;
+
 			length += dire->size + 1;
 
-			if(squashfs_2_1 && name[0] < dire->name[0])
-				goto exit_loop;
+			if (name[0] < dire->name[0])
+				goto exit_lookup;
 
-			if((len == dire->size + 1) && !strncmp(name, dire->name, len)) {
-				squashfs_inode ino = SQUASHFS_MKINODE(dirh.start_block, dire->offset);
+			if ((len == dire->size + 1) && !strncmp(name, dire->name, len)) {
+				squashfs_inode_t ino = SQUASHFS_MKINODE(dirh.start_block,
+								dire->offset);
 
-				TRACE("calling squashfs_iget for directory entry %s, inode %x:%x\n",
-						name, dirh.start_block, dire->offset);
+				TRACE("calling squashfs_iget for directory entry %s, inode"
+					"  %x:%x, %d\n", name, dirh.start_block, dire->offset,
+					dirh.inode_number + dire->inode_number);
 
-				inode = (msBlk->iget)(i->i_sb, ino);
+				inode = squashfs_iget(i->i_sb, ino, dirh.inode_number + dire->inode_number);
 
-				goto exit_loop;
+				goto exit_lookup;
 			}
 		}
 	}
 
-exit_loop:
+exit_lookup:
+	kfree(dire);
+	if (inode)
+		return d_splice_alias(inode, dentry);
 	d_add(dentry, inode);
-	unlock_kernel();
 	return ERR_PTR(0);
 
 failed_read:
-	ERROR("Unable to read directory block [%x:%x]\n", next_block, next_offset);
-	goto exit_loop;
+	ERROR("Unable to read directory block [%llx:%x]\n", next_block,
+		next_offset);
+	goto exit_lookup;
+}
+
+
+static int squashfs_remount(struct super_block *s, int *flags, char *data)
+{
+	*flags |= MS_RDONLY;
+	return 0;
 }
 
 
@@ -1836,31 +2126,31 @@
 {
 	int i;
 
-	if(s->s_fs_info) {
-		squashfs_sb_info *sbi = (squashfs_sb_info *) s->s_fs_info;
-		if(sbi->block_cache) {
-			for(i = 0; i < SQUASHFS_CACHED_BLKS; i++)
-				if(sbi->block_cache[i].block != SQUASHFS_INVALID_BLK)
-					kfree(sbi->block_cache[i].data);
-			kfree(sbi->block_cache);
-		}
-		if(sbi->read_data) kfree(sbi->read_data);
-		if(sbi->read_page) kfree(sbi->read_page);
-		if(sbi->uid) kfree(sbi->uid);
-		if(sbi->fragment) {
-			for(i = 0; i < SQUASHFS_CACHED_FRAGMENTS; i++) 
-				if(sbi->fragment[i].data != NULL)
-					SQUASHFS_FREE(sbi->fragment[i].data);
+	if (s->s_fs_info) {
+		struct squashfs_sb_info *sbi = s->s_fs_info;
+		if (sbi->block_cache)
+			for (i = 0; i < squashfs_cached_blks; i++)
+				if (sbi->block_cache[i].block != SQUASHFS_INVALID_BLK)
+					vfree(sbi->block_cache[i].data);
+		if (sbi->fragment)
+			for (i = 0; i < SQUASHFS_CACHED_FRAGMENTS; i++) 
+				vfree(sbi->fragment[i].data);
 			kfree(sbi->fragment);
-		}
-		if(sbi->fragment_index) kfree(sbi->fragment_index);
+		kfree(sbi->block_cache);
+		vfree(sbi->read_page);
+		kfree(sbi->uid);
+		kfree(sbi->fragment_index);
+		kfree(sbi->fragment_index_2);
+		kfree(sbi->meta_index);
+		//vfree(sbi->stream.workspace);
 		kfree(s->s_fs_info);
 		s->s_fs_info = NULL;
 	}
 }
 
 
-static struct super_block *squashfs_get_sb(struct file_system_type *fs_type, int flags, const char *dev_name, void *data)
+static struct super_block *squashfs_get_sb(struct file_system_type *fs_type, int flags,
+			   const char *dev_name, void *data)
 {
 	return get_sb_bdev(fs_type, flags, dev_name, data, squashfs_fill_super);
 }
@@ -1869,30 +2159,23 @@
 static int __init init_squashfs_fs(void)
 {
 	int err = init_inodecache();
-	if(err)
-		return err;
-
-	printk(KERN_INFO "Squashfs 2.2-r2b (released 2006/02/23) (C) 2002-2005 Phillip Lougher\n");
+	if (err)
+		goto out;
 
-	if(!(stream.workspace = (char *) vmalloc(zlib_inflate_workspacesize()))) {
-		ERROR("Failed to allocate zlib workspace\n");
-		destroy_inodecache();
-		return -ENOMEM;
-	}
+	printk(KERN_INFO "squashfs: version 3.3 (2007/10/31) "
+		"Phillip Lougher\n");
 
-	if((err = register_filesystem(&squashfs_fs_type))) {
-		vfree(stream.workspace);
+	err = register_filesystem(&squashfs_fs_type);
+	if (err)
 		destroy_inodecache();
-	}
 
+out:
 	return err;
 }
 
 
 static void __exit exit_squashfs_fs(void)
 {
-    if (!use_lzma)
-        vfree(stream.workspace);
 	unregister_filesystem(&squashfs_fs_type);
 	destroy_inodecache();
 }
@@ -1904,10 +2187,8 @@
 static struct inode *squashfs_alloc_inode(struct super_block *sb)
 {
 	struct squashfs_inode_info *ei;
-	ei = (struct squashfs_inode_info *)kmem_cache_alloc(squashfs_inode_cachep, SLAB_KERNEL);
-	if (!ei)
-		return NULL;
-	return &ei->vfs_inode;
+	ei = kmem_cache_alloc(squashfs_inode_cachep, GFP_KERNEL);
+	return ei ? &ei->vfs_inode : NULL;
 }
 
 
@@ -1919,20 +2200,17 @@
 
 static void init_once(void * foo, kmem_cache_t * cachep, unsigned long flags)
 {
-	struct squashfs_inode_info *ei = (struct squashfs_inode_info *) foo;
+	struct squashfs_inode_info *ei = foo;
 
-	if ((flags & (SLAB_CTOR_VERIFY|SLAB_CTOR_CONSTRUCTOR)) ==
-	    SLAB_CTOR_CONSTRUCTOR)
 		inode_init_once(&ei->vfs_inode);
 }
  
 
-static int init_inodecache(void)
+static int __init init_inodecache(void)
 {
 	squashfs_inode_cachep = kmem_cache_create("squashfs_inode_cache",
-					     sizeof(struct squashfs_inode_info),
-					     0, SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT,
-					     init_once, NULL);
+	    sizeof(struct squashfs_inode_info), 0,
+		SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT, init_once, NULL);
 	if (squashfs_inode_cachep == NULL)
 		return -ENOMEM;
 	return 0;
@@ -1941,13 +2219,12 @@
 
 static void destroy_inodecache(void)
 {
-	if (kmem_cache_destroy(squashfs_inode_cachep))
-		printk(KERN_INFO "squashfs_inode_cache: not all structures were freed\n");
+	kmem_cache_destroy(squashfs_inode_cachep);
 }
 
 
 module_init(init_squashfs_fs);
 module_exit(exit_squashfs_fs);
-MODULE_DESCRIPTION("squashfs, a compressed read-only filesystem");
+MODULE_DESCRIPTION("squashfs 3.3, a compressed read-only filesystem");
 MODULE_AUTHOR("Phillip Lougher <phillip@lougher.demon.co.uk>");
 MODULE_LICENSE("GPL");
--- linux-2.6.13/fs/squashfs/LzmaDecode.c
+++ linux-2.6.13/fs/squashfs/LzmaDecode.c
@@ -0,0 +1,588 @@
+/*
+  LzmaDecode.c
+  LZMA Decoder (optimized for Speed version)
+  
+  LZMA SDK 4.22 Copyright (c) 1999-2005 Igor Pavlov (2005-06-10)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this Code, expressly permits you to 
+  statically or dynamically link your Code (or bind by name) to the 
+  interfaces of this file without subjecting your linked Code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#include "LzmaDecode.h"
+
+#ifndef Byte
+#define Byte unsigned char
+#endif
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 << kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 << kNumBitModelTotalBits)
+#define kNumMoveBits 5
+
+#define RC_READ_BYTE (*Buffer++)
+
+#define RC_INIT2 Code = 0; Range = 0xFFFFFFFF; \
+  { int i; for(i = 0; i < 5; i++) { RC_TEST; Code = (Code << 8) | RC_READ_BYTE; }}
+
+#ifdef _LZMA_IN_CB
+
+#define RC_TEST { if (Buffer == BufferLim) \
+  { SizeT size; int result = InCallback->Read(InCallback, &Buffer, &size); if (result != LZMA_RESULT_OK) return result; \
+  BufferLim = Buffer + size; if (size == 0) return LZMA_RESULT_DATA_ERROR; }}
+
+#define RC_INIT Buffer = BufferLim = 0; RC_INIT2
+
+#else
+
+#define RC_TEST { if (Buffer == BufferLim) return LZMA_RESULT_DATA_ERROR; }
+
+#define RC_INIT(buffer, bufferSize) Buffer = buffer; BufferLim = buffer + bufferSize; RC_INIT2
+ 
+#endif
+
+#define RC_NORMALIZE if (Range < kTopValue) { RC_TEST; Range <<= 8; Code = (Code << 8) | RC_READ_BYTE; }
+
+#define IfBit0(p) RC_NORMALIZE; bound = (Range >> kNumBitModelTotalBits) * *(p); if (Code < bound)
+#define UpdateBit0(p) Range = bound; *(p) += (kBitModelTotal - *(p)) >> kNumMoveBits;
+#define UpdateBit1(p) Range -= bound; Code -= bound; *(p) -= (*(p)) >> kNumMoveBits;
+
+#define RC_GET_BIT2(p, mi, A0, A1) IfBit0(p) \
+  { UpdateBit0(p); mi <<= 1; A0; } else \
+  { UpdateBit1(p); mi = (mi + mi) + 1; A1; } 
+  
+#define RC_GET_BIT(p, mi) RC_GET_BIT2(p, mi, ; , ;)               
+
+#define RangeDecoderBitTreeDecode(probs, numLevels, res) \
+  { int i = numLevels; res = 1; \
+  do { CProb *p = probs + res; RC_GET_BIT(p, res) } while(--i != 0); \
+  res -= (1 << numLevels); }
+
+
+#define kNumPosBitsMax 4
+#define kNumPosStatesMax (1 << kNumPosBitsMax)
+
+#define kLenNumLowBits 3
+#define kLenNumLowSymbols (1 << kLenNumLowBits)
+#define kLenNumMidBits 3
+#define kLenNumMidSymbols (1 << kLenNumMidBits)
+#define kLenNumHighBits 8
+#define kLenNumHighSymbols (1 << kLenNumHighBits)
+
+#define LenChoice 0
+#define LenChoice2 (LenChoice + 1)
+#define LenLow (LenChoice2 + 1)
+#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
+#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
+#define kNumLenProbs (LenHigh + kLenNumHighSymbols) 
+
+
+#define kNumStates 12
+#define kNumLitStates 7
+
+#define kStartPosModelIndex 4
+#define kEndPosModelIndex 14
+#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
+
+#define kNumPosSlotBits 6
+#define kNumLenToPosStates 4
+
+#define kNumAlignBits 4
+#define kAlignTableSize (1 << kNumAlignBits)
+
+#define kMatchMinLen 2
+
+#define IsMatch 0
+#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
+#define IsRepG0 (IsRep + kNumStates)
+#define IsRepG1 (IsRepG0 + kNumStates)
+#define IsRepG2 (IsRepG1 + kNumStates)
+#define IsRep0Long (IsRepG2 + kNumStates)
+#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
+#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
+#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
+#define LenCoder (Align + kAlignTableSize)
+#define RepLenCoder (LenCoder + kNumLenProbs)
+#define Literal (RepLenCoder + kNumLenProbs)
+
+#if Literal != LZMA_BASE_SIZE
+StopCompilingDueBUG
+#endif
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size)
+{
+  unsigned char prop0;
+  if (size < LZMA_PROPERTIES_SIZE)
+    return LZMA_RESULT_DATA_ERROR;
+  prop0 = propsData[0];
+  if (prop0 >= (9 * 5 * 5))
+    return LZMA_RESULT_DATA_ERROR;
+  {
+    for (propsRes->pb = 0; prop0 >= (9 * 5); propsRes->pb++, prop0 -= (9 * 5));
+    for (propsRes->lp = 0; prop0 >= 9; propsRes->lp++, prop0 -= 9);
+    propsRes->lc = prop0;
+    /*
+    unsigned char remainder = (unsigned char)(prop0 / 9);
+    propsRes->lc = prop0 % 9;
+    propsRes->pb = remainder / 5;
+    propsRes->lp = remainder % 5;
+    */
+  }
+
+  #ifdef _LZMA_OUT_READ
+  {
+    int i;
+    propsRes->DictionarySize = 0;
+    for (i = 0; i < 4; i++)
+      propsRes->DictionarySize += (UInt32)(propsData[1 + i]) << (i * 8);
+    if (propsRes->DictionarySize == 0)
+      propsRes->DictionarySize = 1;
+  }
+  #endif
+  return LZMA_RESULT_OK;
+}
+
+#define kLzmaStreamWasFinishedId (-1)
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *InCallback,
+    #else
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    #endif
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed)
+{
+  CProb *p = vs->Probs;
+  SizeT nowPos = 0;
+  Byte previousByte = 0;
+  UInt32 posStateMask = (1 << (vs->Properties.pb)) - 1;
+  UInt32 literalPosMask = (1 << (vs->Properties.lp)) - 1;
+  int lc = vs->Properties.lc;
+
+  #ifdef _LZMA_OUT_READ
+  
+  UInt32 Range = vs->Range;
+  UInt32 Code = vs->Code;
+  #ifdef _LZMA_IN_CB
+  const Byte *Buffer = vs->Buffer;
+  const Byte *BufferLim = vs->BufferLim;
+  #else
+  const Byte *Buffer = inStream;
+  const Byte *BufferLim = inStream + inSize;
+  #endif
+  int state = vs->State;
+  UInt32 rep0 = vs->Reps[0], rep1 = vs->Reps[1], rep2 = vs->Reps[2], rep3 = vs->Reps[3];
+  int len = vs->RemainLen;
+  UInt32 globalPos = vs->GlobalPos;
+  UInt32 distanceLimit = vs->DistanceLimit;
+
+  Byte *dictionary = vs->Dictionary;
+  UInt32 dictionarySize = vs->Properties.DictionarySize;
+  UInt32 dictionaryPos = vs->DictionaryPos;
+
+  Byte tempDictionary[4];
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+  if (len == kLzmaStreamWasFinishedId)
+    return LZMA_RESULT_OK;
+
+  if (dictionarySize == 0)
+  {
+    dictionary = tempDictionary;
+    dictionarySize = 1;
+    tempDictionary[0] = vs->TempDictionary[0];
+  }
+
+  if (len == kLzmaNeedInitId)
+  {
+    {
+      UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+      UInt32 i;
+      for (i = 0; i < numProbs; i++)
+        p[i] = kBitModelTotal >> 1; 
+      rep0 = rep1 = rep2 = rep3 = 1;
+      state = 0;
+      globalPos = 0;
+      distanceLimit = 0;
+      dictionaryPos = 0;
+      dictionary[dictionarySize - 1] = 0;
+      #ifdef _LZMA_IN_CB
+      RC_INIT;
+      #else
+      RC_INIT(inStream, inSize);
+      #endif
+    }
+    len = 0;
+  }
+  while(len != 0 && nowPos < outSize)
+  {
+    UInt32 pos = dictionaryPos - rep0;
+    if (pos >= dictionarySize)
+      pos += dictionarySize;
+    outStream[nowPos++] = dictionary[dictionaryPos] = dictionary[pos];
+    if (++dictionaryPos == dictionarySize)
+      dictionaryPos = 0;
+    len--;
+  }
+  if (dictionaryPos == 0)
+    previousByte = dictionary[dictionarySize - 1];
+  else
+    previousByte = dictionary[dictionaryPos - 1];
+
+  #else /* if !_LZMA_OUT_READ */
+
+  int state = 0;
+  UInt32 rep0 = 1, rep1 = 1, rep2 = 1, rep3 = 1;
+  int len = 0;
+  const Byte *Buffer;
+  const Byte *BufferLim;
+  UInt32 Range;
+  UInt32 Code;
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+
+  {
+    UInt32 i;
+    UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+    for (i = 0; i < numProbs; i++)
+      p[i] = kBitModelTotal >> 1;
+  }
+  
+  #ifdef _LZMA_IN_CB
+  RC_INIT;
+  #else
+  RC_INIT(inStream, inSize);
+  #endif
+
+  #endif /* _LZMA_OUT_READ */
+
+  while(nowPos < outSize)
+  {
+    CProb *prob;
+    UInt32 bound;
+    int posState = (int)(
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & posStateMask);
+
+    prob = p + IsMatch + (state << kNumPosBitsMax) + posState;
+    IfBit0(prob)
+    {
+      int symbol = 1;
+      UpdateBit0(prob)
+      prob = p + Literal + (LZMA_LIT_SIZE * 
+        (((
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & literalPosMask) << lc) + (previousByte >> (8 - lc))));
+
+      if (state >= kNumLitStates)
+      {
+        int matchByte;
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        matchByte = dictionary[pos];
+        #else
+        matchByte = outStream[nowPos - rep0];
+        #endif
+        do
+        {
+          int bit;
+          CProb *probLit;
+          matchByte <<= 1;
+          bit = (matchByte & 0x100);
+          probLit = prob + 0x100 + bit + symbol;
+          RC_GET_BIT2(probLit, symbol, if (bit != 0) break, if (bit == 0) break)
+        }
+        while (symbol < 0x100);
+      }
+      while (symbol < 0x100)
+      {
+        CProb *probLit = prob + symbol;
+        RC_GET_BIT(probLit, symbol)
+      }
+      previousByte = (Byte)symbol;
+
+      outStream[nowPos++] = previousByte;
+      #ifdef _LZMA_OUT_READ
+      if (distanceLimit < dictionarySize)
+        distanceLimit++;
+
+      dictionary[dictionaryPos] = previousByte;
+      if (++dictionaryPos == dictionarySize)
+        dictionaryPos = 0;
+      #endif
+      if (state < 4) state = 0;
+      else if (state < 10) state -= 3;
+      else state -= 6;
+    }
+    else             
+    {
+      UpdateBit1(prob);
+      prob = p + IsRep + state;
+      IfBit0(prob)
+      {
+        UpdateBit0(prob);
+        rep3 = rep2;
+        rep2 = rep1;
+        rep1 = rep0;
+        state = state < kNumLitStates ? 0 : 3;
+        prob = p + LenCoder;
+      }
+      else
+      {
+        UpdateBit1(prob);
+        prob = p + IsRepG0 + state;
+        IfBit0(prob)
+        {
+          UpdateBit0(prob);
+          prob = p + IsRep0Long + (state << kNumPosBitsMax) + posState;
+          IfBit0(prob)
+          {
+            #ifdef _LZMA_OUT_READ
+            UInt32 pos;
+            #endif
+            UpdateBit0(prob);
+            
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit == 0)
+            #else
+            if (nowPos == 0)
+            #endif
+              return LZMA_RESULT_DATA_ERROR;
+            
+            state = state < kNumLitStates ? 9 : 11;
+            #ifdef _LZMA_OUT_READ
+            pos = dictionaryPos - rep0;
+            if (pos >= dictionarySize)
+              pos += dictionarySize;
+            previousByte = dictionary[pos];
+            dictionary[dictionaryPos] = previousByte;
+            if (++dictionaryPos == dictionarySize)
+              dictionaryPos = 0;
+            #else
+            previousByte = outStream[nowPos - rep0];
+            #endif
+            outStream[nowPos++] = previousByte;
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit < dictionarySize)
+              distanceLimit++;
+            #endif
+
+            continue;
+          }
+          else
+          {
+            UpdateBit1(prob);
+          }
+        }
+        else
+        {
+          UInt32 distance;
+          UpdateBit1(prob);
+          prob = p + IsRepG1 + state;
+          IfBit0(prob)
+          {
+            UpdateBit0(prob);
+            distance = rep1;
+          }
+          else 
+          {
+            UpdateBit1(prob);
+            prob = p + IsRepG2 + state;
+            IfBit0(prob)
+            {
+              UpdateBit0(prob);
+              distance = rep2;
+            }
+            else
+            {
+              UpdateBit1(prob);
+              distance = rep3;
+              rep3 = rep2;
+            }
+            rep2 = rep1;
+          }
+          rep1 = rep0;
+          rep0 = distance;
+        }
+        state = state < kNumLitStates ? 8 : 11;
+        prob = p + RepLenCoder;
+      }
+      {
+        int numBits, offset;
+        CProb *probLen = prob + LenChoice;
+        IfBit0(probLen)
+        {
+          UpdateBit0(probLen);
+          probLen = prob + LenLow + (posState << kLenNumLowBits);
+          offset = 0;
+          numBits = kLenNumLowBits;
+        }
+        else
+        {
+          UpdateBit1(probLen);
+          probLen = prob + LenChoice2;
+          IfBit0(probLen)
+          {
+            UpdateBit0(probLen);
+            probLen = prob + LenMid + (posState << kLenNumMidBits);
+            offset = kLenNumLowSymbols;
+            numBits = kLenNumMidBits;
+          }
+          else
+          {
+            UpdateBit1(probLen);
+            probLen = prob + LenHigh;
+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
+            numBits = kLenNumHighBits;
+          }
+        }
+        RangeDecoderBitTreeDecode(probLen, numBits, len);
+        len += offset;
+      }
+
+      if (state < 4)
+      {
+        int posSlot;
+        state += kNumLitStates;
+        prob = p + PosSlot +
+            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << 
+            kNumPosSlotBits);
+        RangeDecoderBitTreeDecode(prob, kNumPosSlotBits, posSlot);
+        if (posSlot >= kStartPosModelIndex)
+        {
+          int numDirectBits = ((posSlot >> 1) - 1);
+          rep0 = (2 | ((UInt32)posSlot & 1));
+          if (posSlot < kEndPosModelIndex)
+          {
+            rep0 <<= numDirectBits;
+            prob = p + SpecPos + rep0 - posSlot - 1;
+          }
+          else
+          {
+            numDirectBits -= kNumAlignBits;
+            do
+            {
+              RC_NORMALIZE
+              Range >>= 1;
+              rep0 <<= 1;
+              if (Code >= Range)
+              {
+                Code -= Range;
+                rep0 |= 1;
+              }
+            }
+            while (--numDirectBits != 0);
+            prob = p + Align;
+            rep0 <<= kNumAlignBits;
+            numDirectBits = kNumAlignBits;
+          }
+          {
+            int i = 1;
+            int mi = 1;
+            do
+            {
+              CProb *prob3 = prob + mi;
+              RC_GET_BIT2(prob3, mi, ; , rep0 |= i);
+              i <<= 1;
+            }
+            while(--numDirectBits != 0);
+          }
+        }
+        else
+          rep0 = posSlot;
+        if (++rep0 == (UInt32)(0))
+        {
+          /* it's for stream version */
+          len = kLzmaStreamWasFinishedId;
+          break;
+        }
+      }
+
+      len += kMatchMinLen;
+      #ifdef _LZMA_OUT_READ
+      if (rep0 > distanceLimit) 
+      #else
+      if (rep0 > nowPos)
+      #endif
+        return LZMA_RESULT_DATA_ERROR;
+
+      #ifdef _LZMA_OUT_READ
+      if (dictionarySize - distanceLimit > (UInt32)len)
+        distanceLimit += len;
+      else
+        distanceLimit = dictionarySize;
+      #endif
+
+      do
+      {
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        previousByte = dictionary[pos];
+        dictionary[dictionaryPos] = previousByte;
+        if (++dictionaryPos == dictionarySize)
+          dictionaryPos = 0;
+        #else
+        previousByte = outStream[nowPos - rep0];
+        #endif
+        len--;
+        outStream[nowPos++] = previousByte;
+      }
+      while(len != 0 && nowPos < outSize);
+    }
+  }
+  RC_NORMALIZE;
+
+  #ifdef _LZMA_OUT_READ
+  vs->Range = Range;
+  vs->Code = Code;
+  vs->DictionaryPos = dictionaryPos;
+  vs->GlobalPos = globalPos + (UInt32)nowPos;
+  vs->DistanceLimit = distanceLimit;
+  vs->Reps[0] = rep0;
+  vs->Reps[1] = rep1;
+  vs->Reps[2] = rep2;
+  vs->Reps[3] = rep3;
+  vs->State = state;
+  vs->RemainLen = len;
+  vs->TempDictionary[0] = tempDictionary[0];
+  #endif
+
+  #ifdef _LZMA_IN_CB
+  vs->Buffer = Buffer;
+  vs->BufferLim = BufferLim;
+  #else
+  *inSizeProcessed = (SizeT)(Buffer - inStream);
+  #endif
+  *outSizeProcessed = nowPos;
+  return LZMA_RESULT_OK;
+}
--- linux-2.6.13/fs/squashfs/LzmaDecode.h
+++ linux-2.6.13/fs/squashfs/LzmaDecode.h
@@ -0,0 +1 @@
+#include <linux/LzmaDecode.h>
--- linux-2.6.13/fs/squashfs/LzmaStateDecode.h
+++ linux-2.6.13/fs/squashfs/LzmaStateDecode.h
@@ -0,0 +1,115 @@
+/* 
+  LzmaStateDecode.h
+  LZMA Decoder interface (State version)
+
+  LZMA SDK 4.21 Copyright (c) 1999-2005 Igor Pavlov (2005-06-08)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this code, expressly permits you to 
+  statically or dynamically link your code (or bind by name) to the 
+  interfaces of this file without subjecting your linked code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#ifndef __LZMASTATEDECODE_H
+#define __LZMASTATEDECODE_H
+
+/* #define _LZMA_PROB32 */
+/* It can increase speed on some 32-bit CPUs, 
+   but memory usage will be doubled in that case */
+
+/* #define _LZMA_SYSTEM_SIZE_T */
+/* Use system's size_t. You can use it to enable 64-bit sizes supporting*/
+
+
+#ifndef UInt32
+#ifdef _LZMA_UINT32_IS_ULONG
+#define UInt32 unsigned long
+#else
+#define UInt32 unsigned int
+#endif
+#endif
+
+#ifndef SizeT
+#ifdef _LZMA_SYSTEM_SIZE_T
+#include <stddef.h>
+#define SizeT size_t
+#else
+#define SizeT UInt32
+#endif
+#endif
+
+#ifdef _LZMA_PROB32
+#define CProb UInt32
+#else
+#define CProb unsigned short
+#endif
+
+#define LZMA_RESULT_OK 0
+#define LZMA_RESULT_DATA_ERROR 1
+
+#define LZMA_BASE_SIZE 1846
+#define LZMA_LIT_SIZE 768
+
+#define LZMA_PROPERTIES_SIZE 5
+
+typedef struct _CLzmaProperties
+{
+  int lc;
+  int lp;
+  int pb;
+  UInt32 DictionarySize;
+}CLzmaProperties;
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size);
+
+#define LzmaGetNumProbs(lzmaProps) (LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((lzmaProps)->lc + (lzmaProps)->lp)))
+
+#define kLzmaInBufferSize 64   /* don't change it. it must be larger than kRequiredInBufferSize */
+
+#define kLzmaNeedInitId (-2)
+
+typedef struct _CLzmaDecoderState
+{
+  CLzmaProperties Properties;
+  CProb *Probs;
+  unsigned char *Dictionary;
+
+  unsigned char Buffer[kLzmaInBufferSize];
+  int BufferSize;
+
+  UInt32 Range;
+  UInt32 Code;
+  UInt32 DictionaryPos;
+  UInt32 GlobalPos;
+  UInt32 DistanceLimit;
+  UInt32 Reps[4];
+  int State;
+  int RemainLen;  /* -2: decoder needs internal initialization
+                     -1: stream was finished, 
+                      0: ok
+                    > 0: need to write RemainLen bytes as match Reps[0],
+                  */
+  unsigned char TempDictionary[4];  /* it's required when DictionarySize = 0 */
+} CLzmaDecoderState;
+
+#define LzmaDecoderInit(vs) { (vs)->RemainLen = kLzmaNeedInitId; (vs)->BufferSize = 0; }
+
+/* LzmaDecode: decoding from input stream to output stream.
+  If finishDecoding != 0, then there are no more bytes in input stream
+  after inStream[inSize - 1]. */
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    const unsigned char *inStream, SizeT inSize,  SizeT *inSizeProcessed,
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed,
+    int finishDecoding);
+
+#endif
--- linux-2.6.13/fs/squashfs/Makefile
+++ linux-2.6.13/fs/squashfs/Makefile
@@ -2,6 +2,10 @@
 # Makefile for the linux squashfs routines.
 #
 
+# CFLAGS_inode.o = -v -O2
+
 obj-$(CONFIG_SQUASHFS) += squashfs.o
 
-squashfs-objs := inode.o lzma_decode.a
+squashfs-y += inode.o
+squashfs-y += squashfs2_0.o
+squashfs-y += LzmaDecode.o 
--- linux-2.6.13/fs/squashfs/squashfs2_0.c
+++ linux-2.6.13/fs/squashfs/squashfs2_0.c
@@ -0,0 +1,743 @@
+/*
+ * Squashfs - a compressed read only filesystem for Linux
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007
+ * Phillip Lougher <phillip@lougher.demon.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs2_0.c
+ */
+
+#include <linux/squashfs_fs.h>
+#include <linux/module.h>
+#include <linux/zlib.h>
+#include <linux/fs.h>
+#include <linux/squashfs_fs_sb.h>
+#include <linux/squashfs_fs_i.h>
+
+#include "squashfs.h"
+static int squashfs_readdir_2(struct file *file, void *dirent, filldir_t filldir);
+static struct dentry *squashfs_lookup_2(struct inode *, struct dentry *,
+				struct nameidata *);
+
+#define squashfs_aops *(struct address_space_operations *)(&squashfs_aops)
+#define squashfs_symlink_aops *(struct address_space_operations *)(&squashfs_symlink_aops)
+
+static struct file_operations squashfs_dir_ops_2 = {
+	.read = generic_read_dir,
+	.readdir = squashfs_readdir_2
+};
+
+static struct inode_operations squashfs_dir_inode_ops_2 = {
+	.lookup = squashfs_lookup_2
+};
+
+static unsigned char squashfs_filetype_table[] = {
+	DT_UNKNOWN, DT_DIR, DT_REG, DT_LNK, DT_BLK, DT_CHR, DT_FIFO, DT_SOCK
+};
+
+static int read_fragment_index_table_2(struct super_block *s)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	if (!(msblk->fragment_index_2 = kmalloc(SQUASHFS_FRAGMENT_INDEX_BYTES_2
+					(sblk->fragments), GFP_KERNEL))) {
+		ERROR("Failed to allocate uid/gid table\n");
+		return 0;
+	}
+   
+	if (SQUASHFS_FRAGMENT_INDEX_BYTES_2(sblk->fragments) &&
+					!squashfs_read_data(s, (char *)
+					msblk->fragment_index_2,
+					sblk->fragment_table_start,
+					SQUASHFS_FRAGMENT_INDEX_BYTES_2
+					(sblk->fragments) |
+					SQUASHFS_COMPRESSED_BIT_BLOCK, NULL, SQUASHFS_FRAGMENT_INDEX_BYTES_2(sblk->fragments))) {
+		ERROR("unable to read fragment index table\n");
+		return 0;
+	}
+
+	if (msblk->swap) {
+		int i;
+		unsigned int fragment;
+
+		for (i = 0; i < SQUASHFS_FRAGMENT_INDEXES_2(sblk->fragments);
+									i++) {
+			SQUASHFS_SWAP_FRAGMENT_INDEXES_2((&fragment),
+						&msblk->fragment_index_2[i], 1);
+			msblk->fragment_index_2[i] = fragment;
+		}
+	}
+
+	return 1;
+}
+
+
+static int get_fragment_location_2(struct super_block *s, unsigned int fragment,
+				long long *fragment_start_block,
+				unsigned int *fragment_size)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	long long start_block =
+		msblk->fragment_index_2[SQUASHFS_FRAGMENT_INDEX_2(fragment)];
+	int offset = SQUASHFS_FRAGMENT_INDEX_OFFSET_2(fragment);
+	struct squashfs_fragment_entry_2 fragment_entry;
+
+	if (msblk->swap) {
+		struct squashfs_fragment_entry_2 sfragment_entry;
+
+		if (!squashfs_get_cached_block(s, (char *) &sfragment_entry,
+					start_block, offset,
+					sizeof(sfragment_entry), &start_block,
+					&offset))
+			goto out;
+		SQUASHFS_SWAP_FRAGMENT_ENTRY_2(&fragment_entry, &sfragment_entry);
+	} else
+		if (!squashfs_get_cached_block(s, (char *) &fragment_entry,
+					start_block, offset,
+					sizeof(fragment_entry), &start_block,
+					&offset))
+			goto out;
+
+	*fragment_start_block = fragment_entry.start_block;
+	*fragment_size = fragment_entry.size;
+
+	return 1;
+
+out:
+	return 0;
+}
+
+
+static void squashfs_new_inode(struct squashfs_sb_info *msblk, struct inode *i,
+		struct squashfs_base_inode_header_2 *inodeb, unsigned int ino)
+{
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	i->i_ino = ino;
+	i->i_mtime.tv_sec = sblk->mkfs_time;
+	i->i_atime.tv_sec = sblk->mkfs_time;
+	i->i_ctime.tv_sec = sblk->mkfs_time;
+	i->i_uid = msblk->uid[inodeb->uid];
+	i->i_mode = inodeb->mode;
+	i->i_nlink = 1;
+	i->i_size = 0;
+	if (inodeb->guid == SQUASHFS_GUIDS)
+		i->i_gid = i->i_uid;
+	else
+		i->i_gid = msblk->guid[inodeb->guid];
+}
+
+
+static int squashfs_read_inode_2(struct inode *i, squashfs_inode_t inode)
+{
+	struct super_block *s = i->i_sb;
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	unsigned int block = SQUASHFS_INODE_BLK(inode) +
+		sblk->inode_table_start;
+	unsigned int offset = SQUASHFS_INODE_OFFSET(inode);
+	unsigned int ino = SQUASHFS_MK_VFS_INODE(block -
+		sblk->inode_table_start, offset);
+	long long next_block;
+	unsigned int next_offset;
+	union squashfs_inode_header_2 id, sid;
+	struct squashfs_base_inode_header_2 *inodeb = &id.base,
+					  *sinodeb = &sid.base;
+
+	TRACE("Entered squashfs_read_inode_2\n");
+
+	if (msblk->swap) {
+		if (!squashfs_get_cached_block(s, (char *) sinodeb, block,
+					offset, sizeof(*sinodeb), &next_block,
+					&next_offset))
+			goto failed_read;
+		SQUASHFS_SWAP_BASE_INODE_HEADER_2(inodeb, sinodeb,
+					sizeof(*sinodeb));
+	} else
+		if (!squashfs_get_cached_block(s, (char *) inodeb, block,
+					offset, sizeof(*inodeb), &next_block,
+					&next_offset))
+			goto failed_read;
+
+	squashfs_new_inode(msblk, i, inodeb, ino);
+
+	switch(inodeb->inode_type) {
+		case SQUASHFS_FILE_TYPE: {
+			struct squashfs_reg_inode_header_2 *inodep = &id.reg;
+			struct squashfs_reg_inode_header_2 *sinodep = &sid.reg;
+			long long frag_blk;
+			unsigned int frag_size = 0;
+				
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_REG_INODE_HEADER_2(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			frag_blk = SQUASHFS_INVALID_BLK;
+			if (inodep->fragment != SQUASHFS_INVALID_FRAG &&
+					!get_fragment_location_2(s,
+					inodep->fragment, &frag_blk, &frag_size))
+				goto failed_read;
+				
+			i->i_size = inodep->file_size;
+			i->i_fop = &generic_ro_fops;
+			i->i_mode |= S_IFREG;
+			i->i_mtime.tv_sec = inodep->mtime;
+			i->i_atime.tv_sec = inodep->mtime;
+			i->i_ctime.tv_sec = inodep->mtime;
+			i->i_blocks = ((i->i_size - 1) >> 9) + 1;
+			SQUASHFS_I(i)->u.s1.fragment_start_block = frag_blk;
+			SQUASHFS_I(i)->u.s1.fragment_size = frag_size;
+			SQUASHFS_I(i)->u.s1.fragment_offset = inodep->offset;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->u.s1.block_list_start = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+			i->i_data.a_ops = &squashfs_aops;
+
+			TRACE("File inode %x:%x, start_block %x, "
+					"block_list_start %llx, offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->start_block, next_block,
+					next_offset);
+			break;
+		}
+		case SQUASHFS_DIR_TYPE: {
+			struct squashfs_dir_inode_header_2 *inodep = &id.dir;
+			struct squashfs_dir_inode_header_2 *sinodep = &sid.dir;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_DIR_INODE_HEADER_2(inodep, sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			i->i_size = inodep->file_size;
+			i->i_op = &squashfs_dir_inode_ops_2;
+			i->i_fop = &squashfs_dir_ops_2;
+			i->i_mode |= S_IFDIR;
+			i->i_mtime.tv_sec = inodep->mtime;
+			i->i_atime.tv_sec = inodep->mtime;
+			i->i_ctime.tv_sec = inodep->mtime;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->offset = inodep->offset;
+			SQUASHFS_I(i)->u.s2.directory_index_count = 0;
+			SQUASHFS_I(i)->u.s2.parent_inode = 0;
+
+			TRACE("Directory inode %x:%x, start_block %x, offset "
+					"%x\n", SQUASHFS_INODE_BLK(inode),
+					offset, inodep->start_block,
+					inodep->offset);
+			break;
+		}
+		case SQUASHFS_LDIR_TYPE: {
+			struct squashfs_ldir_inode_header_2 *inodep = &id.ldir;
+			struct squashfs_ldir_inode_header_2 *sinodep = &sid.ldir;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_LDIR_INODE_HEADER_2(inodep,
+						sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			i->i_size = inodep->file_size;
+			i->i_op = &squashfs_dir_inode_ops_2;
+			i->i_fop = &squashfs_dir_ops_2;
+			i->i_mode |= S_IFDIR;
+			i->i_mtime.tv_sec = inodep->mtime;
+			i->i_atime.tv_sec = inodep->mtime;
+			i->i_ctime.tv_sec = inodep->mtime;
+			SQUASHFS_I(i)->start_block = inodep->start_block;
+			SQUASHFS_I(i)->offset = inodep->offset;
+			SQUASHFS_I(i)->u.s2.directory_index_start = next_block;
+			SQUASHFS_I(i)->u.s2.directory_index_offset =
+								next_offset;
+			SQUASHFS_I(i)->u.s2.directory_index_count =
+								inodep->i_count;
+			SQUASHFS_I(i)->u.s2.parent_inode = 0;
+
+			TRACE("Long directory inode %x:%x, start_block %x, "
+					"offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->start_block, inodep->offset);
+			break;
+		}
+		case SQUASHFS_SYMLINK_TYPE: {
+			struct squashfs_symlink_inode_header_2 *inodep =
+								&id.symlink;
+			struct squashfs_symlink_inode_header_2 *sinodep =
+								&sid.symlink;
+	
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_SYMLINK_INODE_HEADER_2(inodep,
+								sinodep);
+			} else
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			i->i_size = inodep->symlink_size;
+			i->i_op = &page_symlink_inode_operations;
+			i->i_data.a_ops = &squashfs_symlink_aops;
+			i->i_mode |= S_IFLNK;
+			SQUASHFS_I(i)->start_block = next_block;
+			SQUASHFS_I(i)->offset = next_offset;
+
+			TRACE("Symbolic link inode %x:%x, start_block %llx, "
+					"offset %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					next_block, next_offset);
+			break;
+		 }
+		 case SQUASHFS_BLKDEV_TYPE:
+		 case SQUASHFS_CHRDEV_TYPE: {
+			struct squashfs_dev_inode_header_2 *inodep = &id.dev;
+			struct squashfs_dev_inode_header_2 *sinodep = &sid.dev;
+
+			if (msblk->swap) {
+				if (!squashfs_get_cached_block(s, (char *)
+						sinodep, block, offset,
+						sizeof(*sinodep), &next_block,
+						&next_offset))
+					goto failed_read;
+				SQUASHFS_SWAP_DEV_INODE_HEADER_2(inodep, sinodep);
+			} else	
+				if (!squashfs_get_cached_block(s, (char *)
+						inodep, block, offset,
+						sizeof(*inodep), &next_block,
+						&next_offset))
+					goto failed_read;
+
+			i->i_mode |= (inodeb->inode_type ==
+					SQUASHFS_CHRDEV_TYPE) ?  S_IFCHR :
+					S_IFBLK;
+			init_special_inode(i, i->i_mode,
+					old_decode_dev(inodep->rdev));
+
+			TRACE("Device inode %x:%x, rdev %x\n",
+					SQUASHFS_INODE_BLK(inode), offset,
+					inodep->rdev);
+			break;
+		 }
+		 case SQUASHFS_FIFO_TYPE:
+		 case SQUASHFS_SOCKET_TYPE: {
+
+			i->i_mode |= (inodeb->inode_type == SQUASHFS_FIFO_TYPE)
+							? S_IFIFO : S_IFSOCK;
+			init_special_inode(i, i->i_mode, 0);
+			break;
+		 }
+		 default:
+			ERROR("Unknown inode type %d in squashfs_iget!\n",
+					inodeb->inode_type);
+			goto failed_read1;
+	}
+	
+	return 1;
+
+failed_read:
+	ERROR("Unable to read inode [%x:%x]\n", block, offset);
+
+failed_read1:
+	return 0;
+}
+
+
+static int get_dir_index_using_offset(struct super_block *s, long long 
+				*next_block, unsigned int *next_offset,
+				long long index_start,
+				unsigned int index_offset, int i_count,
+				long long f_pos)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	int i, length = 0;
+	struct squashfs_dir_index_2 index;
+
+	TRACE("Entered get_dir_index_using_offset, i_count %d, f_pos %d\n",
+					i_count, (unsigned int) f_pos);
+
+	if (f_pos == 0)
+		goto finish;
+
+	for (i = 0; i < i_count; i++) {
+		if (msblk->swap) {
+			struct squashfs_dir_index_2 sindex;
+			squashfs_get_cached_block(s, (char *) &sindex,
+					index_start, index_offset,
+					sizeof(sindex), &index_start,
+					&index_offset);
+			SQUASHFS_SWAP_DIR_INDEX_2(&index, &sindex);
+		} else
+			squashfs_get_cached_block(s, (char *) &index,
+					index_start, index_offset,
+					sizeof(index), &index_start,
+					&index_offset);
+
+		if (index.index > f_pos)
+			break;
+
+		squashfs_get_cached_block(s, NULL, index_start, index_offset,
+					index.size + 1, &index_start,
+					&index_offset);
+
+		length = index.index;
+		*next_block = index.start_block + sblk->directory_table_start;
+	}
+
+	*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;
+
+finish:
+	return length;
+}
+
+
+static int get_dir_index_using_name(struct super_block *s, long long
+				*next_block, unsigned int *next_offset,
+				long long index_start,
+				unsigned int index_offset, int i_count,
+				const char *name, int size)
+{
+	struct squashfs_sb_info *msblk = s->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	int i, length = 0;
+	struct squashfs_dir_index_2 *index;
+	char *str;
+
+	TRACE("Entered get_dir_index_using_name, i_count %d\n", i_count);
+
+	if (!(str = kmalloc(sizeof(struct squashfs_dir_index) +
+		(SQUASHFS_NAME_LEN + 1) * 2, GFP_KERNEL))) {
+		ERROR("Failed to allocate squashfs_dir_index\n");
+		goto failure;
+	}
+
+	index = (struct squashfs_dir_index_2 *) (str + SQUASHFS_NAME_LEN + 1);
+	strncpy(str, name, size);
+	str[size] = '\0';
+
+	for (i = 0; i < i_count; i++) {
+		if (msblk->swap) {
+			struct squashfs_dir_index_2 sindex;
+			squashfs_get_cached_block(s, (char *) &sindex,
+					index_start, index_offset,
+					sizeof(sindex), &index_start,
+					&index_offset);
+			SQUASHFS_SWAP_DIR_INDEX_2(index, &sindex);
+		} else
+			squashfs_get_cached_block(s, (char *) index,
+					index_start, index_offset,
+					sizeof(struct squashfs_dir_index_2),
+					&index_start, &index_offset);
+
+		squashfs_get_cached_block(s, index->name, index_start,
+					index_offset, index->size + 1,
+					&index_start, &index_offset);
+
+		index->name[index->size + 1] = '\0';
+
+		if (strcmp(index->name, str) > 0)
+			break;
+
+		length = index->index;
+		*next_block = index->start_block + sblk->directory_table_start;
+	}
+
+	*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;
+	kfree(str);
+failure:
+	return length;
+}
+
+		
+static int squashfs_readdir_2(struct file *file, void *dirent, filldir_t filldir)
+{
+	struct inode *i = file->f_dentry->d_inode;
+	struct squashfs_sb_info *msblk = i->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	long long next_block = SQUASHFS_I(i)->start_block +
+		sblk->directory_table_start;
+	int next_offset = SQUASHFS_I(i)->offset, length = 0,
+		dir_count;
+	struct squashfs_dir_header_2 dirh;
+	struct squashfs_dir_entry_2 *dire;
+
+	TRACE("Entered squashfs_readdir_2 [%llx:%x]\n", next_block, next_offset);
+
+	if (!(dire = kmalloc(sizeof(struct squashfs_dir_entry) +
+		SQUASHFS_NAME_LEN + 1, GFP_KERNEL))) {
+		ERROR("Failed to allocate squashfs_dir_entry\n");
+		goto finish;
+	}
+
+	length = get_dir_index_using_offset(i->i_sb, &next_block, &next_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_start,
+				SQUASHFS_I(i)->u.s2.directory_index_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_count,
+				file->f_pos);
+
+	while (length < i_size_read(i)) {
+		/* read directory header */
+		if (msblk->swap) {
+			struct squashfs_dir_header_2 sdirh;
+			
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &sdirh,
+					next_block, next_offset, sizeof(sdirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(sdirh);
+			SQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);
+		} else {
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &dirh,
+					next_block, next_offset, sizeof(dirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(dirh);
+		}
+
+		dir_count = dirh.count + 1;
+		while (dir_count--) {
+			if (msblk->swap) {
+				struct squashfs_dir_entry_2 sdire;
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						&sdire, next_block, next_offset,
+						sizeof(sdire), &next_block,
+						&next_offset))
+					goto failed_read;
+				
+				length += sizeof(sdire);
+				SQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);
+			} else {
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						dire, next_block, next_offset,
+						sizeof(*dire), &next_block,
+						&next_offset))
+					goto failed_read;
+
+				length += sizeof(*dire);
+			}
+
+			if (!squashfs_get_cached_block(i->i_sb, dire->name,
+						next_block, next_offset,
+						dire->size + 1, &next_block,
+						&next_offset))
+				goto failed_read;
+
+			length += dire->size + 1;
+
+			if (file->f_pos >= length)
+				continue;
+
+			dire->name[dire->size + 1] = '\0';
+
+			TRACE("Calling filldir(%x, %s, %d, %d, %x:%x, %d)\n",
+					(unsigned int) dirent, dire->name,
+					dire->size + 1, (int) file->f_pos,
+					dirh.start_block, dire->offset,
+					squashfs_filetype_table[dire->type]);
+
+			if (filldir(dirent, dire->name, dire->size + 1,
+					file->f_pos, SQUASHFS_MK_VFS_INODE(
+					dirh.start_block, dire->offset),
+					squashfs_filetype_table[dire->type])
+					< 0) {
+				TRACE("Filldir returned less than 0\n");
+				goto finish;
+			}
+			file->f_pos = length;
+		}
+	}
+
+finish:
+	kfree(dire);
+	return 0;
+
+failed_read:
+	ERROR("Unable to read directory block [%llx:%x]\n", next_block,
+		next_offset);
+	kfree(dire);
+	return 0;
+}
+
+
+static struct dentry *squashfs_lookup_2(struct inode *i, struct dentry *dentry,
+				struct nameidata *nd)
+{
+	const unsigned char *name = dentry->d_name.name;
+	int len = dentry->d_name.len;
+	struct inode *inode = NULL;
+	struct squashfs_sb_info *msblk = i->i_sb->s_fs_info;
+	struct squashfs_super_block *sblk = &msblk->sblk;
+	long long next_block = SQUASHFS_I(i)->start_block +
+				sblk->directory_table_start;
+	int next_offset = SQUASHFS_I(i)->offset, length = 0,
+				dir_count;
+	struct squashfs_dir_header_2 dirh;
+	struct squashfs_dir_entry_2 *dire;
+	int sorted = sblk->s_major == 2 && sblk->s_minor >= 1;
+
+	TRACE("Entered squashfs_lookup_2 [%llx:%x]\n", next_block, next_offset);
+
+	if (!(dire = kmalloc(sizeof(struct squashfs_dir_entry) +
+		SQUASHFS_NAME_LEN + 1, GFP_KERNEL))) {
+		ERROR("Failed to allocate squashfs_dir_entry\n");
+		goto exit_loop;
+	}
+
+	if (len > SQUASHFS_NAME_LEN)
+		goto exit_loop;
+
+	length = get_dir_index_using_name(i->i_sb, &next_block, &next_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_start,
+				SQUASHFS_I(i)->u.s2.directory_index_offset,
+				SQUASHFS_I(i)->u.s2.directory_index_count, name,
+				len);
+
+	while (length < i_size_read(i)) {
+		/* read directory header */
+		if (msblk->swap) {
+			struct squashfs_dir_header_2 sdirh;
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &sdirh,
+					next_block, next_offset, sizeof(sdirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(sdirh);
+			SQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);
+		} else {
+			if (!squashfs_get_cached_block(i->i_sb, (char *) &dirh,
+					next_block, next_offset, sizeof(dirh),
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += sizeof(dirh);
+		}
+
+		dir_count = dirh.count + 1;
+		while (dir_count--) {
+			if (msblk->swap) {
+				struct squashfs_dir_entry_2 sdire;
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						&sdire, next_block,next_offset,
+						sizeof(sdire), &next_block,
+						&next_offset))
+					goto failed_read;
+				
+				length += sizeof(sdire);
+				SQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);
+			} else {
+				if (!squashfs_get_cached_block(i->i_sb, (char *)
+						dire, next_block,next_offset,
+						sizeof(*dire), &next_block,
+						&next_offset))
+					goto failed_read;
+
+				length += sizeof(*dire);
+			}
+
+			if (!squashfs_get_cached_block(i->i_sb, dire->name,
+					next_block, next_offset, dire->size + 1,
+					&next_block, &next_offset))
+				goto failed_read;
+
+			length += dire->size + 1;
+
+			if (sorted && name[0] < dire->name[0])
+				goto exit_loop;
+
+			if ((len == dire->size + 1) && !strncmp(name,
+						dire->name, len)) {
+				squashfs_inode_t ino =
+					SQUASHFS_MKINODE(dirh.start_block,
+					dire->offset);
+				unsigned int inode_number = SQUASHFS_MK_VFS_INODE(dirh.start_block,
+					dire->offset);
+
+				TRACE("calling squashfs_iget for directory "
+					"entry %s, inode %x:%x, %lld\n", name,
+					dirh.start_block, dire->offset, ino);
+
+				inode = squashfs_iget(i->i_sb, ino, inode_number);
+
+				goto exit_loop;
+			}
+		}
+	}
+
+exit_loop:
+	kfree(dire);
+	d_add(dentry, inode);
+	return ERR_PTR(0);
+
+failed_read:
+	ERROR("Unable to read directory block [%llx:%x]\n", next_block,
+		next_offset);
+	goto exit_loop;
+}
+
+
+int squashfs_2_0_supported(struct squashfs_sb_info *msblk)
+{
+	struct squashfs_super_block *sblk = &msblk->sblk;
+
+	msblk->read_inode = squashfs_read_inode_2;
+	msblk->read_fragment_index_table = read_fragment_index_table_2;
+
+	sblk->bytes_used = sblk->bytes_used_2;
+	sblk->uid_start = sblk->uid_start_2;
+	sblk->guid_start = sblk->guid_start_2;
+	sblk->inode_table_start = sblk->inode_table_start_2;
+	sblk->directory_table_start = sblk->directory_table_start_2;
+	sblk->fragment_table_start = sblk->fragment_table_start_2;
+
+	return 1;
+}
--- linux-2.6.13/fs/squashfs/squashfs.h
+++ linux-2.6.13/fs/squashfs/squashfs.h
@@ -0,0 +1,87 @@
+/*
+ * Squashfs - a compressed read only filesystem for Linux
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007
+ * Phillip Lougher <phillip@lougher.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs.h
+ */
+
+#ifdef CONFIG_SQUASHFS_1_0_COMPATIBILITY
+#undef CONFIG_SQUASHFS_1_0_COMPATIBILITY
+#endif
+
+#ifdef SQUASHFS_TRACE
+#define TRACE(s, args...)	printk(KERN_NOTICE "SQUASHFS: "s, ## args)
+#else
+#define TRACE(s, args...)	{}
+#endif
+
+#define ERROR(s, args...)	printk(KERN_ERR "SQUASHFS error: "s, ## args)
+
+#define SERROR(s, args...)	do { \
+				if (!silent) \
+				printk(KERN_ERR "SQUASHFS error: "s, ## args);\
+				} while(0)
+
+#define WARNING(s, args...)	printk(KERN_WARNING "SQUASHFS: "s, ## args)
+
+static inline struct squashfs_inode_info *SQUASHFS_I(struct inode *inode)
+{
+	return list_entry(inode, struct squashfs_inode_info, vfs_inode);
+}
+
+#if defined(CONFIG_SQUASHFS_1_0_COMPATIBILITY ) || defined(CONFIG_SQUASHFS_2_0_COMPATIBILITY)
+#define SQSH_EXTERN
+extern unsigned int squashfs_read_data(struct super_block *s, char *buffer,
+				long long index, unsigned int length,
+				long long *next_index, int srclength);
+extern int squashfs_get_cached_block(struct super_block *s, void *buffer,
+				long long block, unsigned int offset,
+				int length, long long *next_block,
+				unsigned int *next_offset);
+extern void release_cached_fragment(struct squashfs_sb_info *msblk, struct
+					squashfs_fragment_cache *fragment);
+extern struct squashfs_fragment_cache *get_cached_fragment(struct super_block
+					*s, long long start_block,
+					int length);
+extern struct inode *squashfs_iget(struct super_block *s, squashfs_inode_t inode, unsigned int inode_number);
+extern const struct address_space_operations squashfs_symlink_aops;
+extern const struct address_space_operations squashfs_aops;
+extern const struct address_space_operations squashfs_aops_4K;
+extern struct inode_operations squashfs_dir_inode_ops;
+#else
+#define SQSH_EXTERN static
+#endif
+
+#ifdef CONFIG_SQUASHFS_1_0_COMPATIBILITY
+extern int squashfs_1_0_supported(struct squashfs_sb_info *msblk);
+#else
+static inline int squashfs_1_0_supported(struct squashfs_sb_info *msblk)
+{
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_SQUASHFS_2_0_COMPATIBILITY
+extern int squashfs_2_0_supported(struct squashfs_sb_info *msblk);
+#else
+static inline int squashfs_2_0_supported(struct squashfs_sb_info *msblk)
+{
+	return 0;
+}
+#endif
--- linux-2.6.13/include/linux/LzmaDecode.h
+++ linux-2.6.13/include/linux/LzmaDecode.h
@@ -22,7 +22,7 @@
 #ifndef __LZMADECODE_H
 #define __LZMADECODE_H
 
-/* #define _LZMA_IN_CB */
+#define _LZMA_IN_CB
 /* Use callback for input data */
 
 /* #define _LZMA_OUT_READ */
--- linux-2.6.13/include/linux/squashfs_fs.h
+++ linux-2.6.13/include/linux/squashfs_fs.h
@@ -1,9 +1,11 @@
 #ifndef SQUASHFS_FS
 #define SQUASHFS_FS
+
 /*
  * Squashfs
  *
- * Copyright (c) 2002, 2003, 2004, 2005 Phillip Lougher <phillip@lougher.demon.co.uk>
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007
+ * Phillip Lougher <phillip@lougher.org.uk>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -22,17 +24,28 @@
  * squashfs_fs.h
  */
 
+#include <linux/autoconf.h>
+
+#ifndef CONFIG_SQUASHFS_2_0_COMPATIBILITY
+#define CONFIG_SQUASHFS_2_0_COMPATIBILITY
+#endif
+
 #ifdef	CONFIG_SQUASHFS_VMALLOC
 #define SQUASHFS_ALLOC(a)		vmalloc(a)
 #define SQUASHFS_FREE(a)		vfree(a)
 #else
+#error unsupported
 #define SQUASHFS_ALLOC(a)		kmalloc(a, GFP_KERNEL)
 #define SQUASHFS_FREE(a)		kfree(a)
 #endif
 #define SQUASHFS_CACHED_FRAGMENTS	CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE	
-#define SQUASHFS_MAJOR			2
-#define SQUASHFS_MINOR			1
+#define SQUASHFS_MAJOR			3
+#define SQUASHFS_MINOR			0
 #define SQUASHFS_MINOR_LZMA     76
+#define SQUASHFS_MINOR_AES_LZMA 77
+#define SQUASHFS_MINOR_CBC_LZMA 78
+#define SQUASHFS_MINOR_AES_ZIP  79
+#define SQUASHFS_MINOR_CBC_ZIP  80
 #define SQUASHFS_MAGIC			0x73717368
 #define SQUASHFS_MAGIC_SWAP		0x68737173
 #define SQUASHFS_START			0
@@ -42,10 +55,10 @@
 #define SQUASHFS_METADATA_LOG		13
 
 /* default size of data blocks */
-#define SQUASHFS_FILE_SIZE		65536
-#define SQUASHFS_FILE_LOG		16
+#define SQUASHFS_FILE_SIZE		131072
+#define SQUASHFS_FILE_LOG		17
 
-#define SQUASHFS_FILE_MAX_SIZE		65536
+#define SQUASHFS_FILE_MAX_SIZE		1048576
 
 /* Max number of uids and gids */
 #define SQUASHFS_UIDS			256
@@ -55,8 +68,9 @@
 #define SQUASHFS_NAME_LEN		256
 
 #define SQUASHFS_INVALID		((long long) 0xffffffffffff)
-#define SQUASHFS_INVALID_BLK		((long long) 0xffffffff)
-#define SQUASHFS_USED_BLK		((long long) 0xfffffffe)
+#define SQUASHFS_INVALID_FRAG		((unsigned int) 0xffffffff)
+#define SQUASHFS_INVALID_BLK		((long long) -1)
+#define SQUASHFS_USED_BLK		((long long) -2)
 
 /* Filesystem flags */
 #define SQUASHFS_NOI			0
@@ -66,15 +80,38 @@
 #define SQUASHFS_NO_FRAG		4
 #define SQUASHFS_ALWAYS_FRAG		5
 #define SQUASHFS_DUPLICATE		6
+#define SQUASHFS_EXPORT			7
+
 #define SQUASHFS_BIT(flag, bit)		((flag >> bit) & 1)
-#define SQUASHFS_UNCOMPRESSED_INODES(flags)	SQUASHFS_BIT(flags, SQUASHFS_NOI)
-#define SQUASHFS_UNCOMPRESSED_DATA(flags)	SQUASHFS_BIT(flags, SQUASHFS_NOD)
-#define SQUASHFS_UNCOMPRESSED_FRAGMENTS(flags)	SQUASHFS_BIT(flags, SQUASHFS_NOF)
-#define SQUASHFS_NO_FRAGMENTS(flags)		SQUASHFS_BIT(flags, SQUASHFS_NO_FRAG)
-#define SQUASHFS_ALWAYS_FRAGMENTS(flags)	SQUASHFS_BIT(flags, SQUASHFS_ALWAYS_FRAG)
-#define SQUASHFS_DUPLICATES(flags)		SQUASHFS_BIT(flags, SQUASHFS_DUPLICATE)
-#define SQUASHFS_CHECK_DATA(flags)		SQUASHFS_BIT(flags, SQUASHFS_CHECK)
-#define SQUASHFS_MKFLAGS(noi, nod, check_data, nof, no_frag, always_frag, duplicate_checking)	(noi | (nod << 1) | (check_data << 2) | (nof << 3) | (no_frag << 4) | (always_frag << 5) | (duplicate_checking << 6))
+
+#define SQUASHFS_UNCOMPRESSED_INODES(flags)	SQUASHFS_BIT(flags, \
+						SQUASHFS_NOI)
+
+#define SQUASHFS_UNCOMPRESSED_DATA(flags)	SQUASHFS_BIT(flags, \
+						SQUASHFS_NOD)
+
+#define SQUASHFS_UNCOMPRESSED_FRAGMENTS(flags)	SQUASHFS_BIT(flags, \
+						SQUASHFS_NOF)
+
+#define SQUASHFS_NO_FRAGMENTS(flags)		SQUASHFS_BIT(flags, \
+						SQUASHFS_NO_FRAG)
+
+#define SQUASHFS_ALWAYS_FRAGMENTS(flags)	SQUASHFS_BIT(flags, \
+						SQUASHFS_ALWAYS_FRAG)
+
+#define SQUASHFS_DUPLICATES(flags)		SQUASHFS_BIT(flags, \
+						SQUASHFS_DUPLICATE)
+
+#define SQUASHFS_EXPORTABLE(flags)		SQUASHFS_BIT(flags, \
+						SQUASHFS_EXPORT)
+
+#define SQUASHFS_CHECK_DATA(flags)		SQUASHFS_BIT(flags, \
+						SQUASHFS_CHECK)
+
+#define SQUASHFS_MKFLAGS(noi, nod, check_data, nof, no_frag, always_frag, \
+		duplicate_checking, exortable)	(noi | (nod << 1) | (check_data << 2) \
+		| (nof << 3) | (no_frag << 4) | (always_frag << 5) | \
+		(duplicate_checking << 6) | (exportable << 7))
 
 /* Max number of types and file types */
 #define SQUASHFS_DIR_TYPE		1
@@ -85,73 +122,129 @@
 #define SQUASHFS_FIFO_TYPE		6
 #define SQUASHFS_SOCKET_TYPE		7
 #define SQUASHFS_LDIR_TYPE		8
+#define SQUASHFS_LREG_TYPE		9
 
 /* 1.0 filesystem type definitions */
 #define SQUASHFS_TYPES			5
 #define SQUASHFS_IPC_TYPE		0
 
-/* Flag whether block is compressed or uncompressed, bit is set if block is uncompressed */
+/* Flag whether block is compressed or uncompressed, bit is set if block is
+ * uncompressed */
 #define SQUASHFS_COMPRESSED_BIT		(1 << 15)
+
 #define SQUASHFS_COMPRESSED_SIZE(B)	(((B) & ~SQUASHFS_COMPRESSED_BIT) ? \
 					(B) & ~SQUASHFS_COMPRESSED_BIT : SQUASHFS_COMPRESSED_BIT)
 
 #define SQUASHFS_COMPRESSED(B)		(!((B) & SQUASHFS_COMPRESSED_BIT))
 
 #define SQUASHFS_COMPRESSED_BIT_BLOCK		(1 << 24)
-#define SQUASHFS_COMPRESSED_SIZE_BLOCK(B)	(((B) & ~SQUASHFS_COMPRESSED_BIT_BLOCK) ? \
-					(B) & ~SQUASHFS_COMPRESSED_BIT_BLOCK : SQUASHFS_COMPRESSED_BIT_BLOCK)
+
+#define SQUASHFS_COMPRESSED_SIZE_BLOCK(B)	(((B) & \
+	~SQUASHFS_COMPRESSED_BIT_BLOCK) ? (B) & \
+	~SQUASHFS_COMPRESSED_BIT_BLOCK : SQUASHFS_COMPRESSED_BIT_BLOCK)
 
 #define SQUASHFS_COMPRESSED_BLOCK(B)		(!((B) & SQUASHFS_COMPRESSED_BIT_BLOCK))
 
 /*
- * Inode number ops.  Inodes consist of a compressed block number, and an uncompressed
- * offset within that block
+ * Inode number ops.  Inodes consist of a compressed block number, and an
+ * uncompressed  offset within that block
  */
 #define SQUASHFS_INODE_BLK(a)		((unsigned int) ((a) >> 16))
+
 #define SQUASHFS_INODE_OFFSET(a)	((unsigned int) ((a) & 0xffff))
-#define SQUASHFS_MKINODE(A, B)		((squashfs_inode)(((squashfs_inode) (A) << 16)\
-					+ (B)))
+
+#define SQUASHFS_MKINODE(A, B)		((squashfs_inode_t)(((squashfs_inode_t) (A)\
+					<< 16) + (B)))
 
 /* Compute 32 bit VFS inode number from squashfs inode number */
-#define SQUASHFS_MK_VFS_INODE(a, b)	((unsigned int) (((a) << 8) + ((b) >> 2) + 1))
+#define SQUASHFS_MK_VFS_INODE(a, b)	((unsigned int) (((a) << 8) + \
+					((b) >> 2) + 1))
+/* XXX */
 
 /* Translate between VFS mode and squashfs mode */
 #define SQUASHFS_MODE(a)		((a) & 0xfff)
 
 /* fragment and fragment table defines */
-typedef unsigned int			squashfs_fragment_index;
-#define SQUASHFS_FRAGMENT_BYTES(A)	(A * sizeof(squashfs_fragment_entry))
-#define SQUASHFS_FRAGMENT_INDEX(A)	(SQUASHFS_FRAGMENT_BYTES(A) / SQUASHFS_METADATA_SIZE)
-#define SQUASHFS_FRAGMENT_INDEX_OFFSET(A)	(SQUASHFS_FRAGMENT_BYTES(A) % SQUASHFS_METADATA_SIZE)
-#define SQUASHFS_FRAGMENT_INDEXES(A)	((SQUASHFS_FRAGMENT_BYTES(A) + SQUASHFS_METADATA_SIZE - 1) / SQUASHFS_METADATA_SIZE)
-#define SQUASHFS_FRAGMENT_INDEX_BYTES(A)	(SQUASHFS_FRAGMENT_INDEXES(A) * sizeof(squashfs_fragment_index))
+#define SQUASHFS_FRAGMENT_BYTES(A)	((A) * sizeof(struct squashfs_fragment_entry))
+
+#define SQUASHFS_FRAGMENT_INDEX(A)	(SQUASHFS_FRAGMENT_BYTES(A) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEX_OFFSET(A)	(SQUASHFS_FRAGMENT_BYTES(A) % \
+						SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEXES(A)	((SQUASHFS_FRAGMENT_BYTES(A) + \
+					SQUASHFS_METADATA_SIZE - 1) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEX_BYTES(A)	(SQUASHFS_FRAGMENT_INDEXES(A) *\
+						sizeof(long long))
+
+/* inode lookup table defines */
+#define SQUASHFS_LOOKUP_BYTES(A)	((A) * sizeof(squashfs_inode_t))
+
+#define SQUASHFS_LOOKUP_BLOCK(A)		(SQUASHFS_LOOKUP_BYTES(A) / \
+						SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_LOOKUP_BLOCK_OFFSET(A)		(SQUASHFS_LOOKUP_BYTES(A) % \
+						SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_LOOKUP_BLOCKS(A)	((SQUASHFS_LOOKUP_BYTES(A) + \
+					SQUASHFS_METADATA_SIZE - 1) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_LOOKUP_BLOCK_BYTES(A)	(SQUASHFS_LOOKUP_BLOCKS(A) *\
+					sizeof(long long))
 
 /* cached data constants for filesystem */
 #define SQUASHFS_CACHED_BLKS		8
 
-#define SQUASHFS_MAX_FILE_SIZE_LOG	32
-#define SQUASHFS_MAX_FILE_SIZE		((long long) 1 << (SQUASHFS_MAX_FILE_SIZE_LOG - 1))
+#define SQUASHFS_MAX_FILE_SIZE_LOG	64
+
+#define SQUASHFS_MAX_FILE_SIZE		((long long) 1 << \
+					(SQUASHFS_MAX_FILE_SIZE_LOG - 2))
 
 #define SQUASHFS_MARKER_BYTE		0xff
 
+/* meta index cache */
+#define SQUASHFS_META_INDEXES	(SQUASHFS_METADATA_SIZE / sizeof(unsigned int))
+#define SQUASHFS_META_ENTRIES	31
+#define SQUASHFS_META_NUMBER	8
+#define SQUASHFS_SLOTS		4
+
+struct meta_entry {
+	long long		data_block;
+	unsigned int		index_block;
+	unsigned short		offset;
+	unsigned short		pad;
+};
+
+struct meta_index {
+	unsigned int		inode_number;
+	unsigned int		offset;
+	unsigned short		entries;
+	unsigned short		skip;
+	unsigned short		locked;
+	unsigned short		pad;
+	struct meta_entry	meta_entry[SQUASHFS_META_ENTRIES];
+};
+
 
 /*
  * definitions for structures on disk
  */
 
-typedef unsigned int		squashfs_block;
-typedef long long		squashfs_inode;
-
-typedef unsigned int		squashfs_uid;
+typedef long long		squashfs_block_t;
+typedef long long		squashfs_inode_t;
 
 typedef struct squashfs_super_block {
 	unsigned int		s_magic;
 	unsigned int		inodes;
-	unsigned int		bytes_used;
-	unsigned int		uid_start;
-	unsigned int		guid_start;
-	unsigned int		inode_table_start;
-	unsigned int		directory_table_start;
+	unsigned int		bytes_used_2;
+	unsigned int		uid_start_2;
+	unsigned int		guid_start_2;
+	unsigned int		inode_table_start_2;
+	unsigned int		directory_table_start_2;
 	unsigned int		s_major:16;
 	unsigned int		s_minor:16;
 	unsigned int		block_size_1:16;
@@ -160,108 +253,125 @@
 	unsigned int		no_uids:8;
 	unsigned int		no_guids:8;
 	unsigned int		mkfs_time /* time of filesystem creation */;
-	squashfs_inode		root_inode;
+	squashfs_inode_t	root_inode;
 	unsigned int		block_size;
 	unsigned int		fragments;
-	unsigned int		fragment_table_start;
+	unsigned int		fragment_table_start_2;
+	long long		bytes_used;
+	long long		uid_start;
+	long long		guid_start;
+	long long		inode_table_start;
+	long long		directory_table_start;
+	long long		fragment_table_start;
+	long long		lookup_table_start;
 } __attribute__ ((packed)) squashfs_super_block;
 
-typedef struct {
-	unsigned int		index:27;
-	unsigned int		start_block:29;
+struct squashfs_dir_index {
+	unsigned int		index;
+	unsigned int		start_block;
 	unsigned char		size;
 	unsigned char		name[0];
-} __attribute__ ((packed)) squashfs_dir_index;
-
-typedef struct {
-	unsigned int		inode_type:4;
-	unsigned int		mode:12; /* protection */
-	unsigned int		uid:8; /* index into uid table */
-	unsigned int		guid:8; /* index into guid table */
-} __attribute__ ((packed)) squashfs_base_inode_header;
+} __attribute__ ((packed));
 
-typedef squashfs_base_inode_header squashfs_ipc_inode_header;
-
-typedef struct {
-	unsigned int		inode_type:4;
-	unsigned int		mode:12; /* protection */
-	unsigned int		uid:8; /* index into uid table */
-	unsigned int		guid:8; /* index into guid table */
+#define SQUASHFS_BASE_INODE_HEADER		\
+	unsigned int		inode_type:4;	\
+	unsigned int		mode:12;	\
+	unsigned int		uid:8;		\
+	unsigned int		guid:8;		\
+	unsigned int		mtime;		\
+	unsigned int 		inode_number;
+
+struct squashfs_base_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+} __attribute__ ((packed));
+
+struct squashfs_ipc_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+} __attribute__ ((packed));
+
+struct squashfs_dev_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
 	unsigned short		rdev;
-} __attribute__ ((packed)) squashfs_dev_inode_header;
+} __attribute__ ((packed));
 	
-typedef struct {
-	unsigned int		inode_type:4;
-	unsigned int		mode:12; /* protection */
-	unsigned int		uid:8; /* index into uid table */
-	unsigned int		guid:8; /* index into guid table */
+struct squashfs_symlink_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
 	unsigned short		symlink_size;
 	char			symlink[0];
-} __attribute__ ((packed)) squashfs_symlink_inode_header;
+} __attribute__ ((packed));
 
-typedef struct {
-	unsigned int		inode_type:4;
-	unsigned int		mode:12; /* protection */
-	unsigned int		uid:8; /* index into uid table */
-	unsigned int		guid:8; /* index into guid table */
-	unsigned int		mtime;
-	squashfs_block		start_block;
+struct squashfs_reg_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	squashfs_block_t	start_block;
 	unsigned int		fragment;
 	unsigned int		offset;
-	unsigned int		file_size:SQUASHFS_MAX_FILE_SIZE_LOG;
+	unsigned int		file_size;
 	unsigned short		block_list[0];
-} __attribute__ ((packed)) squashfs_reg_inode_header;
+} __attribute__ ((packed));
 
-typedef struct {
-	unsigned int		inode_type:4;
-	unsigned int		mode:12; /* protection */
-	unsigned int		uid:8; /* index into uid table */
-	unsigned int		guid:8; /* index into guid table */
+struct squashfs_lreg_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
+	squashfs_block_t	start_block;
+	unsigned int		fragment;
+	unsigned int		offset;
+	long long		file_size;
+	unsigned short		block_list[0];
+} __attribute__ ((packed));
+
+struct squashfs_dir_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
 	unsigned int		file_size:19;
 	unsigned int		offset:13;
-	unsigned int		mtime;
-	unsigned int		start_block:24;
-} __attribute__  ((packed)) squashfs_dir_inode_header;
+	unsigned int		start_block;
+	unsigned int		parent_inode;
+} __attribute__  ((packed));
 
-typedef struct {
-	unsigned int		inode_type:4;
-	unsigned int		mode:12; /* protection */
-	unsigned int		uid:8; /* index into uid table */
-	unsigned int		guid:8; /* index into guid table */
+struct squashfs_ldir_inode_header {
+	SQUASHFS_BASE_INODE_HEADER;
+	unsigned int		nlink;
 	unsigned int		file_size:27;
 	unsigned int		offset:13;
-	unsigned int		mtime;
-	unsigned int		start_block:24;
+	unsigned int		start_block;
 	unsigned int		i_count:16;
-	squashfs_dir_index	index[0];
-} __attribute__  ((packed)) squashfs_ldir_inode_header;
-
-typedef union {
-	squashfs_base_inode_header	base;
-	squashfs_dev_inode_header	dev;
-	squashfs_symlink_inode_header	symlink;
-	squashfs_reg_inode_header	reg;
-	squashfs_dir_inode_header	dir;
-	squashfs_ldir_inode_header	ldir;
-	squashfs_ipc_inode_header	ipc;
-} squashfs_inode_header;
+	unsigned int		parent_inode;
+	struct squashfs_dir_index	index[0];
+} __attribute__  ((packed));
+
+union squashfs_inode_header {
+	struct squashfs_base_inode_header	base;
+	struct squashfs_dev_inode_header	dev;
+	struct squashfs_symlink_inode_header	symlink;
+	struct squashfs_reg_inode_header	reg;
+	struct squashfs_lreg_inode_header	lreg;
+	struct squashfs_dir_inode_header	dir;
+	struct squashfs_ldir_inode_header	ldir;
+	struct squashfs_ipc_inode_header	ipc;
+};
 	
-typedef struct {
+struct squashfs_dir_entry {
 	unsigned int		offset:13;
 	unsigned int		type:3;
 	unsigned int		size:8;
+	int			inode_number:16;
 	char			name[0];
-} __attribute__ ((packed)) squashfs_dir_entry;
+} __attribute__ ((packed));
 
-typedef struct {
+struct squashfs_dir_header {
 	unsigned int		count:8;
-	unsigned int		start_block:24;
-} __attribute__ ((packed)) squashfs_dir_header;
-
-typedef struct {
 	unsigned int		start_block;
+	unsigned int		inode_number;
+} __attribute__ ((packed));
+
+struct squashfs_fragment_entry {
+	long long		start_block;
 	unsigned int		size;
-} __attribute__ ((packed)) squashfs_fragment_entry;
+	unsigned int		pending;
+} __attribute__ ((packed));
 
 extern int squashfs_uncompress_block(void *d, int dstlen, void *s, int srclen);
 extern int squashfs_uncompress_init(void);
@@ -269,20 +379,28 @@
 
 /*
  * macros to convert each packed bitfield structure from little endian to big
- * endian and vice versa.  These are needed when creating or using a filesystem on a
- * machine with different byte ordering to the target architecture.
+ * endian and vice versa.  These are needed when creating or using a filesystem
+ * on a machine with different byte ordering to the target architecture.
  *
  */
 
+#define SQUASHFS_SWAP_START \
+	int bits;\
+	int b_pos;\
+	unsigned long long val;\
+	unsigned char *s;\
+	unsigned char *d;
+
 #define SQUASHFS_SWAP_SUPER_BLOCK(s, d) {\
-	SQUASHFS_MEMSET(s, d, sizeof(squashfs_super_block));\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_super_block));\
 	SQUASHFS_SWAP((s)->s_magic, d, 0, 32);\
 	SQUASHFS_SWAP((s)->inodes, d, 32, 32);\
-	SQUASHFS_SWAP((s)->bytes_used, d, 64, 32);\
-	SQUASHFS_SWAP((s)->uid_start, d, 96, 32);\
-	SQUASHFS_SWAP((s)->guid_start, d, 128, 32);\
-	SQUASHFS_SWAP((s)->inode_table_start, d, 160, 32);\
-	SQUASHFS_SWAP((s)->directory_table_start, d, 192, 32);\
+	SQUASHFS_SWAP((s)->bytes_used_2, d, 64, 32);\
+	SQUASHFS_SWAP((s)->uid_start_2, d, 96, 32);\
+	SQUASHFS_SWAP((s)->guid_start_2, d, 128, 32);\
+	SQUASHFS_SWAP((s)->inode_table_start_2, d, 160, 32);\
+	SQUASHFS_SWAP((s)->directory_table_start_2, d, 192, 32);\
 	SQUASHFS_SWAP((s)->s_major, d, 224, 16);\
 	SQUASHFS_SWAP((s)->s_minor, d, 240, 16);\
 	SQUASHFS_SWAP((s)->block_size_1, d, 256, 16);\
@@ -294,153 +412,221 @@
 	SQUASHFS_SWAP((s)->root_inode, d, 344, 64);\
 	SQUASHFS_SWAP((s)->block_size, d, 408, 32);\
 	SQUASHFS_SWAP((s)->fragments, d, 440, 32);\
-	SQUASHFS_SWAP((s)->fragment_table_start, d, 472, 32);\
+	SQUASHFS_SWAP((s)->fragment_table_start_2, d, 472, 32);\
+	SQUASHFS_SWAP((s)->bytes_used, d, 504, 64);\
+	SQUASHFS_SWAP((s)->uid_start, d, 568, 64);\
+	SQUASHFS_SWAP((s)->guid_start, d, 632, 64);\
+	SQUASHFS_SWAP((s)->inode_table_start, d, 696, 64);\
+	SQUASHFS_SWAP((s)->directory_table_start, d, 760, 64);\
+	SQUASHFS_SWAP((s)->fragment_table_start, d, 824, 64);\
+	SQUASHFS_SWAP((s)->lookup_table_start, d, 888, 64);\
 }
 
-#define SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, n) {\
+#define SQUASHFS_SWAP_BASE_INODE_CORE(s, d, n)\
 	SQUASHFS_MEMSET(s, d, n);\
 	SQUASHFS_SWAP((s)->inode_type, d, 0, 4);\
 	SQUASHFS_SWAP((s)->mode, d, 4, 12);\
 	SQUASHFS_SWAP((s)->uid, d, 16, 8);\
 	SQUASHFS_SWAP((s)->guid, d, 24, 8);\
+	SQUASHFS_SWAP((s)->mtime, d, 32, 32);\
+	SQUASHFS_SWAP((s)->inode_number, d, 64, 32);
+
+#define SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, n) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, n)\
 }
 
-#define SQUASHFS_SWAP_IPC_INODE_HEADER(s, d) SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, sizeof(squashfs_ipc_inode_header))
+#define SQUASHFS_SWAP_IPC_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_ipc_inode_header))\
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+}
 
 #define SQUASHFS_SWAP_DEV_INODE_HEADER(s, d) {\
-	SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, sizeof(squashfs_dev_inode_header));\
-	SQUASHFS_SWAP((s)->rdev, d, 32, 16);\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_dev_inode_header)); \
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+	SQUASHFS_SWAP((s)->rdev, d, 128, 16);\
 }
 
 #define SQUASHFS_SWAP_SYMLINK_INODE_HEADER(s, d) {\
-	SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, sizeof(squashfs_symlink_inode_header));\
-	SQUASHFS_SWAP((s)->symlink_size, d, 32, 16);\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_symlink_inode_header));\
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+	SQUASHFS_SWAP((s)->symlink_size, d, 128, 16);\
 }
 
 #define SQUASHFS_SWAP_REG_INODE_HEADER(s, d) {\
-	SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, sizeof(squashfs_reg_inode_header));\
-	SQUASHFS_SWAP((s)->mtime, d, 32, 32);\
-	SQUASHFS_SWAP((s)->start_block, d, 64, 32);\
-	SQUASHFS_SWAP((s)->fragment, d, 96, 32);\
-	SQUASHFS_SWAP((s)->offset, d, 128, 32);\
-	SQUASHFS_SWAP((s)->file_size, d, 160, SQUASHFS_MAX_FILE_SIZE_LOG);\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_reg_inode_header));\
+	SQUASHFS_SWAP((s)->start_block, d, 96, 64);\
+	SQUASHFS_SWAP((s)->fragment, d, 160, 32);\
+	SQUASHFS_SWAP((s)->offset, d, 192, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 224, 32);\
+}
+
+#define SQUASHFS_SWAP_LREG_INODE_HEADER(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_lreg_inode_header));\
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 128, 64);\
+	SQUASHFS_SWAP((s)->fragment, d, 192, 32);\
+	SQUASHFS_SWAP((s)->offset, d, 224, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 256, 64);\
 }
 
 #define SQUASHFS_SWAP_DIR_INODE_HEADER(s, d) {\
-	SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, sizeof(squashfs_dir_inode_header));\
-	SQUASHFS_SWAP((s)->file_size, d, 32, 19);\
-	SQUASHFS_SWAP((s)->offset, d, 51, 13);\
-	SQUASHFS_SWAP((s)->mtime, d, 64, 32);\
-	SQUASHFS_SWAP((s)->start_block, d, 96, 24);\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_dir_inode_header));\
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 128, 19);\
+	SQUASHFS_SWAP((s)->offset, d, 147, 13);\
+	SQUASHFS_SWAP((s)->start_block, d, 160, 32);\
+	SQUASHFS_SWAP((s)->parent_inode, d, 192, 32);\
 }
 
 #define SQUASHFS_SWAP_LDIR_INODE_HEADER(s, d) {\
-	SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, sizeof(squashfs_ldir_inode_header));\
-	SQUASHFS_SWAP((s)->file_size, d, 32, 27);\
-	SQUASHFS_SWAP((s)->offset, d, 59, 13);\
-	SQUASHFS_SWAP((s)->mtime, d, 72, 32);\
-	SQUASHFS_SWAP((s)->start_block, d, 104, 24);\
-	SQUASHFS_SWAP((s)->i_count, d, 128, 16);\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE(s, d, \
+			sizeof(struct squashfs_ldir_inode_header));\
+	SQUASHFS_SWAP((s)->nlink, d, 96, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 128, 27);\
+	SQUASHFS_SWAP((s)->offset, d, 155, 13);\
+	SQUASHFS_SWAP((s)->start_block, d, 168, 32);\
+	SQUASHFS_SWAP((s)->i_count, d, 200, 16);\
+	SQUASHFS_SWAP((s)->parent_inode, d, 216, 32);\
 }
 
 #define SQUASHFS_SWAP_DIR_INDEX(s, d) {\
-	SQUASHFS_MEMSET(s, d, sizeof(squashfs_dir_index));\
-	SQUASHFS_SWAP((s)->index, d, 0, 27);\
-	SQUASHFS_SWAP((s)->start_block, d, 27, 29);\
-	SQUASHFS_SWAP((s)->size, d, 56, 8);\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_index));\
+	SQUASHFS_SWAP((s)->index, d, 0, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 32, 32);\
+	SQUASHFS_SWAP((s)->size, d, 64, 8);\
 }
 
 #define SQUASHFS_SWAP_DIR_HEADER(s, d) {\
-	SQUASHFS_MEMSET(s, d, sizeof(squashfs_dir_header));\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_header));\
 	SQUASHFS_SWAP((s)->count, d, 0, 8);\
-	SQUASHFS_SWAP((s)->start_block, d, 8, 24);\
+	SQUASHFS_SWAP((s)->start_block, d, 8, 32);\
+	SQUASHFS_SWAP((s)->inode_number, d, 40, 32);\
 }
 
 #define SQUASHFS_SWAP_DIR_ENTRY(s, d) {\
-	SQUASHFS_MEMSET(s, d, sizeof(squashfs_dir_entry));\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_entry));\
 	SQUASHFS_SWAP((s)->offset, d, 0, 13);\
 	SQUASHFS_SWAP((s)->type, d, 13, 3);\
 	SQUASHFS_SWAP((s)->size, d, 16, 8);\
+	SQUASHFS_SWAP((s)->inode_number, d, 24, 16);\
 }
 
 #define SQUASHFS_SWAP_FRAGMENT_ENTRY(s, d) {\
-	SQUASHFS_MEMSET(s, d, sizeof(squashfs_fragment_entry));\
-	SQUASHFS_SWAP((s)->start_block, d, 0, 32);\
-	SQUASHFS_SWAP((s)->size, d, 32, 32);\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_fragment_entry));\
+	SQUASHFS_SWAP((s)->start_block, d, 0, 64);\
+	SQUASHFS_SWAP((s)->size, d, 64, 32);\
 }
 
+#define SQUASHFS_SWAP_INODE_T(s, d) SQUASHFS_SWAP_LONG_LONGS(s, d, 1)
+
 #define SQUASHFS_SWAP_SHORTS(s, d, n) {\
 	int entry;\
 	int bit_position;\
+	SQUASHFS_SWAP_START\
 	SQUASHFS_MEMSET(s, d, n * 2);\
-	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += 16)\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \
+			16)\
 		SQUASHFS_SWAP(s[entry], d, bit_position, 16);\
 }
 
 #define SQUASHFS_SWAP_INTS(s, d, n) {\
 	int entry;\
 	int bit_position;\
+	SQUASHFS_SWAP_START\
 	SQUASHFS_MEMSET(s, d, n * 4);\
-	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += 32)\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \
+			32)\
 		SQUASHFS_SWAP(s[entry], d, bit_position, 32);\
 }
 
+#define SQUASHFS_SWAP_LONG_LONGS(s, d, n) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, n * 8);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \
+			64)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, 64);\
+}
+
 #define SQUASHFS_SWAP_DATA(s, d, n, bits) {\
 	int entry;\
 	int bit_position;\
+	SQUASHFS_SWAP_START\
 	SQUASHFS_MEMSET(s, d, n * bits / 8);\
-	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += bits)\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \
+			bits)\
 		SQUASHFS_SWAP(s[entry], d, bit_position, bits);\
 }
 
-#define SQUASHFS_SWAP_FRAGMENT_INDEXES(s, d, n) SQUASHFS_SWAP_INTS(s, d, n)
+#define SQUASHFS_SWAP_FRAGMENT_INDEXES(s, d, n) SQUASHFS_SWAP_LONG_LONGS(s, d, n)
+#define SQUASHFS_SWAP_LOOKUP_BLOCKS(s, d, n) SQUASHFS_SWAP_LONG_LONGS(s, d, n)
+
+#ifdef CONFIG_SQUASHFS_1_0_COMPATIBILITY
 
-#ifdef SQUASHFS_1_0_COMPATIBILITY
-typedef struct {
+struct squashfs_base_inode_header_1 {
 	unsigned int		inode_type:4;
 	unsigned int		mode:12; /* protection */
 	unsigned int		uid:4; /* index into uid table */
 	unsigned int		guid:4; /* index into guid table */
-} __attribute__ ((packed)) squashfs_base_inode_header_1;
+} __attribute__ ((packed));
 
-typedef struct {
+struct squashfs_ipc_inode_header_1 {
 	unsigned int		inode_type:4;
 	unsigned int		mode:12; /* protection */
 	unsigned int		uid:4; /* index into uid table */
 	unsigned int		guid:4; /* index into guid table */
 	unsigned int		type:4;
 	unsigned int		offset:4;
-} __attribute__ ((packed)) squashfs_ipc_inode_header_1;
+} __attribute__ ((packed));
 
-typedef struct {
+struct squashfs_dev_inode_header_1 {
 	unsigned int		inode_type:4;
 	unsigned int		mode:12; /* protection */
 	unsigned int		uid:4; /* index into uid table */
 	unsigned int		guid:4; /* index into guid table */
 	unsigned short		rdev;
-} __attribute__ ((packed)) squashfs_dev_inode_header_1;
+} __attribute__ ((packed));
 	
-typedef struct {
+struct squashfs_symlink_inode_header_1 {
 	unsigned int		inode_type:4;
 	unsigned int		mode:12; /* protection */
 	unsigned int		uid:4; /* index into uid table */
 	unsigned int		guid:4; /* index into guid table */
 	unsigned short		symlink_size;
 	char			symlink[0];
-} __attribute__ ((packed)) squashfs_symlink_inode_header_1;
+} __attribute__ ((packed));
 
-typedef struct {
+struct squashfs_reg_inode_header_1 {
 	unsigned int		inode_type:4;
 	unsigned int		mode:12; /* protection */
 	unsigned int		uid:4; /* index into uid table */
 	unsigned int		guid:4; /* index into guid table */
 	unsigned int		mtime;
-	squashfs_block		start_block;
-	unsigned int		file_size:SQUASHFS_MAX_FILE_SIZE_LOG;
+	unsigned int		start_block;
+	unsigned int		file_size:32;
 	unsigned short		block_list[0];
-} __attribute__ ((packed)) squashfs_reg_inode_header_1;
+} __attribute__ ((packed));
 
-typedef struct {
+struct squashfs_dir_inode_header_1 {
 	unsigned int		inode_type:4;
 	unsigned int		mode:12; /* protection */
 	unsigned int		uid:4; /* index into uid table */
@@ -449,72 +635,308 @@
 	unsigned int		offset:13;
 	unsigned int		mtime;
 	unsigned int		start_block:24;
-} __attribute__  ((packed)) squashfs_dir_inode_header_1;
+} __attribute__  ((packed));
 
-#define SQUASHFS_SWAP_BASE_INODE_HEADER_1(s, d, n) {\
+#define SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, n) \
 	SQUASHFS_MEMSET(s, d, n);\
 	SQUASHFS_SWAP((s)->inode_type, d, 0, 4);\
 	SQUASHFS_SWAP((s)->mode, d, 4, 12);\
 	SQUASHFS_SWAP((s)->uid, d, 16, 4);\
-	SQUASHFS_SWAP((s)->guid, d, 20, 4);\
+	SQUASHFS_SWAP((s)->guid, d, 20, 4);
+
+#define SQUASHFS_SWAP_BASE_INODE_HEADER_1(s, d, n) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, n)\
 }
 
 #define SQUASHFS_SWAP_IPC_INODE_HEADER_1(s, d) {\
-	SQUASHFS_SWAP_BASE_INODE_HEADER_1(s, d, sizeof(squashfs_ipc_inode_header_1));\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \
+			sizeof(struct squashfs_ipc_inode_header_1));\
 	SQUASHFS_SWAP((s)->type, d, 24, 4);\
 	SQUASHFS_SWAP((s)->offset, d, 28, 4);\
 }
 
 #define SQUASHFS_SWAP_DEV_INODE_HEADER_1(s, d) {\
-	SQUASHFS_SWAP_BASE_INODE_HEADER_1(s, d, sizeof(squashfs_dev_inode_header_1));\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \
+			sizeof(struct squashfs_dev_inode_header_1));\
 	SQUASHFS_SWAP((s)->rdev, d, 24, 16);\
 }
 
 #define SQUASHFS_SWAP_SYMLINK_INODE_HEADER_1(s, d) {\
-	SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, sizeof(squashfs_symlink_inode_header_1));\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \
+			sizeof(struct squashfs_symlink_inode_header_1));\
 	SQUASHFS_SWAP((s)->symlink_size, d, 24, 16);\
 }
 
 #define SQUASHFS_SWAP_REG_INODE_HEADER_1(s, d) {\
-	SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, sizeof(squashfs_reg_inode_header_1));\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \
+			sizeof(struct squashfs_reg_inode_header_1));\
 	SQUASHFS_SWAP((s)->mtime, d, 24, 32);\
 	SQUASHFS_SWAP((s)->start_block, d, 56, 32);\
-	SQUASHFS_SWAP((s)->file_size, d, 88, SQUASHFS_MAX_FILE_SIZE_LOG);\
+	SQUASHFS_SWAP((s)->file_size, d, 88, 32);\
 }
 
 #define SQUASHFS_SWAP_DIR_INODE_HEADER_1(s, d) {\
-	SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, sizeof(squashfs_dir_inode_header_1));\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \
+			sizeof(struct squashfs_dir_inode_header_1));\
 	SQUASHFS_SWAP((s)->file_size, d, 24, 19);\
 	SQUASHFS_SWAP((s)->offset, d, 43, 13);\
 	SQUASHFS_SWAP((s)->mtime, d, 56, 32);\
 	SQUASHFS_SWAP((s)->start_block, d, 88, 24);\
 }
+
+#endif
+
+#ifdef CONFIG_SQUASHFS_2_0_COMPATIBILITY
+
+struct squashfs_dir_index_2 {
+	unsigned int		index:27;
+	unsigned int		start_block:29;
+	unsigned char		size;
+	unsigned char		name[0];
+} __attribute__ ((packed));
+
+struct squashfs_base_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+} __attribute__ ((packed));
+
+struct squashfs_ipc_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+} __attribute__ ((packed));
+
+struct squashfs_dev_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned short		rdev;
+} __attribute__ ((packed));
+	
+struct squashfs_symlink_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned short		symlink_size;
+	char			symlink[0];
+} __attribute__ ((packed));
+
+struct squashfs_reg_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned int		mtime;
+	unsigned int		start_block;
+	unsigned int		fragment;
+	unsigned int		offset;
+	unsigned int		file_size:32;
+	unsigned short		block_list[0];
+} __attribute__ ((packed));
+
+struct squashfs_dir_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned int		file_size:19;
+	unsigned int		offset:13;
+	unsigned int		mtime;
+	unsigned int		start_block:24;
+} __attribute__  ((packed));
+
+struct squashfs_ldir_inode_header_2 {
+	unsigned int		inode_type:4;
+	unsigned int		mode:12; /* protection */
+	unsigned int		uid:8; /* index into uid table */
+	unsigned int		guid:8; /* index into guid table */
+	unsigned int		file_size:27;
+	unsigned int		offset:13;
+	unsigned int		mtime;
+	unsigned int		start_block:24;
+	unsigned int		i_count:16;
+	struct squashfs_dir_index_2	index[0];
+} __attribute__  ((packed));
+
+union squashfs_inode_header_2 {
+	struct squashfs_base_inode_header_2	base;
+	struct squashfs_dev_inode_header_2	dev;
+	struct squashfs_symlink_inode_header_2	symlink;
+	struct squashfs_reg_inode_header_2	reg;
+	struct squashfs_dir_inode_header_2	dir;
+	struct squashfs_ldir_inode_header_2	ldir;
+	struct squashfs_ipc_inode_header_2	ipc;
+};
+	
+struct squashfs_dir_header_2 {
+	unsigned int		count:8;
+	unsigned int		start_block:24;
+} __attribute__ ((packed));
+
+struct squashfs_dir_entry_2 {
+	unsigned int		offset:13;
+	unsigned int		type:3;
+	unsigned int		size:8;
+	char			name[0];
+} __attribute__ ((packed));
+
+struct squashfs_fragment_entry_2 {
+	unsigned int		start_block;
+	unsigned int		size;
+} __attribute__ ((packed));
+
+#define SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, n)\
+	SQUASHFS_MEMSET(s, d, n);\
+	SQUASHFS_SWAP((s)->inode_type, d, 0, 4);\
+	SQUASHFS_SWAP((s)->mode, d, 4, 12);\
+	SQUASHFS_SWAP((s)->uid, d, 16, 8);\
+	SQUASHFS_SWAP((s)->guid, d, 24, 8);\
+
+#define SQUASHFS_SWAP_BASE_INODE_HEADER_2(s, d, n) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, n)\
+}
+
+#define SQUASHFS_SWAP_IPC_INODE_HEADER_2(s, d) \
+	SQUASHFS_SWAP_BASE_INODE_HEADER_2(s, d, sizeof(struct squashfs_ipc_inode_header_2))
+
+#define SQUASHFS_SWAP_DEV_INODE_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \
+			sizeof(struct squashfs_dev_inode_header_2)); \
+	SQUASHFS_SWAP((s)->rdev, d, 32, 16);\
+}
+
+#define SQUASHFS_SWAP_SYMLINK_INODE_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \
+			sizeof(struct squashfs_symlink_inode_header_2));\
+	SQUASHFS_SWAP((s)->symlink_size, d, 32, 16);\
+}
+
+#define SQUASHFS_SWAP_REG_INODE_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \
+			sizeof(struct squashfs_reg_inode_header_2));\
+	SQUASHFS_SWAP((s)->mtime, d, 32, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 64, 32);\
+	SQUASHFS_SWAP((s)->fragment, d, 96, 32);\
+	SQUASHFS_SWAP((s)->offset, d, 128, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 160, 32);\
+}
+
+#define SQUASHFS_SWAP_DIR_INODE_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \
+			sizeof(struct squashfs_dir_inode_header_2));\
+	SQUASHFS_SWAP((s)->file_size, d, 32, 19);\
+	SQUASHFS_SWAP((s)->offset, d, 51, 13);\
+	SQUASHFS_SWAP((s)->mtime, d, 64, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 96, 24);\
+}
+
+#define SQUASHFS_SWAP_LDIR_INODE_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \
+			sizeof(struct squashfs_ldir_inode_header_2));\
+	SQUASHFS_SWAP((s)->file_size, d, 32, 27);\
+	SQUASHFS_SWAP((s)->offset, d, 59, 13);\
+	SQUASHFS_SWAP((s)->mtime, d, 72, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 104, 24);\
+	SQUASHFS_SWAP((s)->i_count, d, 128, 16);\
+}
+
+#define SQUASHFS_SWAP_DIR_INDEX_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_index_2));\
+	SQUASHFS_SWAP((s)->index, d, 0, 27);\
+	SQUASHFS_SWAP((s)->start_block, d, 27, 29);\
+	SQUASHFS_SWAP((s)->size, d, 56, 8);\
+}
+#define SQUASHFS_SWAP_DIR_HEADER_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_header_2));\
+	SQUASHFS_SWAP((s)->count, d, 0, 8);\
+	SQUASHFS_SWAP((s)->start_block, d, 8, 24);\
+}
+
+#define SQUASHFS_SWAP_DIR_ENTRY_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_entry_2));\
+	SQUASHFS_SWAP((s)->offset, d, 0, 13);\
+	SQUASHFS_SWAP((s)->type, d, 13, 3);\
+	SQUASHFS_SWAP((s)->size, d, 16, 8);\
+}
+
+#define SQUASHFS_SWAP_FRAGMENT_ENTRY_2(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_fragment_entry_2));\
+	SQUASHFS_SWAP((s)->start_block, d, 0, 32);\
+	SQUASHFS_SWAP((s)->size, d, 32, 32);\
+}
+
+#define SQUASHFS_SWAP_FRAGMENT_INDEXES_2(s, d, n) SQUASHFS_SWAP_INTS(s, d, n)
+
+/* fragment and fragment table defines */
+#define SQUASHFS_FRAGMENT_BYTES_2(A)	(A * sizeof(struct squashfs_fragment_entry_2))
+
+#define SQUASHFS_FRAGMENT_INDEX_2(A)	(SQUASHFS_FRAGMENT_BYTES_2(A) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEX_OFFSET_2(A)	(SQUASHFS_FRAGMENT_BYTES_2(A) % \
+						SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEXES_2(A)	((SQUASHFS_FRAGMENT_BYTES_2(A) + \
+					SQUASHFS_METADATA_SIZE - 1) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEX_BYTES_2(A)	(SQUASHFS_FRAGMENT_INDEXES_2(A) *\
+						sizeof(int))
+
 #endif
 
 #ifdef __KERNEL__
+
 /*
  * macros used to swap each structure entry, taking into account
- * bitfields and different bitfield placing conventions on differing architectures
+ * bitfields and different bitfield placing conventions on differing
+ * architectures
  */
+
 #include <asm/byteorder.h>
+
 #ifdef __BIG_ENDIAN
 	/* convert from little endian to big endian */
-#define SQUASHFS_SWAP(value, p, pos, tbits) _SQUASHFS_SWAP(value, p, pos, tbits, b_pos)
+#define SQUASHFS_SWAP(value, p, pos, tbits) _SQUASHFS_SWAP(value, p, pos, \
+		tbits, b_pos)
 #else
 	/* convert from big endian to little endian */ 
-#define SQUASHFS_SWAP(value, p, pos, tbits) _SQUASHFS_SWAP(value, p, pos, tbits, 64 - tbits - b_pos)
+#define SQUASHFS_SWAP(value, p, pos, tbits) _SQUASHFS_SWAP(value, p, pos, \
+		tbits, 64 - tbits - b_pos)
 #endif
 
 #define _SQUASHFS_SWAP(value, p, pos, tbits, SHIFT) {\
-	int bits;\
-	int b_pos = pos % 8;\
-	unsigned long long val = 0;\
-	unsigned char *s = (unsigned char *)p + (pos / 8);\
-	unsigned char *d = ((unsigned char *) &val) + 7;\
+	b_pos = pos % 8;\
+	val = 0;\
+	s = (unsigned char *)p + (pos / 8);\
+	d = ((unsigned char *) &val) + 7;\
 	for(bits = 0; bits < (tbits + b_pos); bits += 8) \
 		*d-- = *s++;\
 	value = (val >> (SHIFT))/* & ((1 << tbits) - 1)*/;\
 }
+
 #define SQUASHFS_MEMSET(s, d, n)	memset(s, 0, n);
+
 #endif
 #endif
--- linux-2.6.13/include/linux/squashfs_fs_i.h
+++ linux-2.6.13/include/linux/squashfs_fs_i.h
@@ -3,7 +3,8 @@
 /*
  * Squashfs
  *
- * Copyright (c) 2002, 2003, 2004, 2005 Phillip Lougher <phillip@lougher.demon.co.uk>
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007
+ * Phillip Lougher <phillip@lougher.org.uk>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -22,22 +23,23 @@
  * squashfs_fs_i.h
  */
 
-typedef struct squashfs_inode_info {
-	unsigned int	start_block;
-	unsigned int	block_list_start;
+struct squashfs_inode_info {
+	long long	start_block;
 	unsigned int	offset;
 	union {
 		struct {
-			unsigned int	fragment_start_block;
+			long long	fragment_start_block;
 			unsigned int	fragment_size;
 			unsigned int	fragment_offset;
+			long long	block_list_start;
 		} s1;
 		struct {
-			unsigned int	directory_index_start;
+			long long	directory_index_start;
 			unsigned int	directory_index_offset;
 			unsigned int	directory_index_count;
+			unsigned int	parent_inode;
 		} s2;
 	} u;
 	struct inode	vfs_inode;
-	} squashfs_inode_info;
+};
 #endif
--- linux-2.6.13/include/linux/squashfs_fs_sb.h
+++ linux-2.6.13/include/linux/squashfs_fs_sb.h
@@ -3,7 +3,8 @@
 /*
  * Squashfs
  *
- * Copyright (c) 2002, 2003, 2004, 2005 Phillip Lougher <phillip@lougher.demon.co.uk>
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007
+ * Phillip Lougher <phillip@lougher.demon.co.uk>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -23,43 +24,58 @@
  */
 
 #include <linux/squashfs_fs.h>
+#include <linux/LzmaDecode.h>
 
-typedef struct {
-	unsigned int	block;
+struct squashfs_cache {
+	long long	block;
 	int		length;
-	unsigned int	next_index;
+	long long	next_index;
 	char		*data;
-	} squashfs_cache;
+};
 
 struct squashfs_fragment_cache {
-	unsigned int	block;
+	long long	block;
 	int		length;
 	unsigned int	locked;
 	char		*data;
-	};
+};
 
-typedef struct squashfs_sb_info {
-	squashfs_super_block	sBlk;
+struct squashfs_sb_info {
+	struct squashfs_super_block	sblk;
 	int			devblksize;
 	int			devblksize_log2;
 	int			swap;
-	squashfs_cache		*block_cache;
+	struct squashfs_cache	*block_cache;
 	struct squashfs_fragment_cache	*fragment;
 	int			next_cache;
 	int			next_fragment;
-	squashfs_uid		*uid;
-	squashfs_uid		*guid;
-	squashfs_fragment_index		*fragment_index;
-	unsigned int		read_size;
-	char			*read_data;
+	int			next_meta_index;
+	unsigned int		*uid;
+	unsigned int		*guid;
+	long long		*fragment_index;
+	unsigned int		*fragment_index_2;
 	char			*read_page;
+	struct semaphore	read_data_mutex;
 	struct semaphore	read_page_mutex;
 	struct semaphore	block_cache_mutex;
 	struct semaphore	fragment_mutex;
+	struct semaphore	meta_index_mutex;
 	wait_queue_head_t	waitq;
 	wait_queue_head_t	fragment_wait_queue;
-	struct inode		*(*iget)(struct super_block *s, squashfs_inode inode);
-	unsigned int		(*read_blocklist)(struct inode *inode, int index, int readahead_blks,
-					char *block_list, unsigned short **block_p, unsigned int *bsize);
-	} squashfs_sb_info;
+	struct meta_index	*meta_index;
+	long long		*inode_lookup_table;
+	int			unused_cache_blks;
+	int			unused_frag_blks;
+	int			(*read_inode)(struct inode *i,  squashfs_inode_t \
+				inode);
+	long long		(*read_blocklist)(struct inode *inode, int \
+				index, int readahead_blks, char *block_list, \
+				unsigned short **block_p, unsigned int *bsize);
+	int			(*read_fragment_index_table)(struct super_block *s);
+#ifdef CONFIG_SQUASH_ZLIB
+	z_stream		stream;
+	int use_lzma;
+#endif
+	CLzmaDecoderState	lzma_decoder_state;
+};
 #endif
--- linux-2.6.13/init/do_mounts_rd.c
+++ linux-2.6.13/init/do_mounts_rd.c
@@ -110,6 +110,9 @@
 		printk(KERN_NOTICE
 		       "RAMDISK: squashfs filesystem found at block %d\n",
 		       start_block);
+                if (squashfsb->s_major < 3)
+                       nblocks = (squashfsb->bytes_used_2+BLOCK_SIZE-1)>>BLOCK_SIZE_BITS;
+                else
 		nblocks = (squashfsb->bytes_used+BLOCK_SIZE-1)>>BLOCK_SIZE_BITS;
 		goto done;
 	}
