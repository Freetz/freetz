--- squashfs-tools/Makefile
+++ squashfs-tools/Makefile
@@ -115,7 +115,8 @@
 	caches-queues-lists.o
 
-UNSQUASHFS_OBJS = unsquashfs.o unsquash-1.o unsquash-2.o unsquash-3.o \
-	unsquash-4.o swap.o compressor.o unsquashfs_info.o
+UNSQUASHFS_OBJS = unsquashfs.o                                        \
+	             swap.o compressor.o unsquashfs_info.o             \
+	unsquash-4-be.o
 
 CFLAGS ?= -O2
 CFLAGS += $(EXTRA_CFLAGS) $(INCLUDEDIR) -D_FILE_OFFSET_BITS=64 \
@@ -290,6 +291,9 @@
 unsquash-4.o: unsquashfs.h unsquash-4.c squashfs_fs.h squashfs_swap.h \
 	read_fs.h
 
+unsquash-4-be.o: unsquashfs.h unsquash-4-be.c squashfs_fs.h squashfs_compat.h \
+	squashfs_compat_4_be.h
+
 unsquashfs_xattr.o: unsquashfs_xattr.c unsquashfs.h squashfs_fs.h xattr.h
 
 unsquashfs_info.o: unsquashfs.h squashfs_fs.h
--- squashfs-tools/squashfs_compat_4_be.h
+++ squashfs-tools/squashfs_compat_4_be.h
@@ -0,0 +1,242 @@
+#ifndef SQUASHFS_COMPAT_4_BE
+#define SQUASHFS_COMPAT_4_BE
+/*
+ * Squashfs
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2014
+ * Phillip Lougher <phillip@squashfs.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs_compat_4_be.h
+ *
+ * Copyright (C) 2014
+ * Peter Hämmerlein <opensource@peh-consulting.de>
+ *
+ * look at unsquashfs-4-be.c for additional information
+ *
+ */
+
+/* definitions for squashfs 4 with big endian encoding */
+
+#define SQUASHFS_SWAP_SUPER_BLOCK_4_BE(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_super_block));\
+	SQUASHFS_SWAP((s)->s_magic, d, 0, 32);\
+	SQUASHFS_SWAP((s)->inodes, d, 32, 32);\
+	SQUASHFS_SWAP((s)->mkfs_time, d, 64, 32);\
+	SQUASHFS_SWAP((s)->block_size, d, 96, 32);\
+	SQUASHFS_SWAP((s)->fragments, d, 128, 32);\
+	SQUASHFS_SWAP((s)->compression, d, 160, 16);\
+	SQUASHFS_SWAP((s)->block_log, d, 176, 16);\
+	SQUASHFS_SWAP((s)->flags, d, 192, 16);\
+	SQUASHFS_SWAP((s)->no_ids, d, 208, 16);\
+	SQUASHFS_SWAP((s)->s_major, d, 224, 16);\
+	SQUASHFS_SWAP((s)->s_minor, d, 240, 16);\
+	SQUASHFS_SWAP((s)->root_inode, d, 256, 64);\
+	SQUASHFS_SWAP((s)->bytes_used, d, 320, 64);\
+	SQUASHFS_SWAP((s)->id_table_start, d, 384, 64);\
+	SQUASHFS_SWAP((s)->xattr_id_table_start, d, 448, 64);\
+	SQUASHFS_SWAP((s)->inode_table_start, d, 512, 64);\
+	SQUASHFS_SWAP((s)->directory_table_start, d, 576, 64);\
+	SQUASHFS_SWAP((s)->fragment_table_start, d, 640, 64);\
+	SQUASHFS_SWAP((s)->lookup_table_start, d, 704, 64);\
+}
+
+#define SQUASHFS_SWAP_BASE_INODE_CORE_4_BE(s, d, n)\
+	SQUASHFS_MEMSET(s, d, n);\
+	SQUASHFS_SWAP((s)->inode_type, d, 0, 16);\
+	SQUASHFS_SWAP((s)->mode, d, 16, 16);\
+	SQUASHFS_SWAP((s)->uid, d, 32, 16);\
+	SQUASHFS_SWAP((s)->guid, d, 48, 16);\
+	SQUASHFS_SWAP((s)->mtime, d, 64, 32);\
+	SQUASHFS_SWAP((s)->inode_number, d, 96, 32);
+
+#define SQUASHFS_SWAP_BASE_INODE_HEADER_4_BE(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_4_BE(s, d, \
+			sizeof(struct squashfs_base_inode_header))\
+}
+
+#define SQUASHFS_SWAP_IPC_INODE_HEADER_4_BE(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_4_BE(s, d, \
+			sizeof(struct squashfs_ipc_inode_header))\
+	SQUASHFS_SWAP((s)->nlink, d, 128, 32);\
+}
+
+#define SQUASHFS_SWAP_LIPC_INODE_HEADER_4_BE(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_4_BE(s, d, \
+			sizeof(struct squashfs_lipc_inode_header));\
+	SQUASHFS_SWAP((s)->nlink, d, 128, 32);\
+	SQUASHFS_SWAP((s)->xattr, d, 160, 32);\
+}
+
+#define SQUASHFS_SWAP_DEV_INODE_HEADER_4_BE(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_4_BE(s, d, \
+			sizeof(struct squashfs_dev_inode_header)); \
+	SQUASHFS_SWAP((s)->nlink, d, 128, 32);\
+	SQUASHFS_SWAP((s)->rdev, d, 160, 32);\
+}
+
+#define SQUASHFS_SWAP_LDEV_INODE_HEADER_4_BE(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_4_BE(s, d, \
+			sizeof(struct squashfs_ldev_inode_header)); \
+	SQUASHFS_SWAP((s)->nlink, d, 128, 32);\
+	SQUASHFS_SWAP((s)->rdev, d, 160, 32);\
+	SQUASHFS_SWAP((s)->xattr, d, 192, 32);\
+}
+
+#define SQUASHFS_SWAP_SYMLINK_INODE_HEADER_4_BE(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_4_BE(s, d, \
+			sizeof(struct squashfs_symlink_inode_header));\
+	SQUASHFS_SWAP((s)->nlink, d, 128, 32);\
+	SQUASHFS_SWAP((s)->symlink_size, d, 160, 32);\
+}
+
+#define SQUASHFS_SWAP_REG_INODE_HEADER_4_BE(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_4_BE(s, d, \
+			sizeof(struct squashfs_reg_inode_header));\
+	SQUASHFS_SWAP((s)->start_block, d, 128, 32);\
+	SQUASHFS_SWAP((s)->fragment, d, 160, 32);\
+	SQUASHFS_SWAP((s)->offset, d, 192, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 224, 32);\
+}
+
+#define SQUASHFS_SWAP_LREG_INODE_HEADER_4_BE(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_4_BE(s, d, \
+			sizeof(struct squashfs_lreg_inode_header));\
+	SQUASHFS_SWAP((s)->start_block, d, 128, 64);\
+	SQUASHFS_SWAP((s)->file_size, d, 192, 64);\
+	SQUASHFS_SWAP((s)->sparse, d, 256, 64);\
+	SQUASHFS_SWAP((s)->nlink, d, 320, 32);\
+	SQUASHFS_SWAP((s)->fragment, d, 352, 32);\
+	SQUASHFS_SWAP((s)->offset, d, 384, 32);\
+	SQUASHFS_SWAP((s)->xattr, d, 416, 32);\
+}
+
+#define SQUASHFS_SWAP_DIR_INODE_HEADER_4_BE(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_4_BE(s, d, \
+			sizeof(struct squashfs_dir_inode_header));\
+	SQUASHFS_SWAP((s)->start_block, d, 128, 32);\
+	SQUASHFS_SWAP((s)->nlink, d, 160, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 192, 16);\
+	SQUASHFS_SWAP((s)->offset, d, 208, 16);\
+	SQUASHFS_SWAP((s)->parent_inode, d, 224, 32);\
+}
+
+#define SQUASHFS_SWAP_LDIR_INODE_HEADER_4_BE(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_4_BE(s, d, \
+			sizeof(struct squashfs_ldir_inode_header));\
+	SQUASHFS_SWAP((s)->nlink, d, 128, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 160, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 192, 32);\
+	SQUASHFS_SWAP((s)->parent_inode, d, 224, 32);\
+	SQUASHFS_SWAP((s)->i_count, d, 256, 16);\
+	SQUASHFS_SWAP((s)->offset, d, 272, 16);\
+	SQUASHFS_SWAP((s)->xattr, d, 288, 32);\
+}
+
+#define SQUASHFS_SWAP_DIR_INDEX_4_BE(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_index));\
+	SQUASHFS_SWAP((s)->index, d, 0, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 32, 32);\
+	SQUASHFS_SWAP((s)->size, d, 64, 8);\
+}
+
+#define SQUASHFS_SWAP_DIR_HEADER_4_BE(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_header));\
+	SQUASHFS_SWAP((s)->count, d, 0, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 32, 32);\
+	SQUASHFS_SWAP((s)->inode_number, d, 64, 32);\
+}
+
+#define SQUASHFS_SWAP_DIR_ENTRY_4_BE(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_entry));\
+	SQUASHFS_SWAP((s)->offset, d, 0, 16);\
+	SQUASHFS_SWAP((s)->inode_number, d, 16, 16);\
+	SQUASHFS_SWAP((s)->type, d, 32, 16);\
+	SQUASHFS_SWAP((s)->size, d, 48, 16);\
+}
+
+#define SQUASHFS_SWAP_INODE_T_4_BE(s, d) SQUASHFS_SWAP_LONG_LONGS_4_BE(s, d, 1)
+
+#define SQUASHFS_SWAP_SHORTS_4_BE(s, d, n) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, n * 2);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \
+			16)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, 16);\
+}
+
+#define SQUASHFS_SWAP_INTS_4_BE(s, d, n) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, n * 4);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \
+			32)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, 32);\
+}
+
+#define SQUASHFS_SWAP_LONG_LONGS_4_BE(s, d, n) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, n * 8);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \
+			64)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, 64);\
+}
+
+#define SQUASHFS_SWAP_FRAGMENT_INDEXES_4_BE(s, d, n) SQUASHFS_SWAP_LONG_LONGS_4_BE(s, d, n)
+#define SQUASHFS_SWAP_LOOKUP_BLOCKS_4_BE(s, d, n) SQUASHFS_SWAP_LONG_LONGS_4_BE(s, d, n)
+
+#define SQUASHFS_SWAP_FRAGMENT_ENTRY_4_BE(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_fragment_entry));\
+	SQUASHFS_SWAP((s)->start_block, d, 0, 64);\
+	SQUASHFS_SWAP((s)->size, d, 64, 32);\
+}
+
+#define SQUASHFS_FRAGMENT_BYTES_4_BE(A)	((A) * sizeof(struct squashfs_fragment_entry))
+
+#define SQUASHFS_FRAGMENT_INDEX_4_BE(A)	(SQUASHFS_FRAGMENT_BYTES_4_BE(A) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEX_OFFSET_4_BE(A)	(SQUASHFS_FRAGMENT_BYTES_4_BE(A) % \
+						SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEXES_4_BE(A)	((SQUASHFS_FRAGMENT_BYTES_4_BE(A) + \
+					SQUASHFS_METADATA_SIZE - 1) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEX_BYTES_4_BE(A)	(SQUASHFS_FRAGMENT_INDEXES_4_BE(A) *\
+						sizeof(long long))
+
+#endif
--- squashfs-tools/unsquash-4-be.c
+++ squashfs-tools/unsquash-4-be.c
@@ -0,0 +1,380 @@
+/*
+ * Unsquash a squashfs filesystem.  This is a highly compressed read only
+ * filesystem.
+ *
+ * Copyright (c) 2009, 2010, 2011, 2012, 2013
+ * Phillip Lougher <phillip@squashfs.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * unsquash-4-be.c
+ *
+ * Copyright (C) 2014
+ * Peter Hämmerlein <opensource@peh-consulting.de>
+ *
+ * - unsquashfs code changed for squashfs 4 images with big endian data
+ *   format, which was given up starting with version 4.0 by the original
+ *   code
+ * - that format is introduced and used by AVM
+ *
+ */
+
+#include "unsquashfs.h"
+#include "squashfs_fs.h"
+#include "squashfs_compat.h"
+#include "squashfs_compat_4_be.h"
+
+static struct squashfs_fragment_entry *fragment_table;
+static unsigned int *id_table;
+
+void read_block_list_4_be(unsigned int *block_list, char *block_ptr, int blocks)
+{
+	TRACE("read_block_list: blocks %d\n", blocks);
+
+	memcpy(block_list, block_ptr, blocks * sizeof(unsigned int));
+}
+
+int read_fragment_table_4_be(long long *directory_table_end)
+{
+	int res, i;
+	int bytes = SQUASHFS_FRAGMENT_BYTES_4_BE(sBlk.s.fragments);
+	int indexes = SQUASHFS_FRAGMENT_INDEXES_4_BE(sBlk.s.fragments);
+	long long fragment_table_index[indexes];
+
+	TRACE("read_fragment_table: %d fragments, reading %d fragment indexes "
+		"from 0x%llx\n", sBlk.s.fragments, indexes,
+		sBlk.s.fragment_table_start);
+
+	if(sBlk.s.fragments == 0) {
+		*directory_table_end = sBlk.s.fragment_table_start;
+		return TRUE;
+	}
+
+	fragment_table = malloc(bytes);
+	if(fragment_table == NULL)
+		EXIT_UNSQUASH("read_fragment_table: failed to allocate "
+			"fragment table\n");
+
+	res = read_fs_bytes(fd, sBlk.s.fragment_table_start,
+		SQUASHFS_FRAGMENT_INDEX_BYTES_4_BE(sBlk.s.fragments),
+		fragment_table_index);
+	if(res == FALSE) {
+		ERROR("read_fragment_table: failed to read fragment "
+			"table index\n");
+		return FALSE;
+	}
+
+	for(i = 0; i < indexes; i++) {
+		int expected = (i + 1) != indexes ? SQUASHFS_METADATA_SIZE :
+					bytes & (SQUASHFS_METADATA_SIZE - 1);
+		int length = read_block(fd, fragment_table_index[i], NULL,
+			expected, ((char *) fragment_table) + (i *
+			SQUASHFS_METADATA_SIZE));
+		TRACE("Read fragment table block %d, from 0x%llx, length %d\n",
+			i, fragment_table_index[i], length);
+		if(length == FALSE) {
+			ERROR("read_fragment_table: failed to read fragment "
+				"table block\n");
+			return FALSE;
+		}
+	}
+
+	*directory_table_end = fragment_table_index[0];
+	return TRUE;
+}
+
+void read_fragment_4_be(unsigned int fragment, long long *start_block, int *size)
+{
+	TRACE("read_fragment: reading fragment %d\n", fragment);
+
+	struct squashfs_fragment_entry *fragment_entry = &fragment_table[fragment];
+	*start_block = fragment_entry->start_block;
+	*size = fragment_entry->size;
+}
+
+struct inode *read_inode_4_be(unsigned int start_block, unsigned int offset)
+{
+	static union squashfs_inode_header header;
+	long long start = sBlk.s.inode_table_start + start_block;
+	int bytes = lookup_entry(inode_table_hash, start);
+	char *block_ptr = inode_table + bytes + offset;
+	static struct inode i;
+	memcpy(&header, block_ptr, sizeof(header));
+
+	TRACE("read_inode: reading inode [%d:%d]\n", start_block,  offset);
+
+	if(bytes == -1)
+		EXIT_UNSQUASH("read_inode: inode table block %lld not found\n",
+			start);
+
+	i.uid = (uid_t) id_table[header.base.uid];
+	i.gid = (uid_t) id_table[header.base.guid];
+	i.mode = lookup_type[header.base.inode_type] | header.base.mode;
+	i.type = header.base.inode_type;
+	i.time = header.base.mtime;
+	i.inode_number = header.base.inode_number;
+	memcpy(&header, block_ptr, sizeof(header));
+
+	TRACE("Inode - uid=%hu, gid=%hu, mode=%hu, type=%hu, inode_number=%u, mtime=%u\n", i.uid, i.gid, i.mode, i.type, i.inode_number, i.time);
+
+	switch(i.type) {
+		case SQUASHFS_DIR_TYPE: {
+			struct squashfs_dir_inode_header *inode = &header.dir;
+
+			i.data = inode->file_size;
+			i.offset = inode->offset;
+			i.start = inode->start_block;
+			i.xattr = SQUASHFS_INVALID_XATTR;
+			break;
+		}
+		case SQUASHFS_LDIR_TYPE: {
+			struct squashfs_ldir_inode_header *inode = &header.ldir;
+
+			i.data = inode->file_size;
+			i.offset = inode->offset;
+			i.start = inode->start_block;
+			i.xattr = inode->xattr;
+			break;
+		}
+		case SQUASHFS_FILE_TYPE: {
+			struct squashfs_reg_inode_header *inode = &header.reg;
+
+			i.data = inode->file_size;
+			i.frag_bytes = inode->fragment == SQUASHFS_INVALID_FRAG
+				?  0 : inode->file_size % sBlk.s.block_size;
+			i.fragment = inode->fragment;
+			i.offset = inode->offset;
+			i.blocks = inode->fragment == SQUASHFS_INVALID_FRAG ?
+				(i.data + sBlk.s.block_size - 1) >>
+				sBlk.s.block_log :
+				i.data >> sBlk.s.block_log;
+			i.start = inode->start_block;
+			i.sparse = 0;
+			i.block_ptr = block_ptr + sizeof(*inode);
+			i.xattr = SQUASHFS_INVALID_XATTR;
+			break;
+		}	
+		case SQUASHFS_LREG_TYPE: {
+			struct squashfs_lreg_inode_header *inode = &header.lreg;
+
+			i.data = inode->file_size;
+			i.frag_bytes = inode->fragment == SQUASHFS_INVALID_FRAG
+				?  0 : inode->file_size % sBlk.s.block_size;
+			i.fragment = inode->fragment;
+			i.offset = inode->offset;
+			i.blocks = inode->fragment == SQUASHFS_INVALID_FRAG ?
+				(inode->file_size + sBlk.s.block_size - 1) >>
+				sBlk.s.block_log :
+				inode->file_size >> sBlk.s.block_log;
+			i.start = inode->start_block;
+			i.sparse = inode->sparse != 0;
+			i.block_ptr = block_ptr + sizeof(*inode);
+			i.xattr = inode->xattr;
+			break;
+		}	
+		case SQUASHFS_SYMLINK_TYPE:
+		case SQUASHFS_LSYMLINK_TYPE: {
+			struct squashfs_symlink_inode_header *inode = &header.symlink;
+
+			i.symlink = malloc(inode->symlink_size + 1);
+			if(i.symlink == NULL)
+				EXIT_UNSQUASH("read_inode: failed to malloc "
+					"symlink data\n");
+			strncpy(i.symlink, block_ptr +
+				sizeof(struct squashfs_symlink_inode_header),
+				inode->symlink_size);
+			i.symlink[inode->symlink_size] = '\0';
+			TRACE("linked_to = %s\n", i.symlink);
+			i.data = inode->symlink_size;
+
+			/* SQUASHFS_LSYMLINK_TYPE xattr handling is missing here */
+			i.xattr = SQUASHFS_INVALID_XATTR;
+			break;
+		}
+		case SQUASHFS_BLKDEV_TYPE:
+		case SQUASHFS_CHRDEV_TYPE: {
+			struct squashfs_dev_inode_header *inode = &header.dev;
+
+			i.data = inode->rdev;
+			i.xattr = SQUASHFS_INVALID_XATTR;
+			break;
+		}
+		case SQUASHFS_LBLKDEV_TYPE:
+		case SQUASHFS_LCHRDEV_TYPE: {
+			struct squashfs_ldev_inode_header *inode = &header.ldev;
+
+			i.data = inode->rdev;
+			i.xattr = inode->xattr;
+			break;
+		}
+		case SQUASHFS_FIFO_TYPE:
+		case SQUASHFS_SOCKET_TYPE:
+			i.data = 0;
+			i.xattr = SQUASHFS_INVALID_XATTR;
+			break;
+		case SQUASHFS_LFIFO_TYPE:
+		case SQUASHFS_LSOCKET_TYPE: {
+			struct squashfs_lipc_inode_header *inode = &header.lipc;
+
+			i.data = 0;
+			i.xattr = inode->xattr;
+			break;
+		}
+		default:
+			EXIT_UNSQUASH("Unknown inode type %d in read_inode!\n",
+				header.base.inode_type);
+	}
+	return &i;
+}
+
+struct dir *squashfs_opendir_4_be(unsigned int block_start, unsigned int offset,
+	struct inode **i)
+{
+	struct squashfs_dir_header dirh;
+	char buffer[sizeof(struct squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1]
+		__attribute__((aligned));
+	struct squashfs_dir_entry *dire = (struct squashfs_dir_entry *) buffer;
+	long long start;
+	int bytes;
+	int dir_count, size;
+	struct dir_ent *new_dir;
+	struct dir *dir;
+
+	TRACE("squashfs_opendir: inode start block 0x%x, offset 0x%x\n",
+		block_start, offset);
+
+	*i = s_ops.read_inode(block_start, offset);
+
+	dir = malloc(sizeof(struct dir));
+	if(dir == NULL)
+		EXIT_UNSQUASH("squashfs_opendir: malloc failed!\n");
+
+	dir->dir_count = 0;
+	dir->cur_entry = 0;
+	dir->mode = (*i)->mode;
+	dir->uid = (*i)->uid;
+	dir->guid = (*i)->gid;
+	dir->mtime = (*i)->time;
+	dir->xattr = (*i)->xattr;
+	dir->dirs = NULL;
+
+	if ((*i)->data == 3)
+		/*
+		 * if the directory is empty, skip the unnecessary
+		 * lookup_entry, this fixes the corner case with
+		 * completely empty filesystems where lookup_entry correctly
+		 * returning -1 is incorrectly treated as an error
+		 */
+		return dir;
+
+	start = sBlk.s.directory_table_start + (*i)->start;
+	bytes = lookup_entry(directory_table_hash, start);
+
+	if(bytes == -1)
+		EXIT_UNSQUASH("squashfs_opendir: directory block %d not "
+			"found!\n", block_start);
+
+	bytes += (*i)->offset;
+	size = (*i)->data + bytes - 3;
+
+	while(bytes < size) {
+		memcpy(&dirh, directory_table + bytes, sizeof(dirh));
+	
+		dir_count = dirh.count + 1;
+		TRACE("squashfs_opendir: Read directory header @ byte position "
+			"%d, %d directory entries\n", bytes, dir_count);
+		bytes += sizeof(dirh);
+
+		/* dir_count should never be larger than 256 */
+		if(dir_count > 256)
+			goto corrupted;
+
+		while(dir_count--) {
+			memcpy(dire, directory_table + bytes, sizeof(*dire));
+			bytes += sizeof(*dire);
+
+			/* size should never be larger than SQUASHFS_NAME_LEN */
+			if(dire->size > SQUASHFS_NAME_LEN)
+				goto corrupted;
+
+			memcpy(dire->name, directory_table + bytes,
+				dire->size + 1);
+			dire->name[dire->size + 1] = '\0';
+			TRACE("squashfs_opendir: directory entry %s, inode "
+				"%d:%d, type %d\n", dire->name,
+				dirh.start_block, dire->offset, dire->type);
+			if((dir->dir_count % DIR_ENT_SIZE) == 0) {
+				new_dir = realloc(dir->dirs, (dir->dir_count +
+					DIR_ENT_SIZE) * sizeof(struct dir_ent));
+				if(new_dir == NULL)
+					EXIT_UNSQUASH("squashfs_opendir: "
+						"realloc failed!\n");
+				dir->dirs = new_dir;
+			}
+			strcpy(dir->dirs[dir->dir_count].name, dire->name);
+			dir->dirs[dir->dir_count].start_block =
+				dirh.start_block;
+			dir->dirs[dir->dir_count].offset = dire->offset;
+			dir->dirs[dir->dir_count].type = dire->type;
+			dir->dir_count ++;
+			bytes += dire->size + 1;
+		}
+	}
+
+	return dir;
+
+corrupted:
+	free(dir->dirs);
+	free(dir);
+	return NULL;
+}
+
+int read_uids_guids_4_be()
+{
+	int res, i;
+	int bytes = SQUASHFS_ID_BYTES(sBlk.s.no_ids);
+	int indexes = SQUASHFS_ID_BLOCKS(sBlk.s.no_ids);
+	long long id_index_table[indexes];
+
+	TRACE("read_uids_guids: no. of ids = %d\n", sBlk.s.no_ids);
+
+	id_table = malloc(bytes);
+	if(id_table == NULL) {
+		ERROR("read_uids_guids: failed to allocate id table\n");
+		return FALSE;
+	}
+
+	res = read_fs_bytes(fd, sBlk.s.id_table_start,
+		SQUASHFS_ID_BLOCK_BYTES(sBlk.s.no_ids), id_index_table);
+	if(res == FALSE) {
+		ERROR("read_uids_guids: failed to read id index table\n");
+		return FALSE;
+	}
+
+	TRACE("indexes = %u\n", indexes);
+	for(i = 0; i < indexes; i++) {
+		int expected = ( ((i + 1) != indexes) ? SQUASHFS_METADATA_SIZE :
+					bytes & (SQUASHFS_METADATA_SIZE - 1) );
+		res = read_block(fd, id_index_table[i], NULL, expected,
+			((char *) id_table) + i * SQUASHFS_METADATA_SIZE);
+		if(res == FALSE) {
+			ERROR("read_uids_guids: failed to read id table block"
+				"\n");
+			return FALSE;
+		}
+	}
+
+	return TRUE;
+}
--- squashfs-tools/unsquashfs.c
+++ squashfs-tools/unsquashfs.c
@@ -26,6 +26,7 @@
 #include "unsquashfs.h"
 #include "squashfs_swap.h"
 #include "squashfs_compat.h"
+#include "squashfs_compat_4_be.h"
 #include "compressor.h"
 #include "xattr.h"
 #include "unsquashfs_info.h"
@@ -663,29 +664,18 @@
 	int offset = 2, res, compressed;
 	int outlen = expected ? expected : SQUASHFS_METADATA_SIZE;
 	
-	if(swap) {
-		if(read_fs_bytes(fd, start, 2, &c_byte) == FALSE)
-			goto failed;
-		c_byte = (c_byte >> 8) | ((c_byte & 0xff) << 8);
-	} else 
-		if(read_fs_bytes(fd, start, 2, &c_byte) == FALSE)
-			goto failed;
-
-	TRACE("read_block: block @0x%llx, %d %s bytes\n", start,
-		SQUASHFS_COMPRESSED_SIZE(c_byte), SQUASHFS_COMPRESSED(c_byte) ?
-		"compressed" : "uncompressed");
+	if(read_fs_bytes(fd, start, 2, &c_byte) == FALSE)
+		goto failed;
+	c_byte = (c_byte >> 8) | ((c_byte & 0xff) << 8);
 
 	if(SQUASHFS_CHECK_DATA(sBlk.s.flags))
 		offset = 3;
-
 	compressed = SQUASHFS_COMPRESSED(c_byte);
 	c_byte = SQUASHFS_COMPRESSED_SIZE(c_byte);
 
-	/*
-	 * The block size should not be larger than
-	 * the uncompressed size (or max uncompressed size if
-	 * expected is 0)
-	 */
+	TRACE("read_block: block @0x%llx (+ offset %u), %d %s bytes, max = %u, expected = %u\n", start, offset,
+		c_byte, compressed ? "compressed" : "uncompressed", outlen, expected);
+
 	if(c_byte > outlen)
 		return 0;
 
@@ -1628,15 +1618,8 @@
 	time_t mkfs_time = (time_t) sBlk.s.mkfs_time;
 	char *mkfs_str = ctime(&mkfs_time);
 
-#if __BYTE_ORDER == __BIG_ENDIAN
-	printf("Found a valid %sSQUASHFS %d:%d superblock on %s.\n",
-		sBlk.s.s_major == 4 ? "" : swap ? "little endian " :
-		"big endian ", sBlk.s.s_major, sBlk.s.s_minor, source);
-#else
-	printf("Found a valid %sSQUASHFS %d:%d superblock on %s.\n",
-		sBlk.s.s_major == 4 ? "" : swap ? "big endian " :
-		"little endian ", sBlk.s.s_major, sBlk.s.s_minor, source);
-#endif
+	printf("Found a valid big endian SQUASHFS %d:%d superblock on %s.\n",
+		sBlk.s.s_major, sBlk.s.s_minor, source);
 
 	printf("Creation or last append time %s", mkfs_str ? mkfs_str :
 		"failed to get time\n");
@@ -1775,128 +1758,23 @@
 
 int read_super(char *source)
 {
-	squashfs_super_block_3 sBlk_3;
 	struct squashfs_super_block sBlk_4;
 
-	/*
-	 * Try to read a Squashfs 4 superblock
-	 */
 	read_fs_bytes(fd, SQUASHFS_START, sizeof(struct squashfs_super_block),
 		&sBlk_4);
-	swap = sBlk_4.s_magic != SQUASHFS_MAGIC;
-	SQUASHFS_INSWAP_SUPER_BLOCK(&sBlk_4);
-
-	if(sBlk_4.s_magic == SQUASHFS_MAGIC && sBlk_4.s_major == 4 &&
-			sBlk_4.s_minor == 0) {
-		s_ops.squashfs_opendir = squashfs_opendir_4;
-		s_ops.read_fragment = read_fragment_4;
-		s_ops.read_fragment_table = read_fragment_table_4;
-		s_ops.read_block_list = read_block_list_2;
-		s_ops.read_inode = read_inode_4;
-		s_ops.read_uids_guids = read_uids_guids_4;
+	if(sBlk_4.s_magic == SQUASHFS_MAGIC && sBlk_4.s_major == 4 && sBlk_4.s_minor == 0) {
+		s_ops.squashfs_opendir = squashfs_opendir_4_be;
+		s_ops.read_fragment = read_fragment_4_be;
+		s_ops.read_fragment_table = read_fragment_table_4_be;
+		s_ops.read_block_list = read_block_list_4_be;
+		s_ops.read_inode = read_inode_4_be;
+		s_ops.read_uids_guids = read_uids_guids_4_be;
 		memcpy(&sBlk, &sBlk_4, sizeof(sBlk_4));
-
-		/*
-		 * Check the compression type
-		 */
 		comp = lookup_compressor_id(sBlk.s.compression);
 		return TRUE;
 	}
 
-	/*
- 	 * Not a Squashfs 4 superblock, try to read a squashfs 3 superblock
- 	 * (compatible with 1 and 2 filesystems)
- 	 */
-	read_fs_bytes(fd, SQUASHFS_START, sizeof(squashfs_super_block_3),
-		&sBlk_3);
-
-	/*
-	 * Check it is a SQUASHFS superblock
-	 */
-	swap = 0;
-	if(sBlk_3.s_magic != SQUASHFS_MAGIC) {
-		if(sBlk_3.s_magic == SQUASHFS_MAGIC_SWAP) {
-			squashfs_super_block_3 sblk;
-			ERROR("Reading a different endian SQUASHFS filesystem "
-				"on %s\n", source);
-			SQUASHFS_SWAP_SUPER_BLOCK_3(&sblk, &sBlk_3);
-			memcpy(&sBlk_3, &sblk, sizeof(squashfs_super_block_3));
-			swap = 1;
-		} else  {
-			ERROR("Can't find a SQUASHFS superblock on %s\n",
-				source);
-			goto failed_mount;
-		}
-	}
-
-	sBlk.s.s_magic = sBlk_3.s_magic;
-	sBlk.s.inodes = sBlk_3.inodes;
-	sBlk.s.mkfs_time = sBlk_3.mkfs_time;
-	sBlk.s.block_size = sBlk_3.block_size;
-	sBlk.s.fragments = sBlk_3.fragments;
-	sBlk.s.block_log = sBlk_3.block_log;
-	sBlk.s.flags = sBlk_3.flags;
-	sBlk.s.s_major = sBlk_3.s_major;
-	sBlk.s.s_minor = sBlk_3.s_minor;
-	sBlk.s.root_inode = sBlk_3.root_inode;
-	sBlk.s.bytes_used = sBlk_3.bytes_used;
-	sBlk.s.inode_table_start = sBlk_3.inode_table_start;
-	sBlk.s.directory_table_start = sBlk_3.directory_table_start;
-	sBlk.s.fragment_table_start = sBlk_3.fragment_table_start;
-	sBlk.s.lookup_table_start = sBlk_3.lookup_table_start;
-	sBlk.no_uids = sBlk_3.no_uids;
-	sBlk.no_guids = sBlk_3.no_guids;
-	sBlk.uid_start = sBlk_3.uid_start;
-	sBlk.guid_start = sBlk_3.guid_start;
-	sBlk.s.xattr_id_table_start = SQUASHFS_INVALID_BLK;
-
-	/* Check the MAJOR & MINOR versions */
-	if(sBlk.s.s_major == 1 || sBlk.s.s_major == 2) {
-		sBlk.s.bytes_used = sBlk_3.bytes_used_2;
-		sBlk.uid_start = sBlk_3.uid_start_2;
-		sBlk.guid_start = sBlk_3.guid_start_2;
-		sBlk.s.inode_table_start = sBlk_3.inode_table_start_2;
-		sBlk.s.directory_table_start = sBlk_3.directory_table_start_2;
-		
-		if(sBlk.s.s_major == 1) {
-			sBlk.s.block_size = sBlk_3.block_size_1;
-			sBlk.s.fragment_table_start = sBlk.uid_start;
-			s_ops.squashfs_opendir = squashfs_opendir_1;
-			s_ops.read_fragment_table = read_fragment_table_1;
-			s_ops.read_block_list = read_block_list_1;
-			s_ops.read_inode = read_inode_1;
-			s_ops.read_uids_guids = read_uids_guids_1;
-		} else {
-			sBlk.s.fragment_table_start =
-				sBlk_3.fragment_table_start_2;
-			s_ops.squashfs_opendir = squashfs_opendir_1;
-			s_ops.read_fragment = read_fragment_2;
-			s_ops.read_fragment_table = read_fragment_table_2;
-			s_ops.read_block_list = read_block_list_2;
-			s_ops.read_inode = read_inode_2;
-			s_ops.read_uids_guids = read_uids_guids_1;
-		}
-	} else if(sBlk.s.s_major == 3) {
-		s_ops.squashfs_opendir = squashfs_opendir_3;
-		s_ops.read_fragment = read_fragment_3;
-		s_ops.read_fragment_table = read_fragment_table_3;
-		s_ops.read_block_list = read_block_list_2;
-		s_ops.read_inode = read_inode_3;
-		s_ops.read_uids_guids = read_uids_guids_1;
-	} else {
-		ERROR("Filesystem on %s is (%d:%d), ", source, sBlk.s.s_major,
-			sBlk.s.s_minor);
-		ERROR("which is a later filesystem version than I support!\n");
-		goto failed_mount;
-	}
-
-	/*
-	 * 1.x, 2.x and 3.x filesystems use gzip compression.
-	 */
-	comp = lookup_compressor("gzip");
-	return TRUE;
-
-failed_mount:
+	ERROR("Unknown or unsupported SquashFS format on %s\n", source);
 	return FALSE;
 }
 
--- squashfs-tools/unsquashfs.h
+++ squashfs-tools/unsquashfs.h
@@ -247,32 +247,12 @@
 extern void dump_queue(struct queue *);
 extern void dump_cache(struct cache *);
 
-/* unsquash-1.c */
-extern void read_block_list_1(unsigned int *, char *, int);
-extern int read_fragment_table_1(long long *);
-extern struct inode *read_inode_1(unsigned int, unsigned int);
-extern struct dir *squashfs_opendir_1(unsigned int, unsigned int,
+/* unsquash-4-be.c */
+extern void read_block_list_4_be(unsigned int *, char *, int);
+extern int read_fragment_table_4_be(long long *);
+extern void read_fragment_4_be(unsigned int, long long *, int *);
+extern struct inode *read_inode_4_be(unsigned int, unsigned int);
+extern struct dir *squashfs_opendir_4_be(unsigned int, unsigned int,
 	struct inode **);
-extern int read_uids_guids_1();
-
-/* unsquash-2.c */
-extern void read_block_list_2(unsigned int *, char *, int);
-extern int read_fragment_table_2(long long *);
-extern void read_fragment_2(unsigned int, long long *, int *);
-extern struct inode *read_inode_2(unsigned int, unsigned int);
-
-/* unsquash-3.c */
-extern int read_fragment_table_3(long long *);
-extern void read_fragment_3(unsigned int, long long *, int *);
-extern struct inode *read_inode_3(unsigned int, unsigned int);
-extern struct dir *squashfs_opendir_3(unsigned int, unsigned int,
-	struct inode **);
-
-/* unsquash-4.c */
-extern int read_fragment_table_4(long long *);
-extern void read_fragment_4(unsigned int, long long *, int *);
-extern struct inode *read_inode_4(unsigned int, unsigned int);
-extern struct dir *squashfs_opendir_4(unsigned int, unsigned int,
-	struct inode **);
-extern int read_uids_guids_4();
+extern int read_uids_guids_4_be();
 #endif
