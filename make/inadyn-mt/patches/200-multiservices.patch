diff -ur inadyn-mt.v.02.24.38/readme.html inadyn-mt.v.02.24.38-ms-pid-04/readme.html
--- readme.html
+++ readme.html
@@ -6,7 +6,7 @@
 <body>
 <p><b>inadyn-mt - Simple DYNAMIC DNS client.<br>
 </b></p>
-<p><b>Version 02.24.38, January 2013<br>
+<p><b>Version 02.24.38-ms_pid_04_patch, June 2013<br>
 </b></p>
 <p><b>INADYN Advanced Help<br>
 </b></p>
@@ -299,6 +299,9 @@
 information.<br>
 </p>
 
+<p style="margin-left: 20px;">'--ip_server_name_global &#60;name&#62;[:port] &#60;url&#62;': The client
+IP is detected by calling 'url' from this 'ip_server_name:port'.  Same as ip_server_name option, but 
+overrides unchanged dyndns_system default ip servers.<br>
 </p>
 <p style="margin-left: 20px;">'--dyndns_server_name &#60;name&#62;[:port]': dynamic dns server name, and optional port.</name>
 </p>
@@ -324,7 +327,11 @@
 -For majimoto.net:  default@majimoto.net<br>
 -For zerigo.com:  default@zerigo.com<br>
 -For generic DNS system: custom@http_svr_basic_auth<br>
-DEFAULT value is intended for default service at dyndns.org: dyndns@dyndns.org<br>
+DEFAULT value is intended for default service at dyndns.org: dyndns@dyndns.org<br><br>
+
+Multiple servers are allowed.  Server related parameters are applied to the most recent dyndns_system option parameter appearing
+on the command line (a given system may appear more than once).  Per server option parameters include credentials; ip server, url, port; dyn dns server, url, port;  
+host alias names.<br>
 </p>
 
 <p style="margin-left: 20px;">
@@ -333,6 +340,7 @@
 '--update_period_sec &#60;#&#62;': how often the IP is checked. The period is in [sec]. 30..864000.  Default is about 10 min. Max is 10 days<br>
 '--forced_update_period &#60;#&#62;': how often, in seconds, the IP is updated even if it is not changed. 30 sec..30 days, default, 30 days.<br>
 '--log_file &#60;path/file&#62;': log file path and name<br>
+'--pid_file &#60;path/file&#62;': pid file path and name<br>
 '--background': runs in background.&nbsp; Output to syslog or to log file [if specified].<br>
 '--verbose &#60;#&#62;': set dbg level. 0 to 5<br>
 '--iterations &#60;#&#62;': set the number of DNS updates. Default is 0, which means infinity.<br>
@@ -481,6 +489,29 @@
 <b>HISTORY<br>
 <br>
 </b>
+
+Ver.&nbsp; inadyn-mt 2.24.38-ms_pid_patch_04 - June 2013<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; Changes:<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - Windows version patch type-o fixed<br><br>
+
+Ver.&nbsp; inadyn-mt 2.24.38-ms_pid_patch_03 - May 2013<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; Changes:<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - dns server port allocation error fixed<br><br>
+
+Ver.&nbsp; inadyn-mt 2.24.38-ms_pid_patch_02 - April 2013<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; Changes:<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - architectural/flow control problems fixed<br><br>
+
+Ver.&nbsp; inadyn-mt 2.24.38-ms_pid_patch_01 - February 2013<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; Changes:<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - Windows version shell execute bug fixed<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - pid file related variable inits<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - unicode pid file name and path<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - pid file related snprintf return check<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - multiple update servers, single program instance<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - added defaults override option, ip_server_name_global<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - added pid file name and path option, pid_file<br><br>
+
 Ver.&nbsp; inadyn-mt 2.24.38 - January 2013<br>
 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; Changes:<br>
 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - fatal configuration selector fault fixed<br><br>
Only in inadyn-mt.v.02.24.38-ms-pid-04: readme.html~
diff -ur inadyn-mt.v.02.24.38/src/config.h inadyn-mt.v.02.24.38-ms-pid-04/src/config.h
--- src/config.h
+++ src/config.h
@@ -1,11 +1,8 @@
 /* src/config.h.  Generated from config.h.in by configure.  */
 /* src/config.h.in.  Generated from configure.ac by autoheader.  */
 
-/* Asynchronous lookups without gethostbyname_r */
-/* #undef ASYNC_LOOKUP */
-
 /* More debug log output */
-/* #undef DEBUG */
+#define DEBUG /**/
 
 /* Define to 1 if you have the <ao/ao.h> header file. */
 #define HAVE_AO_AO_H 1
@@ -19,27 +16,6 @@
 /* Define to 1 if you have the `fork' function. */
 #define HAVE_FORK 1
 
-/* gethostbyname_r takes three parameters */
-/* #undef HAVE_FUNC_GETHOSTBYNAME_R_3 */
-
-/* gethostbyname_r takes five parameters */
-/* #undef HAVE_FUNC_GETHOSTBYNAME_R_5 */
-
-/* gethostbyname_r takes six parameters */
-#define HAVE_FUNC_GETHOSTBYNAME_R_6 /**/
-
-/* no gethostbyname_r, use non-reentrant gethostbyname */
-/* #undef HAVE_FUNC_GETHOSTBYNAME_R_NOT */
-
-/* Define to 1 if you have the `getcwd' function. */
-#define HAVE_GETCWD 1
-
-/* Define to 1 if you have the `gethostbyname' function. */
-#define HAVE_GETHOSTBYNAME 1
-
-/* Define to 1 if you have the `gettimeofday' function. */
-#define HAVE_GETTIMEOFDAY 1
-
 /* Define to 1 if you have the <inttypes.h> header file. */
 #define HAVE_INTTYPES_H 1
 
@@ -53,9 +29,6 @@
 /* Define to 1 if you have the <memory.h> header file. */
 #define HAVE_MEMORY_H 1
 
-/* Define to 1 if you have the `memset' function. */
-#define HAVE_MEMSET 1
-
 /* Define to 1 if you have the <netdb.h> header file. */
 #define HAVE_NETDB_H 1
 
@@ -66,12 +39,6 @@
    and to 0 otherwise. */
 #define HAVE_REALLOC 1
 
-/* Define to 1 if you have the `setlocale' function. */
-#define HAVE_SETLOCALE 1
-
-/* Define to 1 if you have the `socket' function. */
-#define HAVE_SOCKET 1
-
 /* Define to 1 if stdbool.h conforms to C99. */
 #define HAVE_STDBOOL_H 1
 
@@ -81,24 +48,12 @@
 /* Define to 1 if you have the <stdlib.h> header file. */
 #define HAVE_STDLIB_H 1
 
-/* Define to 1 if you have the `strchr' function. */
-#define HAVE_STRCHR 1
-
 /* Define to 1 if you have the <strings.h> header file. */
 #define HAVE_STRINGS_H 1
 
 /* Define to 1 if you have the <string.h> header file. */
 #define HAVE_STRING_H 1
 
-/* Define to 1 if you have the `strpbrk' function. */
-#define HAVE_STRPBRK 1
-
-/* Define to 1 if you have the `strrchr' function. */
-#define HAVE_STRRCHR 1
-
-/* Define to 1 if you have the `strstr' function. */
-#define HAVE_STRSTR 1
-
 /* Define to 1 if you have the <syslog.h> header file. */
 #define HAVE_SYSLOG_H 1
 
@@ -138,9 +93,6 @@
 /* Define to 1 if `vfork' works. */
 #define HAVE_WORKING_VFORK 1
 
-/* Define to 1 if you have the <\> header file. */
-/* #undef HAVE__ */
-
 /* Define to 1 if the system has the type `_Bool'. */
 #define HAVE__BOOL 1
 
@@ -160,7 +112,7 @@
 #define PACKAGE_NAME "inadyn-mt"
 
 /* Define to the full name and version of this package. */
-#define PACKAGE_STRING "inadyn-mt 02.20.20"
+#define PACKAGE_STRING "inadyn-mt 02.24.38"
 
 /* Define to the one symbol short name of this package. */
 #define PACKAGE_TARNAME "inadyn-mt"
@@ -169,7 +121,7 @@
 #define PACKAGE_URL ""
 
 /* Define to the version of this package. */
-#define PACKAGE_VERSION "02.20.20"
+#define PACKAGE_VERSION "02.24.38"
 
 /* Define to 1 if you have the ANSI C header files. */
 #define STDC_HEADERS 1
@@ -181,7 +133,7 @@
 #define USE_THREADS /**/
 
 /* Version number of package */
-#define VERSION "02.20.20"
+#define VERSION "02.24.38"
 
 /* Define to rpl_malloc if the replacement function should be used. */
 /* #undef malloc */
diff -ur inadyn-mt.v.02.24.38/src/dyndns.c inadyn-mt.v.02.24.38-ms-pid-04/src/dyndns.c
--- src/dyndns.c
+++ src/dyndns.c
@@ -143,7 +143,9 @@
 static volatile	BOOL		global_is_online=true;
 static volatile BOOL		is_online_thread_exit=false;
 static volatile BOOL		is_alert_thread_exit=false;
-static volatile BOOL		is_update_pending=false;
+static volatile BOOL		is_global_update_pending=false;
+static volatile BOOL		is_global_in_proc_update_pending=false;
+static volatile BOOL		is_global_success_updates=false;
 
 #ifdef USE_THREADS
 
@@ -185,7 +187,7 @@
 int is_exit_requested_void(void *p_self);
 int do_is_dyndns_online(DYN_DNS_CLIENT *p_self);
 static int increment_iterations(DYN_DNS_CLIENT *p_dyndns);
-static RC_TYPE do_handle_bad_config(DYN_DNS_CLIENT *p_self,int i);
+static RC_TYPE do_handle_bad_config(DYN_DNS_CLIENT *p_self,int i,char srv_cnt);
 
 #ifdef USE_SNDFILE
 #ifdef USE_THREADS
@@ -215,29 +217,29 @@
 DYNDNS_ORG_SPECIFIC_DATA dyndns_org_custom = {"custom"};
 DYNDNS_ORG_SPECIFIC_DATA dyndns_org_static = {"statdns"};
 
-static int get_req_for_dyndns_server(DYN_DNS_CLIENT *this, int nr, DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_freedns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_generic_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_noip_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_easydns_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_sitelutions_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_tzo_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_he_ipv6_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_dhis_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_majimoto_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_zerigo_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info);
-
-static BOOL is_dyndns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_freedns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_generic_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_zoneedit_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_easydns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_sitelutions_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_tzo_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_he_ipv6_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_dhis_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_majimoto_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_zerigo_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
+static int get_req_for_dyndns_server(DYN_DNS_CLIENT *this,char srv_cnt, int nr, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_freedns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_generic_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_noip_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_easydns_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_sitelutions_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_tzo_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_he_ipv6_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_dhis_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_majimoto_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_zerigo_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info);
+
+static BOOL is_dyndns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_freedns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_generic_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_zoneedit_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_easydns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_sitelutions_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_tzo_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_he_ipv6_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_dhis_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_majimoto_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_zerigo_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
 
 static BOOL is_dyndns_server_rsp_config(DYN_DNS_CLIENT *p_self, char*p_rsp);
 static BOOL is_freedns_server_rsp_config(DYN_DNS_CLIENT *p_self, char*p_rsp);
@@ -474,7 +476,7 @@
 	DYN_DNS_CMD	old_cmd;
 
 
-	init_cmd_timer(&counter,&counter_init,&cmd_check_period_ms,&old_cmd,is_update_pending,p_self);
+	init_cmd_timer(&counter,&counter_init,&cmd_check_period_ms,&old_cmd,is_global_update_pending,p_self);
 
 	if (old_cmd != NO_CMD)
 	{
@@ -514,7 +516,7 @@
 
 		if (!(p_self->forced_update_counter)) {
 
-			if (!(is_update_pending && !(p_self->retry_pending_off))) {
+			if (!(is_global_update_pending && !(p_self->retry_pending_off))) {
 
 				/*
 					If not retrying pendings, forced update retries fallback to update_period.
@@ -528,9 +530,9 @@
 					turned off.
 				*/
 
-				if (!(is_update_pending) || !(p_self->is_forced_update_attempted)) {
+				if (!(is_global_update_pending) || !(p_self->is_forced_update_attempted)) {
 
-					if (!(p_self->is_bad_config)) {
+					if (!(p_self->is_global_bad_config)) {
 
 						DBG_PRINTF((LOG_INFO,"I:DYNDNS: Command loop breaking for forced update...\n"));
 
@@ -568,7 +570,7 @@
 	return RC_OK;
 }
 
-static int get_req_for_dyndns_server(DYN_DNS_CLIENT *p_self, int cnt,DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_dyndns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,DYNDNS_SYSTEM *p_sys_info)
 {
 
 	int bytes_stored=0;
@@ -581,64 +583,64 @@
 
 
 	bytes_stored=sprintf(p_self->p_req_buffer, DYNDNS_GET_MY_IP_HTTP_REQUEST_FORMAT,
-	                     p_self->info.dyndns_server_url,
+	                     p_self->info[srv_cnt].dyndns_server_name.url,
 	                     p_dyndns_specific->p_system,
-	                     p_self->alias_info.names[cnt].name,
-	                     p_self->info.my_ip_address.name[ip_store],
+	                     p_self->info[srv_cnt].alias_info.names[cnt].name,
+	                     p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
 	                     p_self->wildcard ? "ON" : "OFF",
-	                     p_self->alias_info.names[cnt].name,
-	                     p_self->info.dyndns_server_name.name[ip_store],
-	                     p_self->info.credentials.p_enc_usr_passwd_buffer);
+	                     p_self->info[srv_cnt].alias_info.names[cnt].name,
+	                     p_self->info[srv_cnt].dyndns_server_name.name,
+	                     p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer);
 
 
 	return bytes_stored;
 }
 
-static int get_req_for_freedns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_freedns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, FREEDNS_UPDATE_MY_IP_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-	               p_self->alias_info.hashes[cnt].str,
-				   p_self->info.my_ip_address.name[ip_store],
-	               p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+	               p_self->info[srv_cnt].alias_info.hashes[cnt].str,
+				   p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+	               p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
 
-static int get_req_for_generic_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_generic_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, GENERIC_DNS_BASIC_AUTH_MY_IP_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-	               p_self->alias_info.names[cnt].name,
-	               p_self->info.credentials.p_enc_usr_passwd_buffer,
-	               p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+	               p_self->info[srv_cnt].alias_info.names[cnt].name,
+	               p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,
+	               p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_noip_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_noip_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, GENERIC_NOIP_AUTH_MY_IP_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-	               p_self->alias_info.names[cnt].name,
-	               p_self->info.my_ip_address.name[ip_store],
-	               p_self->info.credentials.p_enc_usr_passwd_buffer,
-	               p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+	               p_self->info[srv_cnt].alias_info.names[cnt].name,
+	               p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+	               p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,
+	               p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_easydns_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_easydns_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, GENERIC_EASYDNS_AUTH_MY_IP_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-	               p_self->alias_info.names[cnt].name,
-	               p_self->info.my_ip_address.name[ip_store],
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+	               p_self->info[srv_cnt].alias_info.names[cnt].name,
+	               p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
 	               p_self->wildcard ? "ON" : "OFF",
-	               p_self->info.credentials.p_enc_usr_passwd_buffer,
-	               p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,
+	               p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_tzo_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_tzo_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 
@@ -649,28 +651,28 @@
 	}
 
 	return sprintf(p_self->p_req_buffer, GENERIC_TZO_AUTH_MY_IP_REQUEST_FORMAT,
-		       p_self->info.dyndns_server_url,
-		       p_self->alias_info.names[cnt].name,
-		       p_self->info.credentials.my_username,
-		       p_self->info.credentials.my_password,
-		       p_self->info.my_ip_address.name[ip_store],
-		       p_self->info.dyndns_server_name.name[ip_store]);
+		       p_self->info[srv_cnt].dyndns_server_name.url,
+		       p_self->info[srv_cnt].alias_info.names[cnt].name,
+		       p_self->info[srv_cnt].credentials.my_username,
+		       p_self->info[srv_cnt].credentials.my_password,
+		       p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+		       p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_sitelutions_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_sitelutions_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, SITELUTIONS_GET_MY_IP_HTTP_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-	               p_self->info.credentials.my_username,
-	               p_self->info.credentials.my_password,
-	               p_self->alias_info.names[cnt].name,
-				   p_self->info.my_ip_address.name[ip_store],
-	               p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+	               p_self->info[srv_cnt].credentials.my_username,
+	               p_self->info[srv_cnt].credentials.my_password,
+	               p_self->info[srv_cnt].alias_info.names[cnt].name,
+				   p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+	               p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_he_ipv6_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_he_ipv6_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info)
 {
 	unsigned char digestbuf[MD5_DIGEST_BYTES];
 	char digeststr[MD5_DIGEST_BYTES*2+1];
@@ -689,116 +691,116 @@
 		return 0;
 	}
 
-	md5_buffer(p_self->info.credentials.my_password,
-		   strlen(p_self->info.credentials.my_password), digestbuf);
+	md5_buffer(p_self->info[srv_cnt].credentials.my_password,
+		   strlen(p_self->info[srv_cnt].credentials.my_password), digestbuf);
 
 	for (i = 0; i < MD5_DIGEST_BYTES; i++)
 		sprintf(&digeststr[i*2], "%02x", digestbuf[i]);
 
 	return sprintf(p_self->p_req_buffer, HE_IPV6TB_UPDATE_MY_IP_REQUEST_FORMAT,
-				p_self->info.dyndns_server_url,
-				p_self->info.my_ip_address.name[ip_store],
-				p_self->info.credentials.my_username,
+				p_self->info[srv_cnt].dyndns_server_name.url,
+				p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+				p_self->info[srv_cnt].credentials.my_username,
 				digeststr,
-				p_self->alias_info.names[cnt].name,
-				p_self->info.dyndns_server_name.name[ip_store]);
+				p_self->info[srv_cnt].alias_info.names[cnt].name,
+				p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_dhis_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_dhis_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 
 	(void)p_sys_info;
 
 	return sprintf(p_self->p_req_buffer, DHIS_MY_IP_UPDATE_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-				   p_self->alias_info.names[cnt].name,
-				   p_self->info.credentials.my_password,
-				   p_self->info.my_ip_address.name[ip_store],
-				   p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+				   p_self->info[srv_cnt].alias_info.names[cnt].name,
+				   p_self->info[srv_cnt].credentials.my_password,
+				   p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+				   p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_majimoto_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_majimoto_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 
 	(void)p_sys_info;
 
 	return sprintf(p_self->p_req_buffer, MAJIMOTO_MY_IP_UPDATE_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-				   p_self->alias_info.names[cnt].name,
-				   p_self->info.my_ip_address.name[ip_store],
-				   p_self->info.credentials.p_enc_usr_passwd_buffer,				   
-				   p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+				   p_self->info[srv_cnt].alias_info.names[cnt].name,
+				   p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+				   p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,				   
+				   p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_zerigo_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_zerigo_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 
 	(void)p_sys_info;
 
 	return sprintf(p_self->p_req_buffer, ZERIGO_MY_IP_UPDATE_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-				   p_self->alias_info.names[cnt].name,
-				   p_self->info.my_ip_address.name[ip_store],
-				   p_self->info.credentials.p_enc_usr_passwd_buffer,				   
-				   p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+				   p_self->info[srv_cnt].alias_info.names[cnt].name,
+				   p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+				   p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,				   
+				   p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_ip_server(DYN_DNS_CLIENT *p_self, void *p_specific_data)
+static int get_req_for_ip_server(DYN_DNS_CLIENT *p_self,char srv_cnt, void *p_specific_data)
 {
 	(void)p_specific_data;
 
 	return sprintf(p_self->p_req_buffer, DYNDNS_GET_MY_IP_HTTP_REQUEST,
-	               p_self->info.ip_server_name.name[ip_store], p_self->info.ip_server_url);
+	               p_self->info[srv_cnt].ip_server_name.name, p_self->info[srv_cnt].ip_server_name.url);
 }
 
 RC_TYPE dyn_dns_set_online_check_dest(HTTP_CLIENT *dest,DYN_DNS_CLIENT *p_self)
 {
 
-	if (p_self->info.proxy_server_name.name[ip_store])
+	if (p_self->info[0].proxy_server_name.name)
 	{
-		http_client_set_remote_name(dest,p_self->info.proxy_server_name.name[ip_store]);
-		http_client_set_port(dest,p_self->info.proxy_server_name.port);
+		http_client_set_remote_name(dest,p_self->info[0].proxy_server_name.name);
+		http_client_set_port(dest,p_self->info[0].proxy_server_name.port);
 	}
 	else
 	{
-		http_client_set_remote_name(dest,p_self->info_online_status.ip_server_name.name[ip_store]);
-		http_client_set_port(dest,p_self->info_online_status.ip_server_name.port);
+		http_client_set_remote_name(dest,p_self->info_online_status.name);
+		http_client_set_port(dest,p_self->info_online_status.port);
 	}
 
 
 	return RC_OK;
 }
 
-RC_TYPE dyn_dns_set_ip_server_dest(HTTP_CLIENT *dest,DYN_DNS_CLIENT *p_self)
+RC_TYPE dyn_dns_set_ip_server_dest(HTTP_CLIENT *dest,DYN_DNS_CLIENT *p_self,char srv_cnt)
 {
 
-	if (p_self->info.proxy_server_name.name[ip_store])
+	if (p_self->info[srv_cnt].proxy_server_name.name)
 	{
-		http_client_set_remote_name(dest,p_self->info.proxy_server_name.name[ip_store]);
-		http_client_set_port(dest,p_self->info.proxy_server_name.port);
+		http_client_set_remote_name(dest,p_self->info[srv_cnt].proxy_server_name.name);
+		http_client_set_port(dest,p_self->info[srv_cnt].proxy_server_name.port);
 	}
 	else
 	{
-		http_client_set_remote_name(dest,p_self->info.ip_server_name.name[ip_store]);
-		http_client_set_port(dest,p_self->info.ip_server_name.port);
+		http_client_set_remote_name(dest,p_self->info[srv_cnt].ip_server_name.name);
+		http_client_set_port(dest,p_self->info[srv_cnt].ip_server_name.port);
 	}
 
 
 	return RC_OK;
 }
 
-RC_TYPE dyn_dns_set_dyndns_server_dest(HTTP_CLIENT *dest,DYN_DNS_CLIENT *p_self)
+RC_TYPE dyn_dns_set_dyndns_server_dest(HTTP_CLIENT *dest,DYN_DNS_CLIENT *p_self,char srv_cnt)
 {
 
-	if (p_self->info.proxy_server_name.name[ip_store])
+	if (p_self->info[srv_cnt].proxy_server_name.name)
 	{
-		http_client_set_remote_name(dest,p_self->info.proxy_server_name.name[ip_store]);
-		http_client_set_port(dest,p_self->info.proxy_server_name.port);
+		http_client_set_remote_name(dest,p_self->info[srv_cnt].proxy_server_name.name);
+		http_client_set_port(dest,p_self->info[srv_cnt].proxy_server_name.port);
 	}
 	else
 	{
-		http_client_set_remote_name(dest,p_self->info.dyndns_server_name.name[ip_store]);
-		http_client_set_port(dest,p_self->info.dyndns_server_name.port);
+		http_client_set_remote_name(dest,p_self->info[srv_cnt].dyndns_server_name.name);
+		http_client_set_port(dest,p_self->info[srv_cnt].dyndns_server_name.port);
 	}
 
 
@@ -807,10 +809,14 @@
 
 RC_TYPE dyn_dns_set_http_clients(DYN_DNS_CLIENT *p_self)
 {
+	char	i;
 
-	dyn_dns_set_ip_server_dest(&p_self->http_to_ip_server,p_self);
-	dyn_dns_set_dyndns_server_dest(&p_self->http_to_dyndns,p_self);
 
+	for (i=0;i<p_self->srv_cnt;i++) {
+
+		dyn_dns_set_ip_server_dest(&p_self->info[i].http_to_ip_server,p_self,i);
+		dyn_dns_set_dyndns_server_dest(&p_self->info[i].http_to_dyndns,p_self,i);
+	}
 
 	return RC_OK;
 }
@@ -847,7 +853,7 @@
     Note:
         it updates the flag: info->'my_ip_has_changed' if the old address was different 
 */
-static RC_TYPE do_check_my_ip_address(DYN_DNS_CLIENT *p_self)
+static RC_TYPE do_check_my_ip_address(DYN_DNS_CLIENT *p_self,char srv_cnt)
 {
 
 	RC_TYPE		rc=RC_OK;
@@ -873,13 +879,13 @@
 		else
 			ip_enum=ip_6;
 
-		p_self->info.my_ip_has_changed[ip_enum]=(strcmp(p_ip_str,p_self->info.my_ip_address.name[ip_enum])!=0);
+		p_self->info[srv_cnt].i_face.my_ip_has_changed[ip_enum]=(strcmp(p_ip_str,p_self->info[srv_cnt].i_face.my_ip_address.name[ip_enum])!=0);
 
-		strcpy(p_self->info.my_ip_address.name[ip_enum],p_ip_str);
+		strcpy(p_self->info[srv_cnt].i_face.my_ip_address.name[ip_enum],p_ip_str);
 
 		/*put currently operated upon here -- for auto ip type too*/
-		strcpy(p_self->info.my_ip_address.name[ip_store],p_ip_str);
-		p_self->info.my_ip_has_changed[ip_store]=p_self->info.my_ip_has_changed[ip_enum];
+		strcpy(p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],p_ip_str);
+		p_self->info[srv_cnt].i_face.my_ip_has_changed[ip_store]=p_self->info[srv_cnt].i_face.my_ip_has_changed[ip_enum];
 
 		free(p_ip_str);
 
@@ -895,20 +901,23 @@
 	iterate over any fallback addresses
 	break on first success
 */
-static RC_TYPE check_my_ip_address(DYN_DNS_CLIENT *p_self)
+static RC_TYPE check_my_ip_address(DYN_DNS_CLIENT *p_self,char srv_index)
 {
-	RC_TYPE rc;
-	HTTP_CLIENT *p_http;
+	RC_TYPE				rc;
+	HTTP_CLIENT			*p_http;
+	DYNDNS_INFO_TYPE	*info;
 	
 
-	p_http = &p_self->http_to_ip_server;
+	info=&p_self->info[srv_index];
 
+	p_http = &info->http_to_ip_server;
 
-	rc = http_client_init_all(&p_self->http_to_ip_server);
+
+	rc = http_client_init_all(&info->http_to_ip_server);
 
 	if (rc != RC_OK)
 	{
-		http_client_shutdown(&p_self->http_to_ip_server);
+		http_client_shutdown(&info->http_to_ip_server);
 
 		return rc;
 	}
@@ -929,8 +938,8 @@
 			BOOL				is_got_afinet=false;
 
 
-			p_tr->req_len = get_req_for_ip_server((DYN_DNS_CLIENT*) p_self,
-			                                      p_self->info.p_dns_system->p_specific_data);
+			p_tr->req_len = get_req_for_ip_server((DYN_DNS_CLIENT*) p_self,srv_index,
+			                                      info->p_dns_system->p_specific_data);
 			if (p_self->dbg.level > LOG_CRIT) {
 
 				DBG_PRINTF((LOG_DEBUG,"The request for IP server:\n%s\n",p_self->p_req_buffer));
@@ -943,12 +952,12 @@
 
 
 			DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "Entering Loop.  Got %d sockets...\n",
-				p_self->http_to_ip_server.super.super.server_socket_count));
+				info->http_to_ip_server.super.super.server_socket_count));
 
-			for (i=0;i<p_self->http_to_ip_server.super.super.server_socket_count;i++,
-				p_self->http_to_ip_server.super.super.sock_index++) {
+			for (i=0;i<info->http_to_ip_server.super.super.server_socket_count;i++,
+				info->http_to_ip_server.super.super.sock_index++) {
 				
-				addr=p_self->http_to_ip_server.super.super.addr_ar[i];
+				addr=info->http_to_ip_server.super.super.addr_ar[i];
 
 				/*on *nix, IPv4 precedence could mean no IPv6 routes which could cause a crash on socket send*/
 				if (((is_got_afinet=(is_got_afinet || addr->ai_family==AF_INET)) && addr->ai_family==AF_INET6))
@@ -968,19 +977,22 @@
 					continue;
 					
 				/*doing any ip4?*/
-				if ((addr->ai_family==AF_INET) && !(p_self->info.is_update_ip4 || p_self->info.is_update_auto))
+				if ((addr->ai_family==AF_INET) && !(p_self->info[srv_index].is_update_ip4 || p_self->info[srv_index].is_update_auto))
 
 					continue;
 					
 				/*doing any ip6?*/
-				if ((addr->ai_family==AF_INET6) && !(p_self->info.is_update_ip6 || p_self->info.is_update_auto))
+				if ((addr->ai_family==AF_INET6) && !(p_self->info[srv_index].is_update_ip6 || p_self->info[srv_index].is_update_auto))
 
 					continue;
+				
+				memset(p_self->p_work_buffer,0,p_self->work_buffer_size);
 
-				if (!(RC_OK==(rc=http_client_transaction(&p_self->http_to_ip_server,&p_self->http_tr)))) {
+
+				if (!(RC_OK==(rc=http_client_transaction(&info->http_to_ip_server,&p_self->http_tr)))) {
 
 					DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Failed getting %s ip from %s%s in check_my_ip_address...\n",
-						addr_family_get_name(addr->ai_family),p_self->info.ip_server_name.name[ip_store],p_self->info.ip_server_url));
+						addr_family_get_name(addr->ai_family),info->ip_server_name.name,info->ip_server_name.url));
 				}
 				else {
 
@@ -993,22 +1005,22 @@
 
 					DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "GONNA PARSE...\n"));
 
-					if (!(RC_OK==(rc=do_check_my_ip_address(p_self)))) {
+					if (!(RC_OK==(rc=do_check_my_ip_address(p_self,srv_index)))) {
 
 						DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "ip parse failed in check_my_ip_address...\n"));
 					}
 					else {
 
-						DBG_PRINTF((LOG_NOTICE,"N:DYNDNS: My IP address: %s\n", p_self->info.my_ip_address.name[ip_store]));
+						DBG_PRINTF((LOG_NOTICE,"N:DYNDNS: My IP address: %s\n", p_self->info[srv_index].i_face.my_ip_address.name[ip_store]));
 
-						p_self->info.is_got_ip4=is_got_ip4=(is_got_ip4 || (addr->ai_family==AF_INET));
-						p_self->info.is_got_ip6=is_got_ip6=(is_got_ip6 || (addr->ai_family==AF_INET6));
+						p_self->info[srv_index].is_got_ip4=is_got_ip4=(is_got_ip4 || (addr->ai_family==AF_INET));
+						p_self->info[srv_index].is_got_ip6=is_got_ip6=(is_got_ip6 || (addr->ai_family==AF_INET6));
 						
 						/*detect if just doing auto (based on ip server) and dump out when done*/
-						if ((is_got_ip4 && is_got_ip6) || !(p_self->info.is_update_ip4 && p_self->info.is_update_ip6))
+						if ((is_got_ip4 && is_got_ip6) || !(p_self->info[srv_index].is_update_ip4 && p_self->info[srv_index].is_update_ip6))
 
 							/*support ip4 only updates, on dual ip server*/
-							if ((p_self->info.is_update_ip4 && is_got_ip4) || !(p_self->info.is_update_ip4))							
+							if ((p_self->info[srv_index].is_update_ip4 && is_got_ip4) || !(p_self->info[srv_index].is_update_ip4))							
 
 								break;
 					}
@@ -1019,7 +1031,7 @@
 	while(0);
 
 	/*close*/
-	http_client_shutdown(&p_self->http_to_ip_server);
+	http_client_shutdown(&info->http_to_ip_server);
 
 
 	return rc;
@@ -1033,53 +1045,57 @@
         Check if my IP address has changed. -> ALL names have to be updated.
         Note: In the update function the property will set to false if update was successful.
 */
-static RC_TYPE do_check_alias_update_table(DYN_DNS_CLIENT *p_self)
+static RC_TYPE do_check_alias_update_table(DYN_DNS_CLIENT *p_self,char srv_index)
 {
-	int			i;
-	DYNDNS_IPV	ip_v;
-	BOOL		is_ip_changed;
-	BOOL		is_dyndns_dual;
+	int					i;
+	DYNDNS_IPV			ip_v;
+	BOOL				is_ip_changed;
+	BOOL				is_dyndns_dual;
+	DYNDNS_INFO_TYPE	*info;
+
 
+	info=&p_self->info[srv_index];
 
-	for (i = 0; i < p_self->alias_info.count; ++i)
+
+	for (i = 0; i < info->alias_info.count; ++i)
 	{
 
-		ip_v=p_self->alias_info.names[i].ip_v_enum;		
+		ip_v=info->alias_info.names[i].ip_v_enum;		
 
 		/*ip type DUAL_LIST is dual of form, 1.1.1.1,::1 -- both ip types in one update connection*/
-		if (!(is_dyndns_dual=(NULL!=strstr(p_self->alias_info.names[i].ip_v,DUAL_LIST))))
+		if (!(is_dyndns_dual=(NULL!=strstr(info->alias_info.names[i].ip_v,DUAL_LIST))))
 
-			is_ip_changed=p_self->info.my_ip_has_changed[ip_v];
+			is_ip_changed=p_self->info[srv_index].i_face.my_ip_has_changed[ip_v];
 		else
-			is_ip_changed=(p_self->info.my_ip_has_changed[ip_4] || p_self->info.my_ip_has_changed[ip_6]);
+			is_ip_changed=(p_self->info[srv_index].i_face.my_ip_has_changed[ip_4] || p_self->info[srv_index].i_face.my_ip_has_changed[ip_6]);
 
-		p_self->alias_info.update_required[i] = 
+		info->alias_info.update_required[i] = 
 
 			/*ip address changed?*/
 			(is_ip_changed
 
 			/*pending failed update?*/
-			|| (is_update_pending && !(p_self->alias_info.update_succeeded[i]))
+			|| (is_global_update_pending && !(info->alias_info.update_succeeded[i]))
 
 			/*administrative update?*/
 			|| (!(p_self->forced_update_counter)));
 
-		if (p_self->alias_info.update_required[i]) {	
+		if (info->alias_info.update_required[i]) {	
 	
 			if (is_dyndns_dual)
 
 				DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "IP address for alias '%s:%s' needs update to '%s%s%s'...\n",
-				        p_self->alias_info.names[i].name,p_self->alias_info.names[i].ip_v, 
-						p_self->info.my_ip_address.name[ip_4],",",p_self->info.my_ip_address.name[ip_6]));
+				        info->alias_info.names[i].name,info->alias_info.names[i].ip_v, 
+						p_self->info[srv_index].i_face.my_ip_address.name[ip_4],",",p_self->info[srv_index].i_face.my_ip_address.name[ip_6]));
 
 
 			else
 
 				DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "IP address for alias '%s:%s' needs update to '%s'...\n",
-				        p_self->alias_info.names[i].name,p_self->alias_info.names[i].ip_v, 
-						p_self->info.my_ip_address.name[ip_v]));
+				        info->alias_info.names[i].name,info->alias_info.names[i].ip_v, 
+						p_self->info[srv_index].i_face.my_ip_address.name[ip_v]));
 
-			p_self->alias_info.update_required[i]=!(p_self->alias_info.fatal_error[i]);
+			info->alias_info.update_required[i]=!(info->alias_info.fatal_error[i]);
 		}
 	}
 	
@@ -1109,7 +1125,7 @@
 					In all other cases it warns user that request was ignored because of agent that does not 
 					follow our specifications. 
 */
-static BOOL is_dyndns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string)
+static BOOL is_dyndns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string,char srv_cnt)
 {
 	/*fail on (badauth, nohost, notfqdn, !yours, etc)*/
 
@@ -1133,10 +1149,10 @@
     fail blabla and n.n.n.n
     are the good answers. We search our own IP address in response and that's enough.
 */
-static BOOL is_freedns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string)
+static BOOL is_freedns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string,char srv_cnt)
 {
 
-	return (((strstr(p_rsp, "ERROR") == NULL) && strstr(p_rsp, p_self->info.my_ip_address.name[ip_store]) != NULL)
+	return (((strstr(p_rsp, "ERROR") == NULL) && strstr(p_rsp, p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store]) != NULL)
 			|| strstr(p_rsp, "has not changed") != NULL);	
 }
 
@@ -1150,7 +1166,7 @@
 	parses a given string. If found is ok,
 	Example : 'SUCCESS CODE='
 */
-static BOOL is_generic_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string)
+static BOOL is_generic_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string,char srv_cnt)
 {
 	if (p_ok_string == NULL)
 	{
@@ -1172,7 +1188,7 @@
 		CODE=200
 		CODE=707, for duplicated updates
 */
-BOOL is_zoneedit_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string)
+BOOL is_zoneedit_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string,char srv_cnt)
 {
 	(void) p_ok_string;
 
@@ -1191,7 +1207,7 @@
 /**
 	NOERROR is the OK code here
 */
-BOOL is_easydns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string)
+BOOL is_easydns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string,char srv_cnt)
 {
 	return (strstr(p_rsp, "NOERROR") != NULL);
 }
@@ -1203,7 +1219,7 @@
 			 != NULL || strstr(p_rsp, "TOOSOON") != NULL);
 }
 
-static BOOL is_sitelutions_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char* p_ok_string)
+static BOOL is_sitelutions_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char* p_ok_string,char srv_cnt)
 {
 
 	return (strstr(p_rsp,"success") != NULL);
@@ -1219,11 +1235,11 @@
 /* HE ipv6 tunnelbroker specific response validator.
    own IP address and 'already in use' are the good answers.
 */
-static BOOL is_he_ipv6_server_rsp_ok(DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string)
+static BOOL is_he_ipv6_server_rsp_ok(DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string,char srv_cnt)
 {
 	(void)p_ok_string;
 
-	return ((strstr(p_rsp, p_self->info.my_ip_address.name[ip_store]) != NULL) ||
+	return ((strstr(p_rsp, p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store]) != NULL) ||
 		(strstr(p_rsp, "already in use") != NULL));
 }
 
@@ -1238,7 +1254,7 @@
 /* TZO specific response validator.
    If we have an HTTP 302 the update wasn't good and we're being redirected 
 */
-static BOOL is_tzo_server_rsp_ok(DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string)
+static BOOL is_tzo_server_rsp_ok(DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string,char srv_cnt)
 {
 	
 	return strstr(p_rsp,"200")  != NULL || strstr(p_rsp,"304") != NULL;
@@ -1252,10 +1268,10 @@
 			 != NULL || strstr(p_rsp, "407") != NULL || strstr(p_rsp, "415") != NULL);
 }
 
-static BOOL is_dhis_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char* p_ok_string)
+static BOOL is_dhis_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char* p_ok_string,char srv_cnt)
 {
 
-	return (strstr(p_rsp,p_self->info.my_ip_address.name[ip_store]) != NULL);
+	return (strstr(p_rsp,p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store]) != NULL);
 }
 
 /*not yet implemented -- at moment, this seems only failure returned
@@ -1267,7 +1283,7 @@
 }
 
 /*the quiet type*/
-static BOOL is_majimoto_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char* p_ok_string)
+static BOOL is_majimoto_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char* p_ok_string,char srv_cnt)
 {
 
 	return (!(strlen(p_rsp)));
@@ -1282,7 +1298,7 @@
 	return false;
 }
 
-static BOOL is_zerigo_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char* p_ok_string)
+static BOOL is_zerigo_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char* p_ok_string,char srv_cnt)
 {
 	return (strstr(p_rsp,"Status: 200")!=NULL);
 }
@@ -1293,110 +1309,133 @@
 }
 
 static RC_TYPE update_update_state(DYN_DNS_CLIENT *p_self,int updates_needed,int success_updates,
-										  int config_fails,RC_TYPE *rc)
+										  int config_fails,RC_TYPE rc,char srv_index)
 {
-	FILE *fp;
+	FILE				*fp;
+	DYNDNS_INFO_TYPE	*info;
 
 
-	if (config_fails==p_self->alias_info.count)
+	info=&p_self->info[srv_index];
 
-		*rc=RC_DYNDNS_RSP_CONFIG;
+	/*global successes maintained across server iterations in main loop*/
+	is_global_success_updates=(is_global_success_updates || success_updates);
 
-	else {
+	if (config_fails==info->alias_info.count) {
 
-		if (success_updates) {
+		rc=RC_DYNDNS_RSP_CONFIG;
+
+		if (!(srv_index==p_self->srv_cnt-1))
 
-			/*reset forced update period*/
-			p_self->forced_update_counter=p_self->forced_update_period_sec_orig/p_self->cmd_check_period;
-			p_self->forced_update_period_sec=p_self->forced_update_period_sec_orig;			
+			return rc;
+	}
 
-			if ((fp=utf_fopen(p_self->time_cache, "w"))) {
+	/*
+		reset on last server if any server successes
+	*/
+	if (is_global_success_updates && srv_index==p_self->srv_cnt-1) {
 
-				fprintf(fp,"%ld",time(NULL));
+		/*reset forced update period*/
+		p_self->forced_update_counter=p_self->forced_update_period_sec_orig/p_self->cmd_check_period;
+		p_self->forced_update_period_sec=p_self->forced_update_period_sec_orig;			
 
-				fclose(fp);
-			}
+		if ((fp=utf_fopen(p_self->time_cache, "w"))) {
 
-			if ((fp=utf_fopen(p_self->ip_cache, "w"))) {
+			fprintf(fp,"%ld",time(NULL));
 
-				int			i;
-				DYNDNS_IPV	ip_enum;
-				BOOL		is_dyndns_dual;
+			fclose(fp);
+		}
+
+		if ((fp=utf_fopen(p_self->ip_cache, "w"))) {
+
+			int			i;
+			int			ii;
+			DYNDNS_IPV	ip_enum;
+			BOOL		is_dyndns_dual;
 				
-				for (i=0;i<p_self->alias_info.count;i++) {
+			for (ii=0;ii<p_self->srv_cnt;ii++) {
+
+				for (i=0;i<p_self->info[ii].alias_info.count;i++) {
 
-					is_dyndns_dual=(NULL!=strstr(p_self->alias_info.names[i].ip_v,DUAL_LIST));
+					is_dyndns_dual=(NULL!=strstr(p_self->info[ii].alias_info.names[i].ip_v,DUAL_LIST));
 
-					ip_enum=p_self->alias_info.names[i].ip_v_enum;
+					ip_enum=p_self->info[ii].alias_info.names[i].ip_v_enum;
 
-					if (p_self->alias_info.update_succeeded[i]) { 						
+					if (p_self->info[ii].alias_info.update_succeeded[i]) { 						
 
 						if (!(is_dyndns_dual))
 
-							fprintf(fp,"%s %s%s%s\n",p_self->info.my_ip_address.name[ip_enum],
-								p_self->alias_info.names[i].name,":",p_self->alias_info.names[i].ip_v);
+							fprintf(fp,"%s %s%s%s\n",p_self->info[ii].i_face.my_ip_address.name[ip_enum],
+									p_self->info[ii].alias_info.names[i].name,":",p_self->info[ii].
+									alias_info.names[i].ip_v);
 
 						else {
 
-							fprintf(fp,"%s %s%s%s\n",p_self->info.my_ip_address.name[ip_4],
-								p_self->alias_info.names[i].name,":","ip4");
+							fprintf(fp,"%s %s%s%s\n",p_self->info[ii].i_face.my_ip_address.name[ip_4],
+									p_self->info[ii].alias_info.names[i].name,":","ip4");
 
-							fprintf(fp,"%s %s%s%s\n",p_self->info.my_ip_address.name[ip_6],
-								p_self->alias_info.names[i].name,":","ip6");
+							fprintf(fp,"%s %s%s%s\n",p_self->info[ii].i_face.my_ip_address.name[ip_6],
+									p_self->info[ii].alias_info.names[i].name,":","ip6");
 						}
 					}
 				}
-
-				fclose(fp);
 			}
-		}
-	
-		/*any pending?*/
-		if (!(updates_needed && !(success_updates==updates_needed))) {
 
-			/*no pendings*/
-			if (success_updates) {
-
-				p_self->is_forced_update_attempted=false;
+			fclose(fp);
+		}		
+	}
 
-				*rc=RC_OK;
-			}
-		}
-		else {
+	/*any pending?*/
+	if ((updates_needed && !(success_updates==updates_needed))) {
 
-			if (*rc==RC_OK) /*not break after http client init*/
+		if (rc==RC_OK) /*not break after http client init*/
 			
-				*rc=RC_DYNDNS_RSP_NOTOK;
+			rc=RC_DYNDNS_RSP_NOTOK;
 
-			DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "One or more (%d) alias updates failed...\n",
+		DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "One or more (%d) alias updates failed...\n",
 						updates_needed-success_updates));
+	}
+	else {
+
+		/*no pendings this server*/
+		if (success_updates) {
+
+			/*no pendings any server*/
+			if (!(is_global_in_proc_update_pending) && srv_index==p_self->srv_cnt-1)
+
+				p_self->is_forced_update_attempted=false;
+
+			rc=RC_OK;
 		}
 	}
 
-	return *rc;
+	return rc;
 }
 
-static RC_TYPE do_update_alias_table(DYN_DNS_CLIENT *p_self,char *is_forced_update_reset)
+static RC_TYPE do_update_alias_table(DYN_DNS_CLIENT *p_self,char *is_forced_update_reset,char srv_index)
 {
-	int		i;
-	int		success_updates=0;	
-	int		update_ok=false;
-	int		config_fails=0;
-	int		updates_needed=p_self->alias_info.count;
-	BOOL	is_ipv4;
+	DYNDNS_INFO_TYPE	*info;
+	int					i;
+	int					success_updates=0;	
+	int					update_ok=false;
+	int					config_fails=0;
+	int					updates_needed=p_self->info[srv_index].alias_info.count;
+	BOOL				is_ipv4;
 
 	RC_TYPE rc = RC_OK;
 
 
+	info=&p_self->info[srv_index];
+
+
 	do
 	{
-		for (i = 0; i < p_self->alias_info.count; ++i) {
+		for (i = 0; i < info->alias_info.count; ++i) {
 
-			if (!(p_self->alias_info.update_required[i])) {
+			if (!(info->alias_info.update_required[i])) {
 
-				if (p_self->alias_info.fatal_error[i]) {
+				if (info->alias_info.fatal_error[i]) {
 
-					do_handle_bad_config(p_self,i);
+					do_handle_bad_config(p_self,i,srv_index);
 
 					config_fails++;
 				}
@@ -1406,48 +1445,48 @@
 			else {
 
 				/*dual stack with ip's updated in comma delimited list fashion?*/
-				if (NULL==(strstr(p_self->alias_info.names[i].ip_v,DUAL_LIST))) {
+				if (NULL==(strstr(info->alias_info.names[i].ip_v,DUAL_LIST))) {
 
-					if (!(ip_store==p_self->alias_info.names[i].ip_v_enum))
+					if (!(ip_store==info->alias_info.names[i].ip_v_enum))
 
-						strcpy(p_self->info.my_ip_address.name[ip_store],
-								p_self->info.my_ip_address.name[p_self->alias_info.names[i].ip_v_enum]);
+						strcpy(p_self->info[srv_index].i_face.my_ip_address.name[ip_store],
+								p_self->info[srv_index].i_face.my_ip_address.name[info->alias_info.names[i].ip_v_enum]);
 				}
 				else {
 
-					strcat(strcat(strcpy(p_self->info.my_ip_address.name[ip_store],p_self->info.my_ip_address.name[ip_4]),
-							","),p_self->info.my_ip_address.name[ip_6]);
+					strcat(strcat(strcpy(p_self->info[srv_index].i_face.my_ip_address.name[ip_store],p_self->info[srv_index].i_face.my_ip_address.name[ip_4]),
+							","),p_self->info[srv_index].i_face.my_ip_address.name[ip_6]);
 
-					if (!(p_self->info.is_got_ip4 && p_self->info.is_got_ip6)) {
+					if (!(p_self->info[srv_index].is_got_ip4 && p_self->info[srv_index].is_got_ip6)) {
 
-						p_self->alias_info.update_succeeded[i]=false;
+						info->alias_info.update_succeeded[i]=false;
 
 						DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Skipping partially empty address (%s) update of alias "\
-							"%s\n",p_self->info.my_ip_address.name[ip_store],p_self->alias_info.names[i].name));
+							"%s\n",p_self->info[srv_index].i_face.my_ip_address.name[ip_store],info->alias_info.names[i].name));
 
 						continue;
 					}
 				}
 
-				if (!(strlen(p_self->info.my_ip_address.name[ip_store]))) {
+				if (!(strlen(p_self->info[srv_index].i_face.my_ip_address.name[ip_store]))) {
 
-					p_self->alias_info.update_succeeded[i]=false;
+					info->alias_info.update_succeeded[i]=false;
 
-					DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Skipping empty address update of alias %s\n",p_self->alias_info.names[i].name));
+					DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Skipping empty address update of alias %s\n",info->alias_info.names[i].name));
 
 					continue;
 				}
 
-				is_ipv4=(p_self->alias_info.names[i].ip_v_enum==ip_4);
+				is_ipv4=(info->alias_info.names[i].ip_v_enum==ip_4);
 
 				/*bind to dynamic dns server according to address type to be updated*/
-				http_client_set_is_ipv4(&p_self->http_to_dyndns,is_ipv4);
+				http_client_set_is_ipv4(&info->http_to_dyndns,is_ipv4);
 
-				if (!((rc=http_client_init(&p_self->http_to_dyndns))==RC_OK)) {
+				if (!((rc=http_client_init(&info->http_to_dyndns))==RC_OK)) {
 
-					DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Init error:  %s updating alias %s\n",errorcode_get_name(rc),p_self->alias_info.names[i].name));
+					DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Init error:  %s updating alias %s\n",errorcode_get_name(rc),info->alias_info.names[i].name));
 
-					p_self->alias_info.update_succeeded[i]=false;
+					info->alias_info.update_succeeded[i]=false;
 				}
 				else {
 
@@ -1455,9 +1494,10 @@
 					{
 						HTTP_TRANSACTION http_tr;
 						
-						http_tr.req_len = p_self->info.p_dns_system->p_dns_update_req_func(
-							                  (struct _DYN_DNS_CLIENT*) p_self,i,
-								              (struct DYNDNS_SYSTEM*) p_self->info.p_dns_system);
+						http_tr.req_len = 
+							info->p_dns_system->p_dns_update_req_func((struct _DYN_DNS_CLIENT*) p_self,srv_index,i,
+							(struct DYNDNS_SYSTEM*) info->p_dns_system);
+
 						http_tr.p_req = (char*) p_self->p_req_buffer;
 						http_tr.p_rsp = (char*) p_self->p_work_buffer;
 						http_tr.max_rsp_len = p_self->work_buffer_size - 1;/*save place for a \0 at the end*/
@@ -1465,7 +1505,7 @@
 						p_self->p_work_buffer[http_tr.rsp_len+1] = 0;				
 
 						/*send it*/
-						rc = http_client_transaction(&p_self->http_to_dyndns, &http_tr);
+						rc = http_client_transaction(&info->http_to_dyndns, &http_tr);
 						http_tr.p_rsp[http_tr.rsp_len]=0;
 
 						if (p_self->dbg.level > 2)
@@ -1477,14 +1517,13 @@
 						/*error in send?*/
 						if (!(rc == RC_OK))
 
-							p_self->alias_info.update_succeeded[i]=false;
+							info->alias_info.update_succeeded[i]=false;
 
 						else {
 
 							update_ok =
-								p_self->info.p_dns_system->p_rsp_ok_func((struct _DYN_DNS_CLIENT*)p_self,
-									    http_tr.p_rsp,
-										p_self->info.p_dns_system->p_success_string);
+								info->p_dns_system->p_rsp_ok_func((struct _DYN_DNS_CLIENT*)p_self,
+									    http_tr.p_rsp,info->p_dns_system->p_success_string,srv_index);
 
 							if (update_ok)
 							{
@@ -1498,12 +1537,12 @@
 									*is_forced_update_reset=true;
 								}
 #endif
-								p_self->alias_info.update_required[i]=false;
-								p_self->alias_info.update_succeeded[i]=true;
+								info->alias_info.update_required[i]=false;
+								info->alias_info.update_succeeded[i]=true;
 
 								DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "Alias '%s' to IP '%s' updated successfully.\n",
-											p_self->alias_info.names[i].name,
-											p_self->info.my_ip_address.name[ip_store]));
+											info->alias_info.names[i].name,
+											p_self->info[srv_index].i_face.my_ip_address.name[ip_store]));
 
 								if (p_self->external_command)
 
@@ -1511,24 +1550,24 @@
 							}
 							else {
 
-								p_self->alias_info.update_succeeded[i]=false;
+								info->alias_info.update_succeeded[i]=false;
 
-								if (!(p_self->info.p_dns_system->p_rsp_config_func((struct _DYN_DNS_CLIENT*)p_self,http_tr.p_rsp))) {
+								if (!(info->p_dns_system->p_rsp_config_func((struct _DYN_DNS_CLIENT*)p_self,http_tr.p_rsp))) {
 
-									DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "Error updating alias %s\n",p_self->alias_info.names[i].name));
+									DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "Error updating alias %s\n",info->alias_info.names[i].name));
 								} 
 								else {
 
 									DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "Error validating DYNDNS svr answer. Check usr,pass,hostname!\n"));
 
-									p_self->alias_info.fatal_error[i]=TRUE;
+									info->alias_info.fatal_error[i]=TRUE;
 
 									DBG_PRINTF((LOG_CRIT,"C:" MODULE_TAG "\n"\
 												ERROR_FLAG \
 												"Fatal dyndns server update error for "\
 												"alias, %s.\nThis client should be stopped and corrected for "\
 												"configuration errors, and restarted...\n" \
-												ERROR_FLAG,p_self->alias_info.names[i].name));
+												ERROR_FLAG,info->alias_info.names[i].name));
 
 									config_fails++;
 									updates_needed--;
@@ -1545,7 +1584,7 @@
 				}
 
 				{
-					RC_TYPE rc2 = http_client_shutdown(&p_self->http_to_dyndns);
+					RC_TYPE rc2 = http_client_shutdown(&info->http_to_dyndns);
 
 					if (!(rc2==RC_OK))
 
@@ -1553,7 +1592,7 @@
 
 				}				
 
-				if (i<p_self->alias_info.count-1)
+				if (i<info->alias_info.count-1)
 
 					os_sleep_ms(1000);
 			}
@@ -1564,7 +1603,7 @@
 	}
 	while(0);
 
-	return update_update_state(p_self,updates_needed,success_updates,config_fails,&rc);
+	return update_update_state(p_self,updates_needed,success_updates,config_fails,rc,srv_index);
 }
 
 RC_TYPE get_default_config_data(DYN_DNS_CLIENT *p_self)
@@ -1576,8 +1615,9 @@
 
 	do
 	{
-		p_self->info.p_dns_system = get_dns_system_by_id(DYNDNS_MY_DNS_SYSTEM);
-		if (p_self->info.p_dns_system == NULL)
+
+		p_self->info[0].p_dns_system = get_dns_system_by_id(DYNDNS_MY_DNS_SYSTEM);
+		if (p_self->info[0].p_dns_system == NULL)
 		{
 			rc = RC_DYNDNS_INVALID_DNS_SYSTEM_DEFAULT;
 			break;
@@ -1651,7 +1691,7 @@
 	return rc;
 }
 
-static RC_TYPE get_encoded_user_passwd(DYN_DNS_CLIENT *p_self)
+static RC_TYPE get_encoded_user_passwd(DYN_DNS_CLIENT *p_self,char srv_cnt)
 {
 	RC_TYPE			rc=RC_OK;
 	char			*str_uri_encoded;
@@ -1661,23 +1701,23 @@
 	int				actual_len;
 
 
-	if (!(p_self->info.credentials.my_password) && !(p_self->info.credentials.my_username))
+	if (!(p_self->info[srv_cnt].credentials.my_password) && !(p_self->info[srv_cnt].credentials.my_username))
 
 		return RC_OK;
 
 	size=strlen(format)+1;
 
-	if (!(p_self->info.credentials.my_password))
+	if (!(p_self->info[srv_cnt].credentials.my_password))
 
-		p_self->info.credentials.my_password=safe_malloc(1);
+		p_self->info[srv_cnt].credentials.my_password=safe_malloc(1);
 
-	size+=strlen(p_self->info.credentials.my_password);
+	size+=strlen(p_self->info[srv_cnt].credentials.my_password);
 
-	if (!(p_self->info.credentials.my_username))
+	if (!(p_self->info[srv_cnt].credentials.my_username))
 
-		p_self->info.credentials.my_username=safe_malloc(1);
+		p_self->info[srv_cnt].credentials.my_username=safe_malloc(1);
 
-	size+=strlen(p_self->info.credentials.my_username);
+	size+=strlen(p_self->info[srv_cnt].credentials.my_username);
 
 	do
 	{
@@ -1689,8 +1729,8 @@
 		}
 
 		actual_len = sprintf(p_tmp_buff, format,
-		                     p_self->info.credentials.my_username,
-		                     p_self->info.credentials.my_password);
+		                     p_self->info[srv_cnt].credentials.my_username,
+		                     p_self->info[srv_cnt].credentials.my_password);
 
 		if (actual_len >= size)
 		{
@@ -1700,15 +1740,15 @@
 
 		/*encode*/
 
-		p_self->info.credentials.p_enc_usr_passwd_buffer =
+		p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer =
 		    b64encode(utf_8_uri_encoded(&str_uri_encoded,p_tmp_buff,"&#",";"));
 
 		free(str_uri_encoded);
 
-		p_self->info.credentials.encoded =
-		    (p_self->info.credentials.p_enc_usr_passwd_buffer != NULL);
+		p_self->info[srv_cnt].credentials.encoded =
+		    (p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer != NULL);
 
-		p_self->info.credentials.size = strlen(p_self->info.credentials.p_enc_usr_passwd_buffer);
+		p_self->info[srv_cnt].credentials.size = strlen(p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer);
 	}
 	while(0);
 
@@ -1741,6 +1781,8 @@
 	DYN_DNS_CLIENT *p_self;
 	BOOL http_to_dyndns_constructed = FALSE;
 	BOOL http_to_ip_constructed = FALSE;
+	char i;
+
 
 	if (pp_self == NULL)
 	{
@@ -1777,25 +1819,30 @@
 		}
 
 
-		rc = http_client_construct(&p_self->http_to_ip_server);
-		if (rc != RC_OK)
-		{
-			rc = RC_OUT_OF_MEMORY;
-			break;
-		}
+		for (i=0;i<MAX_DNS_SERVER;i++) {
 
-		p_self->info.my_ip_address.name[ip_store]=safe_malloc(DYNDNS_MY_IP_ADDRESS_LENGTH);
-		p_self->info.my_ip_address.name[ip_4]=safe_malloc(DYNDNS_MY_IP_ADDRESS_LENGTH);
-		p_self->info.my_ip_address.name[ip_6]=safe_malloc(DYNDNS_MY_IP_ADDRESS_LENGTH);
+			rc = http_client_construct(&p_self->info[i].http_to_ip_server);
+			if (rc != RC_OK)
+			{
+				rc = RC_OUT_OF_MEMORY;
+				break;
+			}
 
-		http_to_ip_constructed = TRUE;
+			rc = http_client_construct(&p_self->info[i].http_to_dyndns);
+			if (rc != RC_OK)
+			{
+				rc = RC_OUT_OF_MEMORY;
+				break;
+			}
 
-		rc = http_client_construct(&p_self->http_to_dyndns);
-		if (rc != RC_OK)
-		{
-			rc = RC_OUT_OF_MEMORY;
-			break;
+			p_self->info[i].i_face.my_ip_address.name[ip_store]=safe_malloc(DYNDNS_MY_IP_ADDRESS_LENGTH);
+			p_self->info[i].i_face.my_ip_address.name[ip_4]=safe_malloc(DYNDNS_MY_IP_ADDRESS_LENGTH);
+			p_self->info[i].i_face.my_ip_address.name[ip_6]=safe_malloc(DYNDNS_MY_IP_ADDRESS_LENGTH);
+
+			p_self->info[i].credentials.p_enc_usr_passwd_buffer = NULL;
 		}
+
+		http_to_ip_constructed = TRUE;
 		http_to_dyndns_constructed = TRUE;
 
 		(p_self)->cmd = NO_CMD;
@@ -1803,8 +1850,6 @@
 		(p_self)->total_iterations = DYNDNS_DEFAULT_ITERATIONS;
 		(p_self)->initialized = FALSE;
 
-		p_self->info.credentials.p_enc_usr_passwd_buffer = NULL;
-
 		p_self->lang_file = NULL;
 
 	}
@@ -1824,25 +1869,33 @@
 		{
 			free (p_self->p_work_buffer);
 		}
-		if (http_to_dyndns_constructed)
-		{
-			http_client_destruct(&p_self->http_to_dyndns);
-		}
-		if (http_to_ip_constructed)
-		{
-			http_client_destruct(&p_self->http_to_ip_server);
-		}
-		if (p_self->info.my_ip_address.name[ip_store])
-		{
-			free(p_self->info.my_ip_address.name[ip_store]);
-		}
-		if (p_self->info.my_ip_address.name[ip_4])
 		{
-			free(p_self->info.my_ip_address.name[ip_4]);
+			for (i=0;i<MAX_DNS_SERVER;i++) {
+
+				http_client_destruct(&p_self->info[i].http_to_dyndns);
+			}
 		}
-		if (p_self->info.my_ip_address.name[ip_6])
 		{
-			free(p_self->info.my_ip_address.name[ip_6]);
+			for (i=0;i<MAX_DNS_SERVER;i++) {
+
+				http_client_destruct(&p_self->info[i].http_to_ip_server);
+			}
+
+			for (i=0;i<MAX_DNS_SERVER;i++) {
+
+				if (p_self->info[i].i_face.my_ip_address.name[ip_store])
+				{
+					free(p_self->info[i].i_face.my_ip_address.name[ip_store]);
+				}
+				if (p_self->info[i].i_face.my_ip_address.name[ip_4])
+				{
+					free(p_self->info[i].i_face.my_ip_address.name[ip_4]);
+				}
+				if (p_self->info[i].i_face.my_ip_address.name[ip_6])
+				{
+					free(p_self->info[i].i_face.my_ip_address.name[ip_6]);
+				}
+			}
 		}
 	}
 
@@ -1855,7 +1908,10 @@
 */	
 RC_TYPE dyn_dns_destruct(DYN_DNS_CLIENT *p_self)
 {
-	RC_TYPE rc;
+	char	i;
+	char	ii;
+
+
 	if (p_self == NULL)
 	{
 		return RC_OK;
@@ -1866,15 +1922,51 @@
 		dyn_dns_shutdown(p_self);
 	}
 
-	rc = http_client_destruct(&p_self->http_to_ip_server);
-	if (rc != RC_OK)
-	{
+	free(p_self->ip_server_name_global.name);
+	p_self->ip_server_name_global.name=NULL;
+	free(p_self->ip_server_name_global.url);
+	p_self->ip_server_name_global.url=NULL;
 
-	}
+	for (i=0;i<MAX_DNS_SERVER;i++) {
 
-	rc = http_client_destruct(&p_self->http_to_dyndns);
-	if (rc != RC_OK)
-	{
+		http_client_destruct(&p_self->info[i].http_to_ip_server);
+		http_client_destruct(&p_self->info[i].http_to_dyndns);
+
+		free(p_self->info[i].i_face.my_ip_address.name[ip_store]);
+		p_self->info[i].i_face.my_ip_address.name[ip_store]=NULL;
+
+		free(p_self->info[i].i_face.my_ip_address.name[ip_4]);
+		p_self->info[i].i_face.my_ip_address.name[ip_4]=NULL;
+
+		free(p_self->info[i].i_face.my_ip_address.name[ip_6]);
+		p_self->info[i].i_face.my_ip_address.name[ip_6]=NULL;
+
+		free(p_self->info[i].credentials.p_enc_usr_passwd_buffer);
+		p_self->info[i].credentials.p_enc_usr_passwd_buffer=NULL;
+
+		free(p_self->info[i].credentials.my_username);
+		p_self->info[i].credentials.my_username=NULL;
+
+		free(p_self->info[i].credentials.my_password);
+		p_self->info[i].credentials.my_password=NULL;
+
+		free(p_self->info[i].dyndns_server_name.url);
+		p_self->info[i].dyndns_server_name.url=NULL;
+
+		free(p_self->info[i].proxy_server_name.name);
+		p_self->info[i].proxy_server_name.name=NULL;
+
+		free(p_self->info[i].ip_server_name.name);
+		p_self->info[i].ip_server_name.name=NULL;
+
+		free(p_self->info[i].ip_server_name.url);
+		p_self->info[i].ip_server_name.url=NULL;
+
+		for (ii=0;ii<p_self->info[i].alias_info.count;ii++) {
+
+			free(p_self->info[i].alias_info.names[ii].name);
+			p_self->info[i].alias_info.names[ii].name=NULL;
+		}
 
 	}
 
@@ -1890,11 +1982,6 @@
 		p_self->p_req_buffer = NULL;
 	}
 
-	if (p_self->info.credentials.p_enc_usr_passwd_buffer != NULL)
-	{
-		free(p_self->info.credentials.p_enc_usr_passwd_buffer);
-		p_self->info.credentials.p_enc_usr_passwd_buffer = NULL;
-	}
 
 	if (p_self->lang_file != NULL)
 	{
@@ -1922,51 +2009,6 @@
 		p_self->time_cache=NULL;
 	}
 
-	if (p_self->info.credentials.my_username != NULL)
-	{
-
-		free(p_self->info.credentials.my_username);
-		p_self->info.credentials.my_username=NULL;
-	}
-
-	if (p_self->info.credentials.my_password != NULL)
-	{
-
-		free(p_self->info.credentials.my_password);
-		p_self->info.credentials.my_password=NULL;
-	}
-
-	{
-		int i=0;
-
-
-		while (1) {
-
-			if (!(p_self->alias_info.names[i].name != NULL))
-
-				break;
-			else
-			{
-
-				free(p_self->alias_info.names[i].name);
-				p_self->alias_info.names[i].name=NULL;
-			}
-		}
-	}
-
-	if (p_self->info.ip_server_url != NULL)
-	{
-
-		free(p_self->info.ip_server_url);
-		p_self->info.ip_server_url=NULL;
-	}
-
-	if (p_self->info.dyndns_server_url != NULL)
-	{
-
-		free(p_self->info.dyndns_server_url);
-		p_self->info.dyndns_server_url=NULL;
-	}
 
 	if (p_self->external_command != NULL)
 	{
@@ -1975,40 +2017,9 @@
 		p_self->external_command=NULL;
 	}
 
-	if (p_self->info.proxy_server_name.name[ip_store] != NULL)
-	{
-
-		free(p_self->info.proxy_server_name.name[ip_store]);
-		p_self->info.proxy_server_name.name[ip_store]=NULL;
-	}
-
-	if (p_self->info.ip_server_name.name[ip_store] != NULL)
-	{
-
-		free(p_self->info.ip_server_name.name[ip_store]);
-		p_self->info.ip_server_name.name[ip_store]=NULL;
-	}
-
-	if (p_self->info.my_ip_address.name[ip_store] != NULL)
-	{
-
-		free(p_self->info.my_ip_address.name[ip_store]);
-		p_self->info.my_ip_address.name[ip_store]=NULL;
-	}
-
-	if (p_self->info.my_ip_address.name[ip_4] != NULL)
-	{
-
-		free(p_self->info.my_ip_address.name[ip_4]);
-		p_self->info.my_ip_address.name[ip_4]=NULL;
-	}
-
-	if (p_self->info.my_ip_address.name[ip_6] != NULL)
-	{
+	free(p_self->p_pidfilename);
+	p_self->p_pidfilename = NULL;
 
-		free(p_self->info.my_ip_address.name[ip_6]);
-		p_self->info.my_ip_address.name[ip_6]=NULL;
-	}
 
 	free(p_self);
 	p_self = NULL;
@@ -2080,12 +2091,12 @@
 	return RC_OK;
 }
 
-static RC_TYPE do_handle_bad_config(DYN_DNS_CLIENT *p_self,int i)
+static RC_TYPE do_handle_bad_config(DYN_DNS_CLIENT *p_self,int i,char srv_cnt)
 {
 
 	/*might want to sound an error specific alert too*/
 
-	if (i<p_self->alias_info.count)
+	if (i<p_self->info[srv_cnt].alias_info.count)
 
 		DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "\n"\
 					ERROR_FLAG \
@@ -2093,7 +2104,7 @@
 					"fatal dyndns server update error for "\
 					"alias, %s.\nThis client should be stopped and corrected for "\
 					"configuration errors, and restarted...\n" \
-					ERROR_FLAG,p_self->alias_info.names[i].name));
+					ERROR_FLAG,p_self->info[srv_cnt].alias_info.names[i].name));
 	else
 
 		DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "\n"\
@@ -2107,21 +2118,21 @@
 	return RC_ERROR;
 }
 
-static RC_TYPE dyn_dns_handle_bad_config(DYN_DNS_CLIENT *p_self)
+static RC_TYPE dyn_dns_handle_bad_config(DYN_DNS_CLIENT *p_self,char srv_cnt)
 {
 
 	/*ip update subsequent dns server return bad config related error*/
 
 	int	i;
 
-	for (i=0;i<p_self->alias_info.count;i++) {
+	for (i=0;i<p_self->info[srv_cnt].alias_info.count;i++) {
 
-		if (p_self->alias_info.fatal_error[i])
+		if (p_self->info[srv_cnt].alias_info.fatal_error[i])
 
 			break;
 	}
 
-	return do_handle_bad_config(p_self,i);
+	return do_handle_bad_config(p_self,i,srv_cnt);
 }
 
 /*
@@ -2134,7 +2145,7 @@
 		- get the current DYN DNS address from DYN DNS server
 		- compare and update if neccessary
 */
-RC_TYPE dyn_dns_update_ip(DYN_DNS_CLIENT *p_self)
+RC_TYPE dyn_dns_update_ip(DYN_DNS_CLIENT *p_self,char srv_cnt)
 {
 
 	RC_TYPE		rc=RC_ERROR;
@@ -2149,9 +2160,9 @@
 		return RC_INVALID_POINTER;
 	}
 
-	if (p_self->is_bad_config)
+	if (p_self->is_global_bad_config)
 
-		return dyn_dns_handle_bad_config(p_self);
+		return dyn_dns_handle_bad_config(p_self,srv_cnt);
 
 	do
 	{
@@ -2164,7 +2175,7 @@
 
 				if ((is_exit=(p_self->net_retries<net_attempts++))) {
 
-					is_update_pending=true;
+					p_self->info[srv_cnt].is_update_pending=true;					
 
 					break;
 				}
@@ -2174,7 +2185,7 @@
 			else {
 
 				/*ask IP server something so will respond and give me my IP */
-				rc = check_my_ip_address(p_self);
+				rc = check_my_ip_address(p_self,srv_cnt);
 
 				if (rc==RC_OK)
 
@@ -2184,7 +2195,7 @@
 
 				if (p_self->net_retries<ip_attempts++) {
 
-					is_update_pending=true;
+					p_self->info[srv_cnt].is_update_pending=true;
 
 					break;
 				}
@@ -2211,7 +2222,7 @@
 			DBG_PRINTF((LOG_INFO,"I:DYNDNS: dyn_dns_update_ip checking alias table...\n"));
 
 			/*step through aliases list, resolve them and check if they point to my IP*/
-			rc = do_check_alias_update_table(p_self);
+			rc = do_check_alias_update_table(p_self,srv_cnt);
 			if (rc != RC_OK)
 			{
 				break;
@@ -2227,7 +2238,7 @@
 
 					if (p_self->net_retries<net_attempts++) {
 
-						is_update_pending=true;
+						p_self->info[srv_cnt].is_update_pending=true;
 
 						break;
 					}
@@ -2237,11 +2248,13 @@
 				else {
 
 					/*update IPs marked as not identical with my IP*/
-					rc = do_update_alias_table(p_self,&is_forced_update_reset);
+					rc = do_update_alias_table(p_self,&is_forced_update_reset,srv_cnt);
 
 					if (rc==RC_OK) {
 
-						is_update_pending=false;
+						p_self->info[srv_cnt].is_update_pending=false;
+
+						p_self->info[srv_cnt].is_bad_config=false;
 
 						break;
 					}
@@ -2250,14 +2263,18 @@
 
 					if (p_self->net_retries<ip_attempts++) {
 
-						is_update_pending=(!(rc==RC_DYNDNS_RSP_CONFIG));						
+						p_self->info[srv_cnt].is_update_pending=(!(rc==RC_DYNDNS_RSP_CONFIG));
+
+						p_self->info[srv_cnt].is_bad_config=!(p_self->info[srv_cnt].is_update_pending);
 						
 						break;
 					}
 
 					if (rc==RC_DYNDNS_RSP_CONFIG) { /*might want to trigger alert here*/
 
-						is_update_pending=false;
+						p_self->info[srv_cnt].is_update_pending=false;
+
+						p_self->info[srv_cnt].is_bad_config=false;
 
 						break;
 					}
@@ -2875,7 +2892,7 @@
 
 
 	*p_ras_thread_data=construct_and_launch_trap_ras_events(dyn_dns_update_ip_handler,p_dyndns,p_dyndns->\
-		                   http_to_ip_server.super.super.p_remote_host_name,\
+		                   info[0].http_to_ip_server.super.super.p_remote_host_name,\
 		                   p_dyndns->dbg.level);
 
 	if (*p_ras_thread_data) {
@@ -2913,20 +2930,6 @@
 	*src+=inc;
 }
 
-RC_TYPE dyn_dns_reinit(DYN_DNS_CLIENT *p_dyndns)
-{
-
-	RC_TYPE		rc=RC_OK;
-
-
-	dyn_dns_shutdown(p_dyndns);
-
-	rc=do_dyn_dns_init(p_dyndns);
-
-
-	return rc;
-}
-
 /*find the alias given by parameter alias in list of p_dyndns structure alias names and set
   correponding update state boolean to parameter is_updated
 
@@ -2939,6 +2942,7 @@
 {
 
 	int		i;
+	int		ii;
 	char	*alias_in=NULL;
 	char	*alias_ip_v=alias;
 	char	*p_alias_ip_v=NULL;
@@ -2973,39 +2977,42 @@
 		is_auto=true;
 	}
 
-	for (i=0;i<p_dyndns->alias_info.count;i++) {
+	for (ii=0;ii<p_dyndns->srv_cnt;ii++) {
 
-		/*add ip type [auto,coupled,ip6,ip4] to name[i].name to do compare*/
+		for (i=0;i<p_dyndns->info[ii].alias_info.count;i++) {
 
-		alias_cmp_src=safe_malloc(strlen(p_dyndns->alias_info.names[i].name)+9);
-		strcat(strcat(strcpy(alias_cmp_src,p_dyndns->alias_info.names[i].name),":"),p_dyndns->alias_info.names[i].ip_v);
+			/*add ip type [auto,coupled,ip6,ip4] to name[i].name to do compare*/
 
-		if (!(strcmp(alias_cmp_src,alias_ip_v)) || (strstr(p_dyndns->alias_info.names[i].ip_v,DUAL_LIST) 
-			&& !(strcmp(p_dyndns->alias_info.names[i].name,alias_in)))) {
+			alias_cmp_src=safe_malloc(strlen(p_dyndns->info[ii].alias_info.names[i].name)+9);
+			strcat(strcat(strcpy(alias_cmp_src,p_dyndns->info[ii].alias_info.names[i].name),":"),p_dyndns->info[ii].alias_info.names[i].ip_v);
 
-			p_dyndns->alias_info.update_succeeded[i]=is_updated;
+			if (!(strcmp(alias_cmp_src,alias_ip_v)) || (strstr(p_dyndns->info[ii].alias_info.names[i].ip_v,DUAL_LIST) 
+				&& !(strcmp(p_dyndns->info[ii].alias_info.names[i].name,alias_in)))) {
 
-			is_found=true;
-		}
-		else {
+				p_dyndns->info[ii].alias_info.update_succeeded[i]=is_updated;
+
+				is_found=true;
+			}
+			else {
 
-			/*for aliases of type auto, set update state for either ip6, ip4*/
+				/*for aliases of type auto, set update state for either ip6, ip4*/
 
-			if (is_auto)
+				if (is_auto)
 
-				if (!(strcmp(p_dyndns->alias_info.names[i].name,alias_in))) {
+					if (!(strcmp(p_dyndns->info[ii].alias_info.names[i].name,alias_in))) {
 
-					p_dyndns->alias_info.update_succeeded[i]=is_updated;
+						p_dyndns->info[ii].alias_info.update_succeeded[i]=is_updated;
 
-					is_found=true;
-				}
-		}
+						is_found=true;
+					}
+			}
 
-		free(alias_cmp_src);
+			free(alias_cmp_src);
 
-		if (is_found)
+			if (is_found)
 
-			break;
+				break;
+		}
 	}
 
 	free(p_alias_ip_v);
@@ -3029,9 +3036,9 @@
 
 		char	ch;
 		char	*in_str[DYNDNS_MAX_ALIAS_NUMBER*2]; /*multiply for dual alias type*/
-		int		i=0;
-		int		line_count=0;
-		int		max_len=256;
+		int	i=0;
+		int	line_count=0;
+		int	max_len=256;
 		BOOL	is_rewrite=false;
 
 		in_str[line_count]=safe_malloc(max_len);
@@ -3129,11 +3136,30 @@
 	return rc;
 }
 
+int number_of_aliases(DYN_DNS_CLIENT *p_dyndns)
+{
+	char	i;
+	int		alias_count=0;
+
+
+	for (i=0;i<MAX_DNS_SERVER;i++) {
+
+		alias_count+=p_dyndns->info[i].alias_info.count;
+	}
+
+	return alias_count;
+}
+
 /*  Record the last ip as per that in ip cache file.  Report it via log output.
 
 	Set update need for each space separated ip, alias pair line read.  
 	
 	Set global is_update_pending if number of aliases read less than p_dyndns->alias_info.count.
+
+	Multiple servers patch moving in direction of providing for multiple ip interfaces as well.
+	So far, this patch provides for multiple instances of stored reference ip -- one per dyndns 
+	server.  Here, we'll update all of them to the same ip, since we're not yet providing for
+	multiple interfaces.
 */
 
 RC_TYPE check_ip_cache(DYN_DNS_CLIENT *p_dyndns)
@@ -3145,6 +3171,7 @@
 
 	fp=utf_fopen(p_dyndns->ip_cache,"r");
 
+
 	if (fp)	{
 
 		char	ch;
@@ -3181,13 +3208,18 @@
 
 					/*redundant for multi-aliases.  and aliases needing update won't be here*/
 
-					if (strstr(in_str,".")) {
+					char i;
 
-						strcpy(p_dyndns->info.my_ip_address.name[ip_4],in_str);
-					}
-					else {
+					for (i=0;i<MAX_DNS_SERVER;i++) {
+
+						if (strstr(in_str,".")) {
+
+							strcpy(p_dyndns->info[i].i_face.my_ip_address.name[ip_4],in_str);
+						}
+						else {
 
-						strcpy(p_dyndns->info.my_ip_address.name[ip_6],in_str);
+							strcpy(p_dyndns->info[i].i_face.my_ip_address.name[ip_6],in_str);
+						}
 					}
 				}
 				else { /*alias*/
@@ -3209,17 +3241,21 @@
 			}
 		}
 
-		is_update_pending=(alias_count<p_dyndns->alias_info.count);
+		is_global_update_pending=(alias_count<number_of_aliases(p_dyndns));
 
 		fclose(fp);
 
-		if (strlen(p_dyndns->info.my_ip_address.name[ip_4]))
+/*
+	see function comments above concerning multiple server/multiple ip present circumstances, and plans -- this section here, will
+	need to be changed accordingly.
+*/
+		if (strlen(p_dyndns->info[0].i_face.my_ip_address.name[ip_4]))
 
-			DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "IPv4 address read from cache file (%s):  '%s'...\n",p_dyndns->ip_cache, p_dyndns->info.my_ip_address.name[ip_4]));
+			DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "IPv4 address read from cache file (%s):  '%s'...\n",p_dyndns->ip_cache, p_dyndns->info[0].i_face.my_ip_address.name[ip_4]));
 
-		if (strlen(p_dyndns->info.my_ip_address.name[ip_6]))
+		if (strlen(p_dyndns->info[0].i_face.my_ip_address.name[ip_6]))
 
-			DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "IPv6 address read from cache file (%s):  '%s'...\n",p_dyndns->ip_cache, p_dyndns->info.my_ip_address.name[ip_6]));
+			DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "IPv6 address read from cache file (%s):  '%s'...\n",p_dyndns->ip_cache, p_dyndns->info[0].i_face.my_ip_address.name[ip_6]));
 
 		free(in_str);
 	}
@@ -3412,6 +3448,35 @@
 		}
 	}
 
+	/*if pid-file wanted, create it*/
+	if (p_dyndns->p_pidfilename) {
+		
+		if (strlen(p_dyndns->p_pidfilename) != 0)
+		{
+			FILE *fp=NULL;
+			int obj=0;
+			char pid[7];
+
+
+			if ((fp = utf_fopen(p_dyndns->p_pidfilename, "w")))
+			{
+
+#ifndef _WIN32
+				if (0<snprintf(pid, 7, "%d\n", getpid()))
+#else
+				if (0<_snprintf(pid, 7, "%d\n", _getpid()))
+#endif
+					obj = fwrite(pid, strlen(pid), 1, fp);
+
+				fclose(fp);
+			}
+			if (!fp || obj != 1)
+			{
+				return RC_FILE_IO_OPEN_ERROR;
+			}
+		}
+	}
+
 	dyn_dns_print_hello(NULL);
 
 	/*  now that log is open, report any command line errors eventhough registry params made up for them --
@@ -3444,7 +3509,18 @@
 
 	if (rc==RC_OK) {
 
-		rc = get_encoded_user_passwd(p_dyndns);
+		char	i;
+		RC_TYPE	pw_rc;
+
+
+		for (i=0;i<p_dyndns->srv_cnt;i++) {
+
+			if (!(RC_OK==(pw_rc=get_encoded_user_passwd(p_dyndns,i))))
+
+				if (rc==RC_OK) /*return first of any error(s)*/
+
+					rc=pw_rc;
+		}
 
 #ifdef _WIN32
 
@@ -3492,6 +3568,9 @@
 	RC_TYPE				rc=RC_OK;
 	BOOL				init_flag=FALSE;
 	int					current_iteration=0;
+	char				bad_config_count;
+	char				i;
+	int					success_count;
 
 #ifdef _WIN32
 
@@ -3513,23 +3592,45 @@
 
 		do
 		{
+			/*state across multiple server updates*/
+			bad_config_count=0;
+			is_global_success_updates=false; /*flagged in update_update_state*/
+			is_global_in_proc_update_pending=false;			
+			success_count=0;
 
-			/*update IP address in a loop*/
-			
-			if (((rc=dyn_dns_update_ip(p_dyndns))==RC_OK))
+			for (i=0;i<p_dyndns->srv_cnt;i++) {
 
-				increment_iterations(p_dyndns);
+				if (p_dyndns->cmd==CMD_STOP)
 
-			else {
+					break;
 
-				DBG_PRINTF((LOG_WARNING,"W:'%s' (0x%x) updating the IPs. (it %d)\n",
-					        errorcode_get_name(rc), rc, current_iteration));
+				if (((rc=dyn_dns_update_ip(p_dyndns,i))==RC_OK))
 
-				p_dyndns->is_bad_config=(rc==RC_DYNDNS_RSP_CONFIG);
+					success_count++;
 
-				rc=dyn_dns_reinit(p_dyndns);
+				else {
+
+					DBG_PRINTF((LOG_WARNING,"W:'%s' (0x%x) updating the IPs. (it %d)\n",
+								errorcode_get_name(rc), rc, current_iteration));
+
+					if (p_dyndns->info[i].is_bad_config)
+
+						bad_config_count++;
+				}
+
+				is_global_in_proc_update_pending=(is_global_in_proc_update_pending || p_dyndns->info[i].is_update_pending);
 			}
 
+			is_global_update_pending=is_global_in_proc_update_pending;
+
+			/*bad config all aliases for all servers?*/
+			p_dyndns->is_global_bad_config=(bad_config_count==p_dyndns->srv_cnt);
+
+			if (success_count==p_dyndns->srv_cnt)
+
+				increment_iterations(p_dyndns);
+
+
 #ifdef USE_SNDFILE
 
 #ifndef USE_THREADS
@@ -3539,8 +3640,7 @@
 
 #endif
 
-			if (p_dyndns->cmd==CMD_STOP)
-			{
+			if (p_dyndns->cmd==CMD_STOP) {
 
 				DBG_PRINTF((LOG_DEBUG,"D:" MODULE_TAG "STOP command received. Exiting.\n"));
 
@@ -3553,15 +3653,6 @@
 
 				break;
 			} 
-			else {
-
-				if (!(rc==RC_OK)) {
-
-					init_flag=false;
-
-					break;
-				}
-			}
 
 			/* sleep the time set in the ->sleep_sec data memeber*/
 			dyn_dns_wait_for_cmd(p_dyndns);
@@ -3570,8 +3661,8 @@
 			inc_update_times(p_dyndns,&(p_dyndns->times_since_last_update),1);
 
 			/*reset the command*/
-			if (!(p_dyndns->cmd==CMD_STOP))
-			{
+			if (!(p_dyndns->cmd==CMD_STOP))	{
+
 				p_dyndns->cmd=NO_CMD;
 			}
 			else {
@@ -3602,8 +3693,8 @@
 #endif
 
 
-	if (init_flag)
-	{
+	if (init_flag) {
+
 		/* dyn_dns_shutdown object */
 		rc = dyn_dns_shutdown(p_dyndns);
 	}
Only in inadyn-mt.v.02.24.38-ms-pid-04/src: dyndns.c~
diff -ur inadyn-mt.v.02.24.38/src/dyndns.h inadyn-mt.v.02.24.38-ms-pid-04/src/dyndns.h
--- src/dyndns.h
+++ src/dyndns.h
@@ -75,7 +75,7 @@
 
 #endif
 
-#define	DYNDNS_EXTRA_VERSION
+#define	DYNDNS_EXTRA_VERSION	"-ms_pid_patch_04"
 
 #define DYNDNS_VERSION_STRING	"02.24.38" DYNDNS_VERSION_SND DYNDNS_VERSION_THD DYNDNS_EXTRA_VERSION
 #define DYNDNS_AGENT_NAME		"inadyn-mt/" DYNDNS_VERSION_STRING
@@ -360,6 +360,8 @@
 #define DUAL_LIST			"coupled"
 #define MAX_IP_TYPE_SIZE	8
 
+#define MAX_DNS_SERVER		10
+
 /* typedefs */
 struct _DYN_DNS_CLIENT;
 struct DYNDNS_SYSTEM;
@@ -369,8 +371,8 @@
 /** Function to prepare DNS system specific server requests
 */
 
-typedef int (*DNS_SYSTEM_REQUEST_FUNC)(struct _DYN_DNS_CLIENT *this, int nr, struct DYNDNS_SYSTEM *p_sys_info);
-typedef int (*DNS_SYSTEM_SRV_RESPONSE_OK_FUNC)(struct _DYN_DNS_CLIENT *this, char *p_rsp, const char*p_ok_str);
+typedef int (*DNS_SYSTEM_REQUEST_FUNC)(struct _DYN_DNS_CLIENT *this, char srv_cnt, int nr, struct DYNDNS_SYSTEM *p_sys_info);
+typedef int (*DNS_SYSTEM_SRV_RESPONSE_OK_FUNC)(struct _DYN_DNS_CLIENT *this, char *p_rsp, const char*p_ok_str,char srv_cnt);
 typedef int (*DNS_SYSTEM_SRV_RESPONSE_CONFIG_FUNC)(struct _DYN_DNS_CLIENT *this, char *p_rsp);
 typedef struct
 {
@@ -432,10 +434,17 @@
 
 typedef struct 
 {
-	char *name[3];
+	char *name;
+	char *url;
 	int port;
 } DYNDNS_SERVER_NAME;
 
+typedef struct 
+{
+	char *name[3];
+	int port;
+} DYNDNS_MY_IP;
+
 /*a given alias (dyn domain names) can
   be associated with one "ip type", of
   'dual', 'coupled', 'ip4', 'ip6', 'auto',
@@ -454,12 +463,20 @@
 
 typedef struct 
 {
-    BOOL my_ip_has_changed[3];
-	BOOL is_update_ip4;
-	BOOL is_update_ip6;
-	BOOL is_update_auto;
-	BOOL is_got_ip4;
-	BOOL is_got_ip6;
+	/*multiple of ip types (2 -- IPv4, IPv6)*/
+	DYNDNS_ALIAS_NAME names[DYNDNS_MAX_ALIAS_NUMBER*2];	
+	int update_required[DYNDNS_MAX_ALIAS_NUMBER*2];
+	int update_succeeded[DYNDNS_MAX_ALIAS_NUMBER*2];
+	int fatal_error[DYNDNS_MAX_ALIAS_NUMBER*2];
+	DYNDNS_HASH_TYPE hashes[DYNDNS_MAX_ALIAS_NUMBER*2]; 
+	int count;
+	int count_dual;
+} DYNDNS_ALIAS_INFO;
+
+typedef struct
+{
+    
+	BOOL my_ip_has_changed[3];
 
 	/*3 strings - ip_4, ip_6 address,
 	  and temp store, ip_store for
@@ -469,28 +486,33 @@
 	  convenient) -- for instance, 
 	  ip type "auto" (based on first 
 	  address returned by ip server)*/
-	DYNDNS_SERVER_NAME my_ip_address;
+	DYNDNS_MY_IP my_ip_address;
+} DYNDNS_IFACE_INFO;
+
+/*per update server*/
+typedef struct 
+{
+	BOOL is_update_ip4;
+	BOOL is_update_ip6;
+	BOOL is_update_auto;
+	BOOL is_got_ip4;
+	BOOL is_got_ip6;
+
+	HTTP_CLIENT			http_to_ip_server;
+	HTTP_CLIENT			http_to_dyndns;
+
+	DYNDNS_IFACE_INFO	i_face;
 
 	DYNDNS_CREDENTIALS credentials;
 	DYNDNS_SYSTEM *p_dns_system;
 	DYNDNS_SERVER_NAME dyndns_server_name;
-	char *dyndns_server_url;
 	DYNDNS_SERVER_NAME ip_server_name;
-	char *ip_server_url;
 	DYNDNS_SERVER_NAME proxy_server_name;
-} DYNDNS_INFO_TYPE;
 
-typedef struct 
-{
-	/*multiple of ip types (2 -- IPv4, IPv6)*/
-	DYNDNS_ALIAS_NAME names[DYNDNS_MAX_ALIAS_NUMBER*2];	
-	int update_required[DYNDNS_MAX_ALIAS_NUMBER*2];
-	int update_succeeded[DYNDNS_MAX_ALIAS_NUMBER*2];
-	int fatal_error[DYNDNS_MAX_ALIAS_NUMBER*2];
-	DYNDNS_HASH_TYPE hashes[DYNDNS_MAX_ALIAS_NUMBER*2]; 
-	int count;
-	int count_dual;
-} DYNDNS_ALIAS_INFO;
+	DYNDNS_ALIAS_INFO	alias_info;
+	BOOL is_bad_config;
+	BOOL is_update_pending;
+} DYNDNS_INFO_TYPE;
 
 typedef struct
 {
@@ -533,8 +555,6 @@
 	BOOL		debug_to_syslog;
 	BOOL		change_persona;
 
-	HTTP_CLIENT			http_to_ip_server;
-	HTTP_CLIENT			http_to_dyndns;
 	HTTP_TRANSACTION	http_tr;
 	char				*p_work_buffer;		/* for HTTP responses*/
 	int					work_buffer_size;
@@ -544,20 +564,25 @@
 	char				*time_cache;
 	char				*ip_cache;
 
+	USER_INFO			sys_usr_info;			/*info about the current account running inadyn*/
 
-	USER_INFO			sys_usr_info;		/*info about the current account running inadyn*/
-	DYNDNS_INFO_TYPE	info;				/*servers, names, passwd*/
-	DYNDNS_INFO_TYPE	info_online_status;	/*info about url to reach to confirm online status -- defaults to info*/
 
-	DYNDNS_ALIAS_INFO	alias_info;
+
+	DYNDNS_INFO_TYPE	info[MAX_DNS_SERVER];	/*servers, names, passwd*/
+	char				srv_cnt;
+
+	DYNDNS_SERVER_NAME	info_online_status;		/*info about url to reach to confirm online status -- defaults to info*/
 
 	BOOL				abort_on_network_errors;
 	BOOL				force_addr_update;
 	BOOL				use_proxy;
 	BOOL				abort;
 	BOOL				wildcard;
-	BOOL				is_bad_config;
+	BOOL				is_global_bad_config; /*all servers*/
+
+	DYNDNS_SERVER_NAME ip_server_name_global;
 
+	char *p_pidfilename;
 	/*dbg*/
 	DBG_TYPE			dbg;
 } DYN_DNS_CLIENT;
@@ -633,7 +658,7 @@
 		- compare and update if neccessary
 */
 
-RC_TYPE dyn_dns_update_ip(DYN_DNS_CLIENT *p_self);
+RC_TYPE dyn_dns_update_ip(DYN_DNS_CLIENT *p_self,char srv_cnt);
 
 /* MAIN - Dyn DNS update entry point.*/
 
Only in inadyn-mt.v.02.24.38-ms-pid-04/src: dyndns.h~
diff -ur inadyn-mt.v.02.24.38/src/errorcode.c inadyn-mt.v.02.24.38-ms-pid-04/src/errorcode.c
--- src/errorcode.c
+++ src/errorcode.c
@@ -56,6 +56,7 @@
         {RC_HTTP_OBJECT_NOT_INITIALIZED,"RC_HTTP_OBJECT_NOT_INITIALIZED"},
         {RC_HTTP_BAD_PARAMETER,"RC_HTTP_BAD_PARAMETER"},
 
+		{RC_DYNDNS_TOO_MANY_SERVERS,"RC_DYNDNS_TOO_MANY_SERVERS"},
 		{RC_DYNDNS_INVALID_IP_ADDR,"RC_DYNDNS_INVALID_IP_ADDR"},
         {RC_DYNDNS_BUFFER_TOO_SMALL,"RC_DYNDNS_BUFFER_TOO_SMALL"},
         {RC_DYNDNS_INVALID_IP_ADDR_IN_HTTP_RESPONSE,"RC_DYNDNS_INVALID_IP_ADDR_IN_HTTP_RESPONSE"},
diff -ur inadyn-mt.v.02.24.38/src/errorcode.h inadyn-mt.v.02.24.38-ms-pid-04/src/errorcode.h
--- src/errorcode.h
+++ src/errorcode.h
@@ -46,6 +46,7 @@
     RC_HTTP_OBJECT_NOT_INITIALIZED				= 0x30,
     RC_HTTP_BAD_PARAMETER						= 0x31,
 
+	RC_DYNDNS_TOO_MANY_SERVERS					= 0x38,
 	RC_DYNDNS_INVALID_IP_ADDR					= 0x39,
     RC_DYNDNS_BUFFER_TOO_SMALL					= 0x40,
     RC_DYNDNS_INVALID_IP_ADDR_IN_HTTP_RESPONSE	= 0x41,
diff -ur inadyn-mt.v.02.24.38/src/inadyn_cmd.c inadyn-mt.v.02.24.38-ms-pid-04/src/inadyn_cmd.c
--- src/inadyn_cmd.c
+++ src/inadyn_cmd.c
@@ -72,6 +72,7 @@
 static RC_TYPE get_dns_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_dns_server_url_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_ip_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
+static RC_TYPE get_global_ip_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_online_check_url_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_dyndns_system_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_update_period_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
@@ -85,6 +86,7 @@
 #endif
 
 static RC_TYPE get_logfile_name(CMD_DATA *p_cmd, int current_nr, void *p_context);
+static RC_TYPE get_pidfile_name(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE set_silent_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE set_verbose_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_proxy_server_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
@@ -120,6 +122,13 @@
 
 #endif
 
+/*
+	muti-services -- inc or set index based on
+	most recent server name option parameter
+	appearance.
+*/
+static server_index=0;
+
 static CMD_DESCRIPTION_TYPE cmd_options_table[] =
     {
         {"--help",		0,	{help_handler, NULL,0},	"help" },
@@ -160,6 +169,10 @@
          "<srv_name[:port] local_url> - local IP is detected by parsing the response after returned by this server and URL.  "\
          "The first IP in found http response is considered 'my IP'."},
 
+         {"--ip_server_name_global",	2,	{get_global_ip_server_name_handler, NULL,0},
+         "<srv_name[:port] local_url> - local IP is detected by parsing the response after returned by this server and URL.  "\
+         "The first IP in found http response is considered 'my IP'.  Same as ip_server_name option, but overrides unchanged dyndns_system default ip servers."},
+
         {"--online_check_url",	2,	{get_online_check_url_handler, NULL,0},
          "<srv_name[:port] local_url> - URL to reach to confirm online status.  "\
          "Default value:  " DYNDNS_MY_ONLINE_CHECK " /"},
@@ -203,6 +216,7 @@
 #endif
 
         {"--log_file",	1,	{get_logfile_name, NULL,0},		"<path/file> - log file path and name"},
+        {"--pid_file",	1,	{get_pidfile_name, NULL,0},		"pid file path and name"},
         {"--background", 0,	{set_silent_handler, NULL,0},		"run in background. output to log file or to syslog"},
 
 		{"--verbose",	1,	{set_verbose_handler, NULL,0},	"<#> - set dbg level. 0 to 5"},
@@ -257,6 +271,22 @@
         {NULL,		0,	{0, NULL,0},	"" }
     };
 
+static RC_TYPE get_pidfile_name(CMD_DATA *p_cmd, int current_nr, void *p_context)
+{
+	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
+	if (p_self == NULL)
+	{
+		return RC_INVALID_POINTER;
+	}
+
+	p_self->p_pidfilename = (char *) safe_malloc(strlen(p_cmd->argv[current_nr]) + 1);
+	if (p_self->p_pidfilename == NULL)
+	{
+		return  RC_OUT_OF_MEMORY;
+	}
+	strcpy(p_self->p_pidfilename, p_cmd->argv[current_nr]);
+	return RC_OK;
+}
 
 void print_help_page(void)
 {
@@ -398,15 +428,15 @@
 		return RC_INVALID_POINTER;
 	}
 
-	if (p_self->info.credentials.my_username) {
+	if (p_self->info[server_index].credentials.my_username) {
 
-		free(p_self->info.credentials.my_username);
+		free(p_self->info[server_index].credentials.my_username);
 	}
 
 	/*user*/
-	p_self->info.credentials.my_username=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
+	p_self->info[server_index].credentials.my_username=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
 
-	strcpy(p_self->info.credentials.my_username, p_cmd->argv[current_nr]);
+	strcpy(p_self->info[server_index].credentials.my_username, p_cmd->argv[current_nr]);
 
 	return RC_OK;
 }
@@ -419,14 +449,14 @@
 		return RC_INVALID_POINTER;
 	}
 
-	if (p_self->info.credentials.my_password) {
+	if (p_self->info[server_index].credentials.my_password) {
 
-		free(p_self->info.credentials.my_password);
+		free(p_self->info[server_index].credentials.my_password);
 	}
 
 	/*password*/
-	p_self->info.credentials.my_password=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
-	strcpy(p_self->info.credentials.my_password, (p_cmd->argv[current_nr]));
+	p_self->info[server_index].credentials.my_password=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
+	strcpy(p_self->info[server_index].credentials.my_password, (p_cmd->argv[current_nr]));
 	return RC_OK;
 }
 
@@ -452,7 +482,8 @@
 		return RC_INVALID_POINTER;
 	}
 
-	if (p_self->alias_info.count-p_self->alias_info.count_dual >= DYNDNS_MAX_ALIAS_NUMBER) {
+	if (p_self->info[server_index].alias_info.count-p_self->info[server_index].alias_info.count_dual 
+			>= DYNDNS_MAX_ALIAS_NUMBER) {
 
 		return RC_DYNDNS_TOO_MANY_ALIASES;
 	}
@@ -462,42 +493,46 @@
 
 	if (p_hash)	{
 
-		if (p_self->alias_info.hashes[p_self->alias_info.count].str)
+		if (p_self->info[server_index].alias_info.hashes[p_self->info[server_index].alias_info.count].str)
 
-			free(p_self->alias_info.hashes[p_self->alias_info.count].str);
+			free(p_self->info[server_index].alias_info.hashes[p_self->info[server_index].alias_info.count].str);
 
 		/*allocate and copy hash len minus comma*/
-		p_self->alias_info.hashes[p_self->alias_info.count].str=safe_malloc(strlen(p_hash));
-		strcpy(p_self->alias_info.hashes[p_self->alias_info.count].str,(p_hash+1));
+		p_self->info[server_index].alias_info.hashes[p_self->info[server_index].alias_info.count].str
+			=safe_malloc(strlen(p_hash));
+
+		strcpy(p_self->info[server_index].alias_info.hashes[p_self->info[server_index].alias_info.count].str,(p_hash+1));
 
 		alias_len=strlen(p_hash);
 	}
 	
-	if (p_self->alias_info.names[p_self->alias_info.count].name)
+	if (p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].name)
 
-		free(p_self->alias_info.names[p_self->alias_info.count].name);
+		free(p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].name);
 
 	alias_len=strlen(p_cmd->argv[current_nr])-alias_len;
 
 	/*alias*/
-	p_self->alias_info.names[p_self->alias_info.count].name=safe_malloc(alias_len+1);
-	strncpy(p_self->alias_info.names[p_self->alias_info.count].name,p_cmd->argv[current_nr],alias_len);
+	p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].name
+		=safe_malloc(alias_len+1);
+	strncpy(p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].name,
+		p_cmd->argv[current_nr],alias_len);
 
 	/*default to letting ip server determine update type*/
-	strcpy(p_self->alias_info.names[p_self->alias_info.count].ip_v,"auto");
+	strcpy(p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].ip_v,"auto");
 
-	p_self->alias_info.names[p_self->alias_info.count].ip_v_enum=ip_store;
+	p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].ip_v_enum=ip_store;
 
 	/*IPv/type*/
 	if (!(current_nr+1<p_cmd->argc)) {
 
-		p_self->info.is_update_auto=true;
+		p_self->info[server_index].is_update_auto=true;
 	}
 	else {
 
 		if (!(strncmp(p_cmd->argv[current_nr+1],"-",1))) {
 
-			p_self->info.is_update_auto=true;
+			p_self->info[server_index].is_update_auto=true;
 		}
 		else {
 
@@ -510,7 +545,7 @@
 			}
 			else {
 
-				strcpy(p_self->alias_info.names[p_self->alias_info.count].ip_v,ip_ver_str);
+				strcpy(p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].ip_v,ip_ver_str);
 
 				if (strcmp(ip_ver_str,"auto")) {
 
@@ -518,24 +553,24 @@
 
 						if (strcmp(ip_ver_str,"ip4"))
 
-							p_self->alias_info.names[p_self->alias_info.count].ip_v_enum=ip_6;
+							p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].ip_v_enum=ip_6;
 						else
-							p_self->alias_info.names[p_self->alias_info.count].ip_v_enum=ip_4;
+							p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].ip_v_enum=ip_4;
 					}
 				}
 
-				p_self->info.is_update_ip4=(p_self->info.is_update_ip4 || strstr(ip_ver_str,"ip4")
+				p_self->info[server_index].is_update_ip4=(p_self->info[server_index].is_update_ip4 || strstr(ip_ver_str,"ip4")
 					 || strstr(ip_ver_str,DUAL_LIST));
 
-				p_self->info.is_update_ip6=(p_self->info.is_update_ip6 || strstr(ip_ver_str,"ip6")
+				p_self->info[server_index].is_update_ip6=(p_self->info[server_index].is_update_ip6 || strstr(ip_ver_str,"ip6")
 					 || strstr(ip_ver_str,DUAL_LIST));
 
-				p_self->info.is_update_auto=(p_self->info.is_update_auto || strstr(ip_ver_str,"auto"));
+				p_self->info[server_index].is_update_auto=(p_self->info[server_index].is_update_auto || strstr(ip_ver_str,"auto"));
 			}
 		}
 	}
 
-	p_self->alias_info.count++;
+	p_self->info[server_index].alias_info.count++;
 
 
 	return RC_OK;
@@ -550,13 +585,13 @@
 
 	if (!(current_nr+1<p_cmd->argc)) {
 
-		p_self->info.is_update_auto=true;
+		p_self->info[server_index].is_update_auto=true;
 	}
 	else {
 
 		if (!(strncmp(p_cmd->argv[current_nr+1],"-",1))) {
 
-			p_self->info.is_update_auto=true;
+			p_self->info[server_index].is_update_auto=true;
 		}
 		else {
 
@@ -583,7 +618,7 @@
 
 		if ((RC_OK==(rc=do_get_alias_handler(p_cmd,current_nr,p_context,"ip6"))))
 
-			p_self->alias_info.count_dual++;
+			p_self->info[server_index].alias_info.count_dual++;
 	}
 
 	return rc;
@@ -611,7 +646,7 @@
         *p_dest_port = port_nr;
         len = p_port - p_src;
 
-	  *p_dest_name=safe_malloc(len);
+	  *p_dest_name=safe_malloc(len+1);
 	  memcpy(*p_dest_name, p_src, len);
 
         *(*p_dest_name+len) = '\0';
@@ -629,7 +664,7 @@
 /** Returns the svr name and port if the format is :
  * name[:port] url.
  */
-static RC_TYPE set_url_param(CMD_DATA *p_cmd, int current_nr,DYNDNS_INFO_TYPE *info)
+static RC_TYPE set_url_param(CMD_DATA *p_cmd, int current_nr,DYNDNS_SERVER_NAME *info)
 {
 	RC_TYPE rc;
     int port = -1;
@@ -640,22 +675,22 @@
 	}
 
 	/*user*/
-    info->ip_server_name.port = HTTP_DEFAULT_PORT;
+    info->port = HTTP_DEFAULT_PORT;
 
-    rc = get_name_and_port(p_cmd->argv[current_nr], &info->ip_server_name.name[ip_store], &port);
+    rc = get_name_and_port(p_cmd->argv[current_nr], &info->name, &port);
 
     if (rc == RC_OK && port != -1)
     {
-        info->ip_server_name.port = port;
+        info->port = port;
     }        
 
-    if (info->ip_server_url)
+    if (info->url)
 
-		free(info->ip_server_url);
+		free(info->url);
 
-    info->ip_server_url=safe_malloc(strlen(p_cmd->argv[current_nr + 1]) + 1);
+    info->url=safe_malloc(strlen(p_cmd->argv[current_nr + 1]) + 1);
 
-    strcpy(info->ip_server_url, p_cmd->argv[current_nr + 1]);
+    strcpy(info->url, p_cmd->argv[current_nr + 1]);
 
     return rc;
 }
@@ -663,7 +698,34 @@
 static RC_TYPE get_ip_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 
-    return set_url_param(p_cmd,current_nr,&(((DYN_DNS_CLIENT *) (p_context))->info));
+    return set_url_param(p_cmd,current_nr,&(((DYN_DNS_CLIENT *) (p_context))->info[server_index].ip_server_name));
+}
+
+static RC_TYPE get_global_ip_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
+{
+	RC_TYPE			rc;
+	DYN_DNS_CLIENT	*p_self=(DYN_DNS_CLIENT *) p_context;
+	int				i;
+
+
+    if ((RC_OK==(rc=set_url_param(p_cmd,current_nr,&p_self->ip_server_name_global)))) {
+
+		for (i=0;i<MAX_DNS_SERVER;i++) {
+
+			if (!(p_self->info[i].ip_server_name.name)) {
+
+				p_self->info[i].ip_server_name.name=safe_malloc(strlen(p_self->ip_server_name_global.name)+1);
+				strcpy(p_self->info[i].ip_server_name.name,p_self->ip_server_name_global.name);
+				
+				p_self->info[i].ip_server_name.url=safe_malloc(strlen(p_self->ip_server_name_global.url)+1);
+				strcpy(p_self->info[i].ip_server_name.url,p_self->ip_server_name_global.url);
+				
+				p_self->info[i].ip_server_name.port=p_self->ip_server_name_global.port;
+			}
+		}
+	}
+
+	return rc;
 }
 
 static RC_TYPE get_online_check_url_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
@@ -672,26 +734,112 @@
     return set_url_param(p_cmd,current_nr,&(((DYN_DNS_CLIENT *) (p_context))->info_online_status));
 }
 
+static char index_of(DYNDNS_SYSTEM *src,DYN_DNS_CLIENT *p_self)
+{
+
+	char i;
+
+
+	for (i=0;i<p_self->srv_cnt;i++) {
+
+		if (src==p_self->info[i].p_dns_system)
+
+			return i;
+	}
+
+	return -1;
+}
+
 static RC_TYPE get_dns_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
 	RC_TYPE rc;
 	int port = -1;
 
+
 	if (p_self == NULL)
 	{
 		return RC_INVALID_POINTER;
 	}
-   
-    p_self->info.dyndns_server_name.port = HTTP_DEFAULT_PORT;
-    rc = get_name_and_port(p_cmd->argv[current_nr], &p_self->info.dyndns_server_name.name[ip_store], &port);
-    if (rc == RC_OK && port != -1)
-    {
-        p_self->info.dyndns_server_name.port = port;
-    }                                   
+
+    p_self->info[server_index].dyndns_server_name.port = HTTP_DEFAULT_PORT;
+    rc = get_name_and_port(p_cmd->argv[current_nr], &p_self->info[server_index].dyndns_server_name.name, &port);
+
+	if (rc==RC_OK) {
+
+		if (port != -1) {
+
+			p_self->info[server_index].dyndns_server_name.port = port;
+		}
+    }
+
+
 	return rc;
 }
 
+/**
+    Searches the DYNDNS system by the argument.
+    Input is like: system@server.name
+    system=statdns|custom|dyndns|default
+    server name = dyndns.org | freedns.afraid.org
+    The result is a pointer in the table of DNS systems.
+*/
+static RC_TYPE get_dyndns_system_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
+{
+	DYNDNS_SYSTEM *p_dns_system = NULL;
+	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
+	if (p_self == NULL)
+	{
+		return RC_INVALID_POINTER;
+	}
+
+	{
+		DYNDNS_SYSTEM_INFO *it = get_dyndns_system_table();
+		for (; it != NULL && it->id != LAST_DNS_SYSTEM; ++it)
+		{
+			if (strcmp(it->system.p_key, p_cmd->argv[current_nr]) == 0)
+			{
+				p_dns_system = &it->system;
+			}
+		}
+	}
+
+	if (p_dns_system == NULL)
+	{
+		return RC_DYNDNS_INVALID_OPTION;
+	}
+
+
+   	/*new or existing server name can appear anywhere on command line.  if new, increment the global
+	  index (or counter, depending on how implement).  but, first check if it's already in list of
+	  servers and set index (or counter) correspondingly to it.  all "info" (server info structure)
+	  related handlers will use this index (or counter) until a new, or other existing name appears.*/
+
+	if (p_self->srv_cnt) {
+
+		if (!(p_self->srv_cnt<MAX_DNS_SERVER))
+
+			return RC_DYNDNS_TOO_MANY_SERVERS;
+
+
+		if (!(-1==(server_index=index_of(p_dns_system,p_self)))) {
+
+			return RC_OK;			
+		}
+		else {
+
+			server_index=p_self->srv_cnt;
+		}			
+	}
+
+	p_self->info[server_index].p_dns_system = p_dns_system;
+
+	p_self->srv_cnt+=1;
+
+
+	return RC_OK;
+}
+
 RC_TYPE get_dns_server_url_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
@@ -700,14 +848,14 @@
 		return RC_INVALID_POINTER;
 	}
 
-	if (p_self->info.dyndns_server_url)
+	if (p_self->info[server_index].dyndns_server_name.url)
 
-		free(p_self->info.dyndns_server_url);
+		free(p_self->info[server_index].dyndns_server_name.url);
 
-	p_self->info.dyndns_server_url=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
+	p_self->info[server_index].dyndns_server_name.url=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
 
 	/*url*/
-	strcpy(p_self->info.dyndns_server_url, p_cmd->argv[current_nr]);
+	strcpy(p_self->info[server_index].dyndns_server_name.url, p_cmd->argv[current_nr]);
 
 	return RC_OK;
 }
@@ -726,11 +874,11 @@
 	}
 
 	/*user*/
-    p_self->info.proxy_server_name.port = HTTP_DEFAULT_PORT;
-    rc = get_name_and_port(p_cmd->argv[current_nr], &p_self->info.proxy_server_name.name[ip_store], &port);
+    p_self->info[server_index].proxy_server_name.port = HTTP_DEFAULT_PORT;
+    rc = get_name_and_port(p_cmd->argv[current_nr], &p_self->info[server_index].proxy_server_name.name, &port);
     if (rc == RC_OK && port != -1)
     {
-        p_self->info.proxy_server_name.port = port;
+        p_self->info[server_index].proxy_server_name.port = port;
     }                                   
 	return rc;    
 }
@@ -995,43 +1143,6 @@
 	return RC_OK;
 }
 
-/**
-    Searches the DYNDNS system by the argument.
-    Input is like: system@server.name
-    system=statdns|custom|dyndns|default
-    server name = dyndns.org | freedns.afraid.org
-    The result is a pointer in the table of DNS systems.
-*/
-static RC_TYPE get_dyndns_system_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
-{
-	DYNDNS_SYSTEM *p_dns_system = NULL;
-	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
-	if (p_self == NULL)
-	{
-		return RC_INVALID_POINTER;
-	}
-
-	{
-		DYNDNS_SYSTEM_INFO *it = get_dyndns_system_table();
-		for (; it != NULL && it->id != LAST_DNS_SYSTEM; ++it)
-		{
-			if (strcmp(it->system.p_key, p_cmd->argv[current_nr]) == 0)
-			{
-				p_dns_system = &it->system;
-			}
-		}
-	}
-
-	if (p_dns_system == NULL)
-	{
-		return RC_DYNDNS_INVALID_OPTION;
-	}
-
-	p_self->info.p_dns_system = p_dns_system;
-
-	return RC_OK;
-}
-
 static RC_TYPE get_debug_level_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 
@@ -2223,8 +2334,7 @@
 			rc = get_cmd_parse_data_with_error_handling(argv, argc, cmd_options_table,pf_err_handler);
 		}
 
-		if (rc != RC_OK ||
-		        p_self->abort)
+		if (rc != RC_OK || p_self->abort)
 		{
 			break;
 		}
@@ -2232,52 +2342,61 @@
 		/*settings that may change due to cmd line options*/
 		{
 			int	len=0;
+			int i;
 
 			
-    		/*ip server*/
-            if (!(p_self->info.ip_server_name.name[ip_store]))
-            {
-				p_self->info.ip_server_name.name[ip_store]=safe_malloc(strlen(p_self->info.p_dns_system->p_ip_server_name)+1);
-				strcpy(p_self->info.ip_server_name.name[ip_store], p_self->info.p_dns_system->p_ip_server_name);
+            if (!(p_self->info_online_status.name))
+			{
+				p_self->info_online_status.name=safe_malloc(strlen(DYNDNS_MY_ONLINE_CHECK)+1);
+				strcpy(p_self->info_online_status.name,DYNDNS_MY_ONLINE_CHECK);
+
+				p_self->info_online_status.url=safe_malloc(strlen(DYNDNS_MY_ONLINE_CHECK_URL)+1);
+				strcpy(p_self->info_online_status.url,DYNDNS_MY_ONLINE_CHECK_URL);
 
-				p_self->info.ip_server_url=safe_malloc(strlen(p_self->info.p_dns_system->p_ip_server_url)+1);
-				strcpy(p_self->info.ip_server_url, p_self->info.p_dns_system->p_ip_server_url);				
+				p_self->info_online_status.port=80;
             }
 
-            if (!(p_self->info_online_status.ip_server_name.name[ip_store]))
-			{
-				p_self->info_online_status.ip_server_name.name[ip_store]=safe_malloc(strlen(DYNDNS_MY_ONLINE_CHECK)+1);
-				strcpy(p_self->info_online_status.ip_server_name.name[ip_store],DYNDNS_MY_ONLINE_CHECK);
+			if (!(p_self->srv_cnt))
 
-				p_self->info_online_status.ip_server_url=safe_malloc(strlen(DYNDNS_MY_ONLINE_CHECK_URL)+1);
-				strcpy(p_self->info_online_status.ip_server_url,DYNDNS_MY_ONLINE_CHECK_URL);
+				p_self->srv_cnt=1; /*default server set in main*/
 
-				p_self->info_online_status.ip_server_name.port=80;
-            }
+			for (i=0;i<p_self->srv_cnt;i++) {
 
-    		/*dyndns server*/
-            if (!(p_self->info.dyndns_server_name.name[ip_store]))
-            {
-				if (!(0==(len=strlen(p_self->info.p_dns_system->p_dyndns_server_name)))) {
+    			/*dyndns server*/
+				if (!(p_self->info[i].dyndns_server_name.name))
+				{
+					if (!(0==(len=strlen(p_self->info[i].p_dns_system->p_dyndns_server_name)))) {
 
-					p_self->info.dyndns_server_name.name[ip_store]=safe_malloc(len+1);
-        			strcpy(p_self->info.dyndns_server_name.name[ip_store], p_self->info.p_dns_system->p_dyndns_server_name);
+						p_self->info[i].dyndns_server_name.name=safe_malloc(len+1);
+        				strcpy(p_self->info[i].dyndns_server_name.name, p_self->info[i].p_dns_system->p_dyndns_server_name);
+					}				
 				}
-			}
 
-			if (!(p_self->info.dyndns_server_url)) 
-			{
-				if (!(0==(len=strlen(p_self->info.p_dns_system->p_dyndns_server_url)))) {
+ 				/*ip server*/
+				if (!(p_self->info[i].ip_server_name.name))
+				{
+					p_self->info[i].ip_server_name.name=safe_malloc(strlen(p_self->info[i].p_dns_system->p_ip_server_name)+1);
+					strcpy(p_self->info[i].ip_server_name.name, p_self->info[i].p_dns_system->p_ip_server_name);
+				
+					p_self->info[i].ip_server_name.url=safe_malloc(strlen(p_self->info[i].p_dns_system->p_ip_server_url)+1);
+					strcpy(p_self->info[i].ip_server_name.url, p_self->info[i].p_dns_system->p_ip_server_url);				
+				}
 
-					p_self->info.dyndns_server_url=safe_malloc(len+1);
-      				strcpy(p_self->info.dyndns_server_url, p_self->info.p_dns_system->p_dyndns_server_url);
+
+				if (!(p_self->info[i].dyndns_server_name.url)) 
+				{
+					if (!(0==(len=strlen(p_self->info[i].p_dns_system->p_dyndns_server_url)))) {
+
+						p_self->info[i].dyndns_server_name.url=safe_malloc(len+1);
+    					strcpy(p_self->info[i].dyndns_server_name.url, p_self->info[i].p_dns_system->p_dyndns_server_url);
+					}
 				}
 			}
 		}
 
 		/*check if the neccessary params have been provided*/
-		if ((!(p_self->info.dyndns_server_name.name[ip_store])) || (!(p_self->info.ip_server_name.name[ip_store]))
-			|| (!(p_self->info.dyndns_server_url)) || (p_self->alias_info.count == 0))
+		if ((!(p_self->info[0].dyndns_server_name.name)) || (!(p_self->info[0].ip_server_name.name))
+			|| (!(p_self->info[0].dyndns_server_name.url)) || (p_self->info[0].alias_info.count == 0))
 
 		{
 			rc = RC_DYNDNS_INVALID_OR_MISSING_PARAMETERS;
diff -ur inadyn-mt.v.02.24.38/src/lang.c inadyn-mt.v.02.24.38-ms-pid-04/src/lang.c
--- src/lang.c
+++ src/lang.c
@@ -659,14 +659,20 @@
 	RC_TYPE				rc=RC_OK;
 
 
-	DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "Language file search locale:  %s...\n",szLocale));
-
 	memset(langFile,0,7);
 
+	lang_code(langFile,szLocale);
+
+	if (szLocale)
+
+		DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "Language file search locale:  %s...\n",szLocale));
+	else
+		DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "Language file search locale NULL.  Will use language code:  %s...\n",langFile));
+
 
 	/*pass to langFile function, 2 character language code, with appended, .lng*/
 
-	searchedLangFile(pLOG_FILE,&lang_file_and_path,strcat(lang_code(langFile,szLocale),".lng"));
+	searchedLangFile(pLOG_FILE,&lang_file_and_path,strcat(langFile,".lng"));
 
 
 	rc=do_init_lang_strings(pLOG_FILE,lang_file_and_path);
diff -ur inadyn-mt.v.02.24.38/src/os_windows.c inadyn-mt.v.02.24.38-ms-pid-04/src/os_windows.c
--- src/os_windows.c
+++ src/os_windows.c
@@ -322,14 +322,13 @@
 
 		shellInfo.lpFile = utf_8_to_16(utf_malloc_8_to_16(&utf_16,p_cmd),p_cmd);
 
-
-		free(utf_16);
-
 		if(!ShellExecuteExW(&shellInfo))
 
 		{
 			rc = RC_OS_FORK_FAILURE;
 		}
+
+		free(utf_16);
 	}
 
 
diff -ur inadyn-mt.v.02.24.38/src/path.c inadyn-mt.v.02.24.38-ms-pid-04/src/path.c
--- src/path.c
+++ src/path.c
@@ -635,7 +635,7 @@
 	FILE    *fp=NULL;
 
 
-	if (!(root_dir))
+	if (!(root_dir) || !(in_dir))
 
 		return NULL;
 
@@ -768,11 +768,16 @@
 
 	*dest=NULL;
 
+	if (!(cross_platform_cwd(&cwd))) {
+
+		DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "cwd giving NULL in searchedProgFile...\n"));
+
+		return NULL;
+	}
+
 	normed_path=safe_malloc(strlen(path)+2);
 	strcat(strcpy(normed_path,path),DIR_DELIM_STR);
 
-	cross_platform_cwd(&cwd);
-
 #ifdef _WIN32
 
 	if (!(progMetaFile(pLOG_FILE,dest,normed_path,path_len,langFileName,str_to_lwr(ancestor_path(&a_path,root,cwd)),cwd))) {
