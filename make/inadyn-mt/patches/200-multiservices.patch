--- man/inadyn.8
+++ man/inadyn.8
@@ -79,6 +79,8 @@
 .TP
 http://www.tunnelbroker.net,
 .TP
+http://dns.he.net,
+.TP
 http://www.dynsip.org
 .TP
 http://www.dhis.org
@@ -125,6 +127,7 @@
 update request, i.e., both ip address types may be sent in a comma delimited list fashion.
 .TP
 .I \-\-addr_pref
+
 ipv6 privacy extensions address preference.  Valid parameters are 'pub,' 'policy,' 'home,' 'careof,' 'crypto,' 'nocrypto,' 'tmp,' 'pubtmp.'  Defaults to 'pub.'  
 See rfc5014.  Combining via logical OR not presently supported.
 .TP
@@ -164,7 +167,7 @@
 
 There is only one acceptable service for http://freedns.afraid.org, which is default@freedns.afraid.org. 
 
-Other services are: default@zoneedit.com, default@no-ip.com, default@easydns.com, dyndns@3322.org, default@sitelutions.com, default@dnsomatic.com, ipv6tb@he.net, default@tzo.com, default@dynsip.org, default@dhis.org, default@majimoto.net, default@zerigo.com, custom@http_svr_basic_auth. The default service is dyndns@dyndns.org, which is believed to be used by most users, at least initially.
+Other services are: default@zoneedit.com, default@no-ip.com, default@easydns.com, dyndns@3322.org, default@sitelutions.com, default@dnsomatic.com, ipv6tb@he.net, default@he.net, default@tzo.com, default@dynsip.org, default@dhis.org, default@majimoto.net, default@zerigo.com, custom@http_svr_basic_auth. The default service is dyndns@dyndns.org, which is believed to be used by most users, at least initially.
 .TP
 .I \-\-proxy_server[:port]
 An http proxy server name and port. The default is none.
--- man/inadyn-mt.8
+++ man/inadyn-mt.8
@@ -79,6 +79,8 @@
 .TP
 http://www.tunnelbroker.net,
 .TP
+http://dns.he.net,
+.TP
 http://www.dynsip.org
 .TP
 http://www.dhis.org
@@ -125,6 +127,7 @@
 update request, i.e., both ip address types may be sent in a comma delimited list fashion.
 .TP
 .I \-\-addr_pref
+
 ipv6 privacy extensions address preference.  Valid parameters are 'pub,' 'policy,' 'home,' 'careof,' 'crypto,' 'nocrypto,' 'tmp,' 'pubtmp.'  Defaults to 'pub.'  
 See rfc5014.  Combining via logical OR not presently supported.
 .TP
@@ -164,7 +167,7 @@
 
 There is only one acceptable service for http://freedns.afraid.org, which is default@freedns.afraid.org. 
 
-Other services are: default@zoneedit.com, default@no-ip.com, default@easydns.com, dyndns@3322.org, default@sitelutions.com, default@dnsomatic.com, ipv6tb@he.net, default@tzo.com, default@dynsip.org, default@dhis.org, default@majimoto.net, default@zerigo.com, custom@http_svr_basic_auth. The default service is dyndns@dyndns.org, which is believed to be used by most users, at least initially.
+Other services are: default@zoneedit.com, default@no-ip.com, default@easydns.com, dyndns@3322.org, default@sitelutions.com, default@dnsomatic.com, ipv6tb@he.net, default@he.net, default@tzo.com, default@dynsip.org, default@dhis.org, default@majimoto.net, default@zerigo.com, custom@http_svr_basic_auth. The default service is dyndns@dyndns.org, which is believed to be used by most users, at least initially.
 .TP
 .I \-\-proxy_server[:port]
 An http proxy server name and port. The default is none.
--- readme.html
+++ readme.html
@@ -6,8 +6,7 @@
 <body>
 <p><b>inadyn-mt - Simple DYNAMIC DNS client.<br>
 </b></p>
-<p><b>Version 02.24.44, January 2015<br>
-
+<p><b>Version 02.24.44-ms_pid_01_patch, January 2015<br>
 </b></p>
 <p><b>INADYN Advanced Help<br>
 </b></p>
@@ -58,6 +57,7 @@
   <li><a href="http://www.sitelutions.com">sitelutions.com</a></li>
   <li><a href="http://www.dnsomatic.com">dnsomatic.com</a></li>
   <li><a href="http://ipv6tb.he.net">ipv6tb.he.net</a></li>
+  <li><a href="http://dns.he.net">dns.he.net</a></li>
   <li><a href="http://www.tzo.com">tzo.com</a></li>
   <li><a href="http://www.dynsip.org">dynsip.org</a></li>
   <li><a href="http://www.dhis.org">dhis.org</a></li>
@@ -270,9 +270,9 @@
 update request, i.e., both ip address types may be sent in a comma delimited list fashion.</p>
 
 </p>
-<p style="margin-left: 20px;">'--addr_pref &#60;pub | policy | home | careof | crypto | nocrypto | tmp | pubtmp&#62;': ipv6 privacy extensions address 
-preference - public (value, pub - public ipv6 address), policy (value, policy - system policy tables), defaults to pub.  See rfc5014.  Combining via logical OR 
-not presently supported.<br>
+
+<p style="margin-left: 20px;">'--addr_pref &#60;pub | policy | home | careof | crypto | nocrypto | tmp | pubtmp&#62;': ipv6 privacy extensions address preference - public 
+(value, pub - public ipv6 address), policy (value, policy - system policy tables), defaults to pub.  See rfc5014.  Combining via logical OR not presently supported.<br>
 </p>
 <p style="margin-left: 20px;">'--debug': &#60;#&#62; - debug level 1..7 (higher = more output)<br>
 '-d': debug level 1..7 (higher = more output).<br>
@@ -303,6 +303,9 @@
 information.<br>
 </p>
 
+<p style="margin-left: 20px;">'--ip_server_name_global &#60;name&#62;[:port] &#60;url&#62;': The client
+IP is detected by calling 'url' from this 'ip_server_name:port'.  Same as ip_server_name option, but 
+overrides unchanged dyndns_system default ip servers.<br>
 </p>
 <p style="margin-left: 20px;">'--dyndns_server_name &#60;name&#62;[:port]': dynamic dns server name, and optional port.</name>
 </p>
@@ -322,13 +325,18 @@
 -For sitelutions.com:  default@sitelutions.com<br>
 -For dnsomatic.com:  default@dnsomatic.com<br>
 -For tunnelbroker.net:  ipv6tb@he.net<br>
+-For dns.he.net:  default@he.net<br>
 -For tzo.com:  default@tzo.com<br>
 -For dynsip.org:  default@dynsip.org<br>
 -For dhis.org:  default@dhis.org<br>
 -For majimoto.net:  default@majimoto.net<br>
 -For zerigo.com:  default@zerigo.com<br>
 -For generic DNS system: custom@http_svr_basic_auth<br>
-DEFAULT value is intended for default service at dyndns.org: dyndns@dyndns.org<br>
+DEFAULT value is intended for default service at dyndns.org: dyndns@dyndns.org<br><br>
+
+Multiple servers are allowed.  Server related parameters are applied to the most recent dyndns_system option parameter appearing
+on the command line (a given system may appear more than once).  Per server option parameters include credentials; ip server, url, port; dyn dns server, url, port;  
+host alias names.<br>
 </p>
 
 <p style="margin-left: 20px;">
@@ -337,6 +345,7 @@
 '--update_period_sec &#60;#&#62;': how often the IP is checked. The period is in [sec]. 30..864000.  Default is about 10 min. Max is 10 days<br>
 '--forced_update_period &#60;#&#62;': how often, in seconds, the IP is updated even if it is not changed. 30 sec..30 days, default, 30 days.<br>
 '--log_file &#60;path/file&#62;': log file path and name<br>
+'--pid_file &#60;path/file&#62;': pid file path and name<br>
 '--background': runs in background.&nbsp; Output to syslog or to log file [if specified].<br>
 '--verbose &#60;#&#62;': set dbg level. 0 to 5<br>
 '--iterations &#60;#&#62;': set the number of DNS updates. Default is 0, which means infinity.<br>
@@ -485,6 +494,15 @@
 <b>HISTORY<br>
 <br>
 </b>
+Ver.&nbsp; inadyn-mt 2.24.44-ms_pid_patch_01 - Janurary 2015<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; Changes:<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - added /usr/local/ to shared library search<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - fixes missing 2.24.44-ms_pid_patch_00 missing extra version<br><br>
+
+Ver.&nbsp; inadyn-mt 2.24.44-ms_pid_patch_00 - Janurary 2015<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; Changes:<br>
+&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - Multiple services, in single program instance<br><br>
+
 Ver.&nbsp; inadyn-mt 2.24.44 - January 2015<br>
 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; Changes:<br>
 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; - fixes shared library, libao open failure<br><br>
--- src/dyndns.c
+++ src/dyndns.c
@@ -125,9 +125,9 @@
 
 	DYN_DNS_CLIENT	*p_dyndns;
 #ifndef _WIN32
-	void		*p_data;
+	void			*p_data;
 #else
-	RAS_THREAD_DATA	*p_data;
+	RAS_THREAD_DATA *p_data;
 #endif
 
 } CB_ALERT_DATA;
@@ -144,10 +144,12 @@
 
 #endif
 
-static volatile	BOOL	global_is_online=true;
-static volatile BOOL	is_online_thread_exit=false;
-static volatile BOOL	is_alert_thread_exit=false;
-static volatile BOOL	is_update_pending=false;
+static volatile	BOOL		global_is_online=true;
+static volatile BOOL		is_online_thread_exit=false;
+static volatile BOOL		is_alert_thread_exit=false;
+static volatile BOOL		is_global_update_pending=false;
+static volatile BOOL		is_global_in_proc_update_pending=false;
+static volatile BOOL		is_global_success_updates=false;
 
 #ifdef USE_THREADS
 
@@ -174,9 +176,9 @@
 #include "debug_service.h"
 #include "unicode_util.h"
 
-static BOOL				returnSignaled=false;
-static unsigned long			thread_online_test=0;
-static unsigned	long			thread_alert=0;
+static BOOL		returnSignaled=false;
+static unsigned long	thread_online_test=0;
+static unsigned	long	thread_alert=0;
 
 char get_mutex_dyn(DYN_DNS_CLIENT *p_dyndns,HANDLE *hMutex,int *is_waited);
 DWORD get_mutex_wait_dyn(DYN_DNS_CLIENT *p_dyndns,HANDLE *hMutex);
@@ -189,7 +191,7 @@
 int is_exit_requested_void(void *p_self);
 int do_is_dyndns_online(DYN_DNS_CLIENT *p_self);
 static int increment_iterations(DYN_DNS_CLIENT *p_dyndns);
-static RC_TYPE do_handle_bad_config(DYN_DNS_CLIENT *p_self,int i);
+static RC_TYPE do_handle_bad_config(DYN_DNS_CLIENT *p_self,int i,char srv_cnt);
 
 #ifdef USE_SNDFILE
 #ifdef USE_THREADS
@@ -215,34 +217,35 @@
 
 /* DNS systems specific configurations*/
 
-DYNDNS_ORG_SPECIFIC_DATA dyndns_org_dynamic =	{"dyndns"};
-DYNDNS_ORG_SPECIFIC_DATA dyndns_org_custom =	{"custom"};
-DYNDNS_ORG_SPECIFIC_DATA dyndns_org_static =	{"statdns"};
-
-static int get_req_for_dyndns_server(DYN_DNS_CLIENT *this, int nr, DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_freedns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_generic_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_noip_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_easydns_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_sitelutions_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_tzo_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_he_ipv6_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_dhis_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_majimoto_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_zerigo_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info);
-static int get_req_for_twodns_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info);
-
-static BOOL is_dyndns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_freedns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_generic_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_zoneedit_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_easydns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_sitelutions_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_tzo_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_he_ipv6_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_dhis_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_majimoto_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
-static BOOL is_zerigo_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string);
+DYNDNS_ORG_SPECIFIC_DATA dyndns_org_dynamic = {"dyndns"};
+DYNDNS_ORG_SPECIFIC_DATA dyndns_org_custom = {"custom"};
+DYNDNS_ORG_SPECIFIC_DATA dyndns_org_static = {"statdns"};
+
+static int get_req_for_dyndns_server(DYN_DNS_CLIENT *this,char srv_cnt, int nr, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_freedns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_generic_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_noip_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_easydns_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_sitelutions_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_tzo_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_he_ipv6_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_he_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_dhis_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_majimoto_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_zerigo_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info);
+static int get_req_for_twodns_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info);
+
+static BOOL is_dyndns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_freedns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_generic_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_zoneedit_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_easydns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_sitelutions_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_tzo_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_he_ipv6_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_dhis_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_majimoto_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
+static BOOL is_zerigo_server_rsp_ok( DYN_DNS_CLIENT *p_self, char*p_rsp, char* p_ok_string,char srv_cnt);
 
 static BOOL is_dyndns_server_rsp_config(DYN_DNS_CLIENT *p_self, char*p_rsp);
 static BOOL is_freedns_server_rsp_config(DYN_DNS_CLIENT *p_self, char*p_rsp);
@@ -362,6 +365,14 @@
 			DYNDNS_MY_IP_SERVER, DYNDNS_MY_IP_SERVER_URL,
 			"ipv4.tunnelbroker.net", "/ipv4_end.php?", NULL}},
 
+		{HE_DEFAULT,
+			{"default@he.net", NULL,
+			(DNS_SYSTEM_SRV_RESPONSE_OK_FUNC)is_dyndns_server_rsp_ok,
+			(DNS_SYSTEM_SRV_RESPONSE_CONFIG_FUNC)is_dyndns_server_rsp_config,
+			(DNS_SYSTEM_REQUEST_FUNC) get_req_for_he_dns_server,
+			"checkip.dns.he.net", "/",
+			"dyn.dns.he.net", "/nic/update?", NULL}},
+
 		/* Support for dynsip.org by milkfish, from DD-WRT */
 		{DYNSIP_DEFAULT,
 			{"default@dynsip.org", NULL,
@@ -487,7 +498,7 @@
 	DYN_DNS_CMD	old_cmd;
 
 
-	init_cmd_timer(&counter,&counter_init,&cmd_check_period_ms,&old_cmd,is_update_pending,p_self);
+	init_cmd_timer(&counter,&counter_init,&cmd_check_period_ms,&old_cmd,is_global_update_pending,p_self);
 
 	if (old_cmd != NO_CMD)
 	{
@@ -527,7 +538,7 @@
 
 		if (!(p_self->forced_update_counter)) {
 
-			if (!(is_update_pending && !(p_self->retry_pending_off))) {
+			if (!(is_global_update_pending && !(p_self->retry_pending_off))) {
 
 				/*
 					If not retrying pendings, forced update retries fallback to update_period.
@@ -541,9 +552,9 @@
 					turned off.
 				*/
 
-				if (!(is_update_pending) || !(p_self->is_forced_update_attempted)) {
+				if (!(is_global_update_pending) || !(p_self->is_forced_update_attempted)) {
 
-					if (!(p_self->is_bad_config)) {
+					if (!(p_self->is_global_bad_config)) {
 
 						DBG_PRINTF((LOG_INFO,"I:DYNDNS: Command loop breaking for forced update...\n"));
 
@@ -581,10 +592,10 @@
 	return RC_OK;
 }
 
-static int get_req_for_dyndns_server(DYN_DNS_CLIENT *p_self, int cnt,DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_dyndns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,DYNDNS_SYSTEM *p_sys_info)
 {
 
-	int	bytes_stored=0;
+	int bytes_stored=0;
 
 
 	DYNDNS_ORG_SPECIFIC_DATA *p_dyndns_specific =
@@ -594,64 +605,64 @@
 
 
 	bytes_stored=sprintf(p_self->p_req_buffer, DYNDNS_GET_MY_IP_HTTP_REQUEST_FORMAT,
-	                     p_self->info.dyndns_server_url,
+	                     p_self->info[srv_cnt].dyndns_server_name.url,
 	                     p_dyndns_specific->p_system,
-	                     p_self->alias_info.names[cnt].name,
-	                     p_self->info.my_ip_address.name[ip_store],
+	                     p_self->info[srv_cnt].alias_info.names[cnt].name,
+	                     p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
 	                     p_self->wildcard ? "ON" : "OFF",
-	                     p_self->alias_info.names[cnt].name,
-	                     p_self->info.dyndns_server_name.name[ip_store],
-	                     p_self->info.credentials.p_enc_usr_passwd_buffer);
+	                     p_self->info[srv_cnt].alias_info.names[cnt].name,
+	                     p_self->info[srv_cnt].dyndns_server_name.name,
+	                     p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer);
 
 
 	return bytes_stored;
 }
 
-static int get_req_for_freedns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_freedns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, FREEDNS_UPDATE_MY_IP_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-	               p_self->alias_info.hashes[cnt].str,
-				   p_self->info.my_ip_address.name[ip_store],
-	               p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+	               p_self->info[srv_cnt].alias_info.hashes[cnt].str,
+	               p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+	               p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
 
-static int get_req_for_generic_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_generic_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, GENERIC_DNS_BASIC_AUTH_MY_IP_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-	               p_self->alias_info.names[cnt].name,
-	               p_self->info.credentials.p_enc_usr_passwd_buffer,
-	               p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+	               p_self->info[srv_cnt].alias_info.names[cnt].name,
+	               p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,
+	               p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_noip_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_noip_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, GENERIC_NOIP_AUTH_MY_IP_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-	               p_self->alias_info.names[cnt].name,
-	               p_self->info.my_ip_address.name[ip_store],
-	               p_self->info.credentials.p_enc_usr_passwd_buffer,
-	               p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+	               p_self->info[srv_cnt].alias_info.names[cnt].name,
+	               p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+	               p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,
+	               p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_easydns_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_easydns_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, GENERIC_EASYDNS_AUTH_MY_IP_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-	               p_self->alias_info.names[cnt].name,
-	               p_self->info.my_ip_address.name[ip_store],
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+	               p_self->info[srv_cnt].alias_info.names[cnt].name,
+	               p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
 	               p_self->wildcard ? "ON" : "OFF",
-	               p_self->info.credentials.p_enc_usr_passwd_buffer,
-	               p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,
+	               p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_tzo_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_tzo_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info)
 {
 	(void)p_sys_info;
 
@@ -662,28 +673,28 @@
 	}
 
 	return sprintf(p_self->p_req_buffer, GENERIC_TZO_AUTH_MY_IP_REQUEST_FORMAT,
-		       p_self->info.dyndns_server_url,
-		       p_self->alias_info.names[cnt].name,
-		       p_self->info.credentials.my_username,
-		       p_self->info.credentials.my_password,
-		       p_self->info.my_ip_address.name[ip_store],
-		       p_self->info.dyndns_server_name.name[ip_store]);
+		       p_self->info[srv_cnt].dyndns_server_name.url,
+		       p_self->info[srv_cnt].alias_info.names[cnt].name,
+		       p_self->info[srv_cnt].credentials.my_username,
+		       p_self->info[srv_cnt].credentials.my_password,
+		       p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+		       p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_sitelutions_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_sitelutions_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 
 	(void)p_sys_info;
 	return sprintf(p_self->p_req_buffer, SITELUTIONS_GET_MY_IP_HTTP_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-	               p_self->info.credentials.my_username,
-	               p_self->info.credentials.my_password,
-	               p_self->alias_info.names[cnt].name,
-				   p_self->info.my_ip_address.name[ip_store],
-	               p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+	               p_self->info[srv_cnt].credentials.my_username,
+	               p_self->info[srv_cnt].credentials.my_password,
+	               p_self->info[srv_cnt].alias_info.names[cnt].name,
+				   p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+	               p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_he_ipv6_server(DYN_DNS_CLIENT *p_self, int cnt, DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_he_ipv6_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt, DYNDNS_SYSTEM *p_sys_info)
 {
 	unsigned char	digestbuf[MD5_DIGEST_BYTES];
 	char		digeststr[MD5_DIGEST_BYTES*2+1];
@@ -702,129 +713,142 @@
 		return 0;
 	}
 
-	md5_buffer(p_self->info.credentials.my_password,
-		   strlen(p_self->info.credentials.my_password), digestbuf);
+	md5_buffer(p_self->info[srv_cnt].credentials.my_password,
+		   strlen(p_self->info[srv_cnt].credentials.my_password), digestbuf);
 
 	for (i = 0; i < MD5_DIGEST_BYTES; i++)
 		sprintf(&digeststr[i*2], "%02x", digestbuf[i]);
 
 	return sprintf(p_self->p_req_buffer, HE_IPV6TB_UPDATE_MY_IP_REQUEST_FORMAT,
-				p_self->info.dyndns_server_url,
-				p_self->info.my_ip_address.name[ip_store],
-				p_self->info.credentials.my_username,
+				p_self->info[srv_cnt].dyndns_server_name.url,
+				p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+				p_self->info[srv_cnt].credentials.my_username,
 				digeststr,
-				p_self->alias_info.names[cnt].name,
-				p_self->info.dyndns_server_name.name[ip_store]);
+				p_self->info[srv_cnt].alias_info.names[cnt].name,
+				p_self->info[srv_cnt].dyndns_server_name.name);
+}
+
+static int get_req_for_he_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+{
+
+	(void)p_sys_info;
+
+	return sprintf(p_self->p_req_buffer, HE_DEFAULT_UPDATE_MY_IP_REQUEST_FORMAT,
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+				   p_self->info[srv_cnt].alias_info.names[cnt].name,
+				   p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+				   p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,				   
+				   p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_dhis_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_dhis_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 
 	(void)p_sys_info;
 
 	return sprintf(p_self->p_req_buffer, DHIS_MY_IP_UPDATE_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-				   p_self->alias_info.names[cnt].name,
-				   p_self->info.credentials.my_password,
-				   p_self->info.my_ip_address.name[ip_store],
-				   p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+				   p_self->info[srv_cnt].alias_info.names[cnt].name,
+				   p_self->info[srv_cnt].credentials.my_password,
+				   p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+				   p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_majimoto_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_majimoto_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 
 	(void)p_sys_info;
 
 	return sprintf(p_self->p_req_buffer, MAJIMOTO_MY_IP_UPDATE_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-				   p_self->alias_info.names[cnt].name,
-				   p_self->info.my_ip_address.name[ip_store],
-				   p_self->info.credentials.p_enc_usr_passwd_buffer,				   
-				   p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+				   p_self->info[srv_cnt].alias_info.names[cnt].name,
+				   p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+				   p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,				   
+				   p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_zerigo_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_zerigo_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 
 	(void)p_sys_info;
 
 	return sprintf(p_self->p_req_buffer, ZERIGO_MY_IP_UPDATE_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-				   p_self->alias_info.names[cnt].name,
-				   p_self->info.my_ip_address.name[ip_store],
-				   p_self->info.credentials.p_enc_usr_passwd_buffer,				   
-				   p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+				   p_self->info[srv_cnt].alias_info.names[cnt].name,
+				   p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+				   p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,				   
+				   p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_twodns_http_dns_server(DYN_DNS_CLIENT *p_self, int cnt,  DYNDNS_SYSTEM *p_sys_info)
+static int get_req_for_twodns_http_dns_server(DYN_DNS_CLIENT *p_self,char srv_cnt, int cnt,  DYNDNS_SYSTEM *p_sys_info)
 {
 
 	(void)p_sys_info;
 
 	return sprintf(p_self->p_req_buffer, TWODNS_MY_IP_UPDATE_REQUEST_FORMAT,
-	               p_self->info.dyndns_server_url,
-				   p_self->alias_info.names[cnt].name,
-				   p_self->info.my_ip_address.name[ip_store],
-				   p_self->info.credentials.p_enc_usr_passwd_buffer,				   
-				   p_self->info.dyndns_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].dyndns_server_name.url,
+				   p_self->info[srv_cnt].alias_info.names[cnt].name,
+				   p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],
+				   p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer,				   
+				   p_self->info[srv_cnt].dyndns_server_name.name);
 }
 
-static int get_req_for_ip_server(DYN_DNS_CLIENT *p_self, void *p_specific_data)
+static int get_req_for_ip_server(DYN_DNS_CLIENT *p_self,char srv_cnt, void *p_specific_data)
 {
 	(void)p_specific_data;
 
 	return sprintf(p_self->p_req_buffer, DYNDNS_GET_MY_IP_HTTP_REQUEST,
-	               p_self->info.ip_server_url, p_self->info.ip_server_name.name[ip_store]);
+	               p_self->info[srv_cnt].ip_server_name.url,p_self->info[srv_cnt].ip_server_name.name);
 }
 
 RC_TYPE dyn_dns_set_online_check_dest(HTTP_CLIENT *dest,DYN_DNS_CLIENT *p_self)
 {
 
-	if (p_self->info.proxy_server_name.name[ip_store])
+	if (p_self->info[0].proxy_server_name.name)
 	{
-		http_client_set_remote_name(dest,p_self->info.proxy_server_name.name[ip_store]);
-		http_client_set_port(dest,p_self->info.proxy_server_name.port);
+		http_client_set_remote_name(dest,p_self->info[0].proxy_server_name.name);
+		http_client_set_port(dest,p_self->info[0].proxy_server_name.port);
 	}
 	else
 	{
-		http_client_set_remote_name(dest,p_self->info_online_status.ip_server_name.name[ip_store]);
-		http_client_set_port(dest,p_self->info_online_status.ip_server_name.port);
+		http_client_set_remote_name(dest,p_self->info_online_status.name);
+		http_client_set_port(dest,p_self->info_online_status.port);
 	}
 
 
 	return RC_OK;
 }
 
-RC_TYPE dyn_dns_set_ip_server_dest(HTTP_CLIENT *dest,DYN_DNS_CLIENT *p_self)
+RC_TYPE dyn_dns_set_ip_server_dest(HTTP_CLIENT *dest,DYN_DNS_CLIENT *p_self,char srv_cnt)
 {
 
-	if (p_self->info.proxy_server_name.name[ip_store])
+	if (p_self->info[srv_cnt].proxy_server_name.name)
 	{
-		http_client_set_remote_name(dest,p_self->info.proxy_server_name.name[ip_store]);
-		http_client_set_port(dest,p_self->info.proxy_server_name.port);
+		http_client_set_remote_name(dest,p_self->info[srv_cnt].proxy_server_name.name);
+		http_client_set_port(dest,p_self->info[srv_cnt].proxy_server_name.port);
 	}
 	else
 	{
-		http_client_set_remote_name(dest,p_self->info.ip_server_name.name[ip_store]);
-		http_client_set_port(dest,p_self->info.ip_server_name.port);
+		http_client_set_remote_name(dest,p_self->info[srv_cnt].ip_server_name.name);
+		http_client_set_port(dest,p_self->info[srv_cnt].ip_server_name.port);
 	}
 
 
 	return RC_OK;
 }
 
-RC_TYPE dyn_dns_set_dyndns_server_dest(HTTP_CLIENT *dest,DYN_DNS_CLIENT *p_self)
+RC_TYPE dyn_dns_set_dyndns_server_dest(HTTP_CLIENT *dest,DYN_DNS_CLIENT *p_self,char srv_cnt)
 {
 
-	if (p_self->info.proxy_server_name.name[ip_store])
+	if (p_self->info[srv_cnt].proxy_server_name.name)
 	{
-		http_client_set_remote_name(dest,p_self->info.proxy_server_name.name[ip_store]);
-		http_client_set_port(dest,p_self->info.proxy_server_name.port);
+		http_client_set_remote_name(dest,p_self->info[srv_cnt].proxy_server_name.name);
+		http_client_set_port(dest,p_self->info[srv_cnt].proxy_server_name.port);
 	}
 	else
 	{
-		http_client_set_remote_name(dest,p_self->info.dyndns_server_name.name[ip_store]);
-		http_client_set_port(dest,p_self->info.dyndns_server_name.port);
+		http_client_set_remote_name(dest,p_self->info[srv_cnt].dyndns_server_name.name);
+		http_client_set_port(dest,p_self->info[srv_cnt].dyndns_server_name.port);
 	}
 
 
@@ -833,10 +857,14 @@
 
 RC_TYPE dyn_dns_set_http_clients(DYN_DNS_CLIENT *p_self)
 {
+	char	i;
+
 
-	dyn_dns_set_ip_server_dest(&p_self->http_to_ip_server,p_self);
-	dyn_dns_set_dyndns_server_dest(&p_self->http_to_dyndns,p_self);
+	for (i=0;i<p_self->srv_cnt;i++) {
 
+		dyn_dns_set_ip_server_dest(&p_self->info[i].http_to_ip_server,p_self,i);
+		dyn_dns_set_dyndns_server_dest(&p_self->info[i].http_to_dyndns,p_self,i);
+	}
 
 	return RC_OK;
 }
@@ -873,7 +901,7 @@
     Note:
         it updates the flag: info->'my_ip_has_changed' if the old address was different 
 */
-static RC_TYPE do_check_my_ip_address(DYN_DNS_CLIENT *p_self)
+static RC_TYPE do_check_my_ip_address(DYN_DNS_CLIENT *p_self,char srv_cnt)
 {
 
 	RC_TYPE		rc=RC_OK;
@@ -899,13 +927,13 @@
 		else
 			ip_enum=ip_6;
 
-		p_self->info.my_ip_has_changed[ip_enum]=(strcmp(p_ip_str,p_self->info.my_ip_address.name[ip_enum])!=0);
+		p_self->info[srv_cnt].i_face.my_ip_has_changed[ip_enum]=(strcmp(p_ip_str,p_self->info[srv_cnt].i_face.my_ip_address.name[ip_enum])!=0);
 
-		strcpy(p_self->info.my_ip_address.name[ip_enum],p_ip_str);
+		strcpy(p_self->info[srv_cnt].i_face.my_ip_address.name[ip_enum],p_ip_str);
 
 		/*put currently operated upon here -- for auto ip type too*/
-		strcpy(p_self->info.my_ip_address.name[ip_store],p_ip_str);
-		p_self->info.my_ip_has_changed[ip_store]=p_self->info.my_ip_has_changed[ip_enum];
+		strcpy(p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store],p_ip_str);
+		p_self->info[srv_cnt].i_face.my_ip_has_changed[ip_store]=p_self->info[srv_cnt].i_face.my_ip_has_changed[ip_enum];
 
 		free(p_ip_str);
 
@@ -921,16 +949,23 @@
 	iterate over any fallback addresses
 	break on first success
 */
-static RC_TYPE check_my_ip_address(DYN_DNS_CLIENT *p_self)
+static RC_TYPE check_my_ip_address(DYN_DNS_CLIENT *p_self,char srv_index)
 {
-	RC_TYPE	rc;
+	RC_TYPE			rc;
+	HTTP_CLIENT		*p_http;
+	DYNDNS_INFO_TYPE	*info;
+	
+
+	info=&p_self->info[srv_index];
 
+	p_http = &info->http_to_ip_server;
 
-	rc = http_client_init_all(&p_self->http_to_ip_server);
+
+	rc = http_client_init_all(&info->http_to_ip_server);
 
 	if (rc != RC_OK)
 	{
-		http_client_shutdown(&p_self->http_to_ip_server);
+		http_client_shutdown(&info->http_to_ip_server);
 
 		return rc;
 	}
@@ -951,8 +986,8 @@
 			BOOL			is_got_afinet=false;
 
 
-			p_tr->req_len = get_req_for_ip_server((DYN_DNS_CLIENT*) p_self,
-			                                      p_self->info.p_dns_system->p_specific_data);
+			p_tr->req_len = get_req_for_ip_server((DYN_DNS_CLIENT*) p_self,srv_index,
+			                                      info->p_dns_system->p_specific_data);
 			if (p_self->dbg.level > LOG_CRIT) {
 
 				DBG_PRINTF((LOG_DEBUG,"The request for IP server:\n%s\n",p_self->p_req_buffer));
@@ -965,12 +1000,12 @@
 
 
 			DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "Entering Loop.  Got %d sockets...\n",
-				p_self->http_to_ip_server.super.super.server_socket_count));
+				info->http_to_ip_server.super.super.server_socket_count));
 
-			for (i=0;i<p_self->http_to_ip_server.super.super.server_socket_count;i++,
-				p_self->http_to_ip_server.super.super.sock_index++) {
+			for (i=0;i<info->http_to_ip_server.super.super.server_socket_count;i++,
+				info->http_to_ip_server.super.super.sock_index++) {
 				
-				addr=p_self->http_to_ip_server.super.super.addr_ar[i];
+				addr=info->http_to_ip_server.super.super.addr_ar[i];
 
 				/*on *nix, IPv4 precedence could mean no IPv6 routes which could cause a crash on socket send*/
 				if (((is_got_afinet=(is_got_afinet || addr->ai_family==AF_INET)) && addr->ai_family==AF_INET6))
@@ -990,35 +1025,39 @@
 					continue;
 					
 				/*doing any ip4?*/
-				if ((addr->ai_family==AF_INET) && !(p_self->info.is_update_ip4 || p_self->info.is_update_auto))
+				if ((addr->ai_family==AF_INET) && !(p_self->info[srv_index].is_update_ip4 || p_self->info[srv_index].is_update_auto))
 
 					continue;
 					
 				/*doing any ip6?*/
-				if ((addr->ai_family==AF_INET6) && !(p_self->info.is_update_ip6 || p_self->info.is_update_auto))
+				if ((addr->ai_family==AF_INET6) && !(p_self->info[srv_index].is_update_ip6 || p_self->info[srv_index].is_update_auto))
 
 					continue;
 
 				if (strcmp(p_self->ipv6_priv_ext.addr_pref,"policy")) {
 
 					/*as per above flags=IPV6_PREFER_SRC_PUBLIC, connect with our "normal" IPV6 address*/
-					setsockopt(p_self->http_to_ip_server.super.super.socket[i],IPPROTO_IPV6,IPV6_ADDR_PREFERENCES,
+					setsockopt(info->http_to_ip_server.super.super.socket[i],IPPROTO_IPV6,IPV6_ADDR_PREFERENCES,
 						(void *) &p_self->ipv6_priv_ext.flags,sizeof (&p_self->ipv6_priv_ext.flags));
 				}
 
-				if (!(RC_OK==(rc=http_client_connect_socket(&p_self->http_to_ip_server)))) {
+				if (!(RC_OK==(rc=http_client_connect_socket(&info->http_to_ip_server)))) {
 
 					DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "connect failed getting %s ip from %s%s in check_my_ip_address...\n",
-						addr_family_get_name(addr->ai_family),p_self->info.ip_server_name.name[ip_store],p_self->info.ip_server_url));
+						addr_family_get_name(addr->ai_family),info->ip_server_name.name,info->ip_server_name.url));
 
 					continue;
 
 				}
 
-				if (!(RC_OK==(rc=http_client_transaction(&p_self->http_to_ip_server,&p_self->http_tr)))) {
+				
+				memset(p_self->p_work_buffer,0,p_self->work_buffer_size);
+
+
+				if (!(RC_OK==(rc=http_client_transaction(&info->http_to_ip_server,&p_self->http_tr)))) {
 
 					DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Failed getting %s ip from %s%s in check_my_ip_address...\n",
-						addr_family_get_name(addr->ai_family),p_self->info.ip_server_name.name[ip_store],p_self->info.ip_server_url));
+						addr_family_get_name(addr->ai_family),info->ip_server_name.name,info->ip_server_name.url));
 				}
 				else {
 
@@ -1031,22 +1070,22 @@
 
 					DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "GONNA PARSE...\n"));
 
-					if (!(RC_OK==(rc=do_check_my_ip_address(p_self)))) {
+					if (!(RC_OK==(rc=do_check_my_ip_address(p_self,srv_index)))) {
 
 						DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "ip parse failed in check_my_ip_address...\n"));
 					}
 					else {
 
-						DBG_PRINTF((LOG_NOTICE,"N:DYNDNS: My IP address: %s\n", p_self->info.my_ip_address.name[ip_store]));
+						DBG_PRINTF((LOG_NOTICE,"N:DYNDNS: My IP address: %s\n", p_self->info[srv_index].i_face.my_ip_address.name[ip_store]));
 
-						p_self->info.is_got_ip4=is_got_ip4=(is_got_ip4 || (addr->ai_family==AF_INET));
-						p_self->info.is_got_ip6=is_got_ip6=(is_got_ip6 || (addr->ai_family==AF_INET6));
+						p_self->info[srv_index].is_got_ip4=is_got_ip4=(is_got_ip4 || (addr->ai_family==AF_INET));
+						p_self->info[srv_index].is_got_ip6=is_got_ip6=(is_got_ip6 || (addr->ai_family==AF_INET6));
 						
 						/*detect if just doing auto (based on ip server) and dump out when done*/
-						if ((is_got_ip4 && is_got_ip6) || !(p_self->info.is_update_ip4 && p_self->info.is_update_ip6))
+						if ((is_got_ip4 && is_got_ip6) || !(p_self->info[srv_index].is_update_ip4 && p_self->info[srv_index].is_update_ip6))
 
 							/*support ip4 only updates, on dual ip server*/
-							if ((p_self->info.is_update_ip4 && is_got_ip4) || !(p_self->info.is_update_ip4))							
+							if ((p_self->info[srv_index].is_update_ip4 && is_got_ip4) || !(p_self->info[srv_index].is_update_ip4))							
 
 								break;
 					}
@@ -1057,224 +1096,12 @@
 	while(0);
 
 	/*close*/
-	http_client_shutdown(&p_self->http_to_ip_server);
+	http_client_shutdown(&info->http_to_ip_server);
 
 
 	return rc;
 }
 
-/* DynDNS org.specific response validator.
-    'good' or 'nochange' are the good answers,
-
-  3 conditions:
-  pass/good/success/nochange, etc.
-  bad config
-  dyn dns server error (server side trouble)
-  So, for supported servers, we'll have 2 functions to check results:
-  --The present (legacy) function indicating pass/fail
-  --Added function indicating whether it was config error
-
-  'cause on config error, client should stop attempting updates
-  'till config fixed.
-
-  dyndns.org has a fourth condition -- includes "badagent", "good 127.0.0.1" -- 
-  both indicating non-conforming update client:
-
-  badagent 		The user agent was not sent or HTTP method is not permitted (we recommend use of GET request method).
-
-  good 127.0.0.1	This answer indicates good update only when 127.0.0.1 address is requested by update. 
-			In all other cases it warns user that request was ignored because of agent that does not 
-			follow our specifications. 
-*/
-static BOOL is_dyndns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string)
-{
-	/*fail on (badauth, nohost, notfqdn, !yours, etc)*/
-
-	(void) p_ok_string;
-	return ( (strstr(p_rsp, DYNDNS_OK_RESPONSE) != NULL) ||
-	         (strstr(p_rsp, DYNDNS_OK_NOCHANGE) != NULL) );
-}
-
-static BOOL is_dyndns_server_rsp_config( DYN_DNS_CLIENT *p_self, char *p_rsp)
-{
-
-/*Sharing this with servers other than dyndns.org - notes here to distinguish between dyndns.org codes, and those
-  NOT used by dyndns.org*/
-
-/*"Access denied" on bad user or pass from two-dns.de*/
-
-	return (strstr(p_rsp, "!donator")  != NULL || strstr(p_rsp, "badauth") != NULL 
-			|| strstr(p_rsp, "notfqdn") != NULL || strstr(p_rsp, "nohost") != NULL 
-			|| strstr(p_rsp, "numhost")  != NULL || strstr(p_rsp, "badagent") != NULL 
-			|| strstr(p_rsp, "abuse") != NULL || strstr(p_rsp, "good 127.0.0.1") != NULL
-			|| strstr(p_rsp, "!yours") != NULL || strstr(p_rsp, "badsys") != NULL
-			|| strstr(p_rsp, "911") != NULL) || strstr(p_rsp, "Access denied") !=NULL;
-}
-
-/* Freedns afraid.org.specific response validator.
-    ok blabla and n.n.n.n
-    fail blabla and n.n.n.n
-    are the good answers. We search our own IP address in response and that's enough.
-*/
-static BOOL is_freedns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string)
-{
-
-	return (((strstr(p_rsp, "ERROR") == NULL) && strstr(p_rsp, p_self->info.my_ip_address.name[ip_store]) != NULL)
-			|| strstr(p_rsp, "has not changed") != NULL);	
-}
-
-static BOOL is_freedns_server_rsp_config( DYN_DNS_CLIENT *p_self, char *p_rsp)
-{
-
-	return (strstr(p_rsp,"Invalid update URL") != NULL);
-}
-
-/** generic http dns server ok parser
-	parses a given string. If found is ok,
-	Example : 'SUCCESS CODE='
-*/
-static BOOL is_generic_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string)
-{
-	if (p_ok_string == NULL)
-	{
-		return FALSE;
-	}
-	return (strstr(p_rsp, p_ok_string) != NULL);
-}
-
-static BOOL is_generic_server_rsp_config( DYN_DNS_CLIENT *p_self, char *p_rsp)
-{
-
-	/*caveat emptor*/
-
-	return false;
-}
-
-/**
-	the OK codes are:
-	CODE=200
-	CODE=707, for duplicated updates
-*/
-BOOL is_zoneedit_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string)
-{
-	(void) p_ok_string;
-
-	return ((strstr(p_rsp, "CODE=\"200\"") != NULL) || (strstr(p_rsp, "CODE=\"707\"") != NULL)
-			 || (strstr(p_rsp, "CODE=\"201\"") != NULL));
-}
-
-static BOOL is_zoneedit_server_rsp_config( DYN_DNS_CLIENT *p_self, char *p_rsp)
-{
-
-	return (strstr(p_rsp, "CODE=\"703\"") != NULL || strstr(p_rsp, "CODE=\"707\"") != NULL 
-			|| strstr(p_rsp, "CODE=\"704\"") != NULL || strstr(p_rsp, "CODE=\"701\"") != NULL 
-			|| strstr(p_rsp, "CODE=\"705\"") != NULL || strstr(p_rsp, "CODE=\"708\"") != NULL);
-}
-
-/**
-	NOERROR is the OK code here
-*/
-BOOL is_easydns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string)
-{
-	return (strstr(p_rsp, "NOERROR") != NULL);
-}
-
-static BOOL is_easydns_server_rsp_config( DYN_DNS_CLIENT *p_self, char *p_rsp)
-{
-
-	return (strstr(p_rsp, "NOACCESS")  != NULL || strstr(p_rsp, "NOSERVICE")  != NULL || strstr(p_rsp, "ILLEGAL INPUT") 
-			 != NULL || strstr(p_rsp, "TOOSOON") != NULL);
-}
-
-static BOOL is_sitelutions_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char* p_ok_string)
-{
-
-	return (strstr(p_rsp,"success") != NULL);
-}
-
-static BOOL is_sitelutions_server_rsp_config( DYN_DNS_CLIENT *p_self, char *p_rsp)
-{
-
-	return (strstr(p_rsp, "noauth")  != NULL || strstr(p_rsp, "invalid ip")  != NULL || strstr(p_rsp, "invalid ttl") 
-			 != NULL || strstr(p_rsp, "no record")  != NULL || strstr(p_rsp, "not owner") != NULL);
-}
-
-/* HE ipv6 tunnelbroker specific response validator.
-   own IP address and 'already in use' are the good answers.
-*/
-static BOOL is_he_ipv6_server_rsp_ok(DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string)
-{
-	(void)p_ok_string;
-
-	return ((strstr(p_rsp, p_self->info.my_ip_address.name[ip_store]) != NULL) ||
-		(strstr(p_rsp, "already in use") != NULL));
-}
-
-/*not yet implemented
-*/
-static BOOL is_he_ipv6_server_rsp_config( DYN_DNS_CLIENT *p_self, char*p_rsp)
-{
-
-	return false;
-}
-
-/* TZO specific response validator.
-   If we have an HTTP 302 the update wasn't good and we're being redirected 
-*/
-static BOOL is_tzo_server_rsp_ok(DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string)
-{
-	
-	return strstr(p_rsp,"200")  != NULL || strstr(p_rsp,"304") != NULL;
-}
-
-static BOOL is_tzo_server_rsp_config( DYN_DNS_CLIENT *p_self, char *p_rsp)
-{
-
-	return (strstr(p_rsp, "480") != NULL || strstr(p_rsp, "405")  != NULL || strstr(p_rsp, "401")  != NULL 
-			|| strstr(p_rsp, "403") != NULL || strstr(p_rsp, "414") != NULL || strstr(p_rsp, "405") 
-			 != NULL || strstr(p_rsp, "407") != NULL || strstr(p_rsp, "415") != NULL);
-}
-
-static BOOL is_dhis_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char* p_ok_string)
-{
-
-	return (strstr(p_rsp,p_self->info.my_ip_address.name[ip_store]) != NULL);
-}
-
-/*not yet implemented -- at moment, this seems only failure returned
-*/
-static BOOL is_dhis_server_rsp_config( DYN_DNS_CLIENT *p_self, char *p_rsp)
-{
-
-	return !(strstr(p_rsp,"Authorization Required")==NULL);
-}
-
-/*the quiet type*/
-static BOOL is_majimoto_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char* p_ok_string)
-{
-
-	return (!(strlen(p_rsp)));
-}
-
-/*not yet implemented -- there *are* relevant return codes on error --
-  presently, use dyndns server config fuction
-*/
-static BOOL is_majimoto_server_rsp_config( DYN_DNS_CLIENT *p_self, char *p_rsp)
-{
-
-	return false;
-}
-
-static BOOL is_zerigo_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char* p_ok_string)
-{
-	return (strstr(p_rsp,"Status: 200")!=NULL);
-}
-
-static BOOL is_zerigo_server_rsp_config( DYN_DNS_CLIENT *p_self, char *p_rsp)
-{
-	return (strstr(p_rsp,"Status: 400")!=NULL || strstr(p_rsp,"Status: 403")!=NULL || strstr(p_rsp,"Status: 404")!=NULL);
-}
-
 /*find the alias given by parameter alias in list of p_dyndns structure alias names and set
   correponding update state boolean to parameter is_updated
 
@@ -1287,6 +1114,7 @@
 {
 
 	int	i;
+	int	ii;
 	char	*alias_in=NULL;
 	char	*alias_ip_v=alias;
 	char	*p_alias_ip_v=NULL;
@@ -1321,39 +1149,42 @@
 		is_auto=true;
 	}
 
-	for (i=0;i<p_dyndns->alias_info.count;i++) {
+	for (ii=0;ii<p_dyndns->srv_cnt;ii++) {
 
-		/*add ip type [auto,coupled,ip6,ip4] to name[i].name to do compare*/
+		for (i=0;i<p_dyndns->info[ii].alias_info.count;i++) {
 
-		alias_cmp_src=safe_malloc(strlen(p_dyndns->alias_info.names[i].name)+9);
-		sprintf(alias_cmp_src,"%s:%s",p_dyndns->alias_info.names[i].name,p_dyndns->alias_info.names[i].ip_v);
+			/*add ip type [auto,coupled,ip6,ip4] to name[i].name to do compare*/
 
-		if (!(strcmp(alias_cmp_src,alias_ip_v)) || (strstr(p_dyndns->alias_info.names[i].ip_v,DUAL_LIST) 
-			&& !(strcmp(p_dyndns->alias_info.names[i].name,alias_in)))) {
+			alias_cmp_src=safe_malloc(strlen(p_dyndns->info[ii].alias_info.names[i].name)+9);
+			sprintf(alias_cmp_src,"%s:%s",p_dyndns->info[ii].alias_info.names[i].name,p_dyndns->info[ii].alias_info.names[i].ip_v);
 
-			p_dyndns->alias_info.update_succeeded[i]=is_updated;
+			if (!(strcmp(alias_cmp_src,alias_ip_v)) || (strstr(p_dyndns->info[ii].alias_info.names[i].ip_v,DUAL_LIST) 
+				&& !(strcmp(p_dyndns->info[ii].alias_info.names[i].name,alias_in)))) {
 
-			is_found=true;
-		}
-		else {
+				p_dyndns->info[ii].alias_info.update_succeeded[i]=is_updated;
 
-			/*for aliases of type auto, set update state for either ip6, ip4*/
+				is_found=true;
+			}
+			else {
 
-			if (is_auto)
+				/*for aliases of type auto, set update state for either ip6, ip4*/
 
-				if (!(strcmp(p_dyndns->alias_info.names[i].name,alias_in))) {
+				if (is_auto)
 
-					p_dyndns->alias_info.update_succeeded[i]=is_updated;
+					if (!(strcmp(p_dyndns->info[ii].alias_info.names[i].name,alias_in))) {
 
-					is_found=true;
-				}
-		}
+						p_dyndns->info[ii].alias_info.update_succeeded[i]=is_updated;
+
+						is_found=true;
+					}
+			}
 
-		free(alias_cmp_src);
+			free(alias_cmp_src);
 
-		if (is_found)
+			if (is_found)
 
-			break;
+				break;
+		}
 	}
 
 	free(p_alias_ip_v);
@@ -1484,7 +1315,8 @@
 					else {	/*alias*/
 
 //second space or \n
-						/*							set update succeeded for corresponding alias
+						/*
+							set update succeeded for corresponding alias
 
 							others will be false, and need is_update_pending true accordingly
 						*/
@@ -1537,7 +1369,7 @@
 
 		}
 
-		is_update_pending=(alias_count<p_dyndns->alias_info.count);
+		is_global_update_pending=(alias_count<number_of_aliases(p_dyndns));
 
 		fclose(fp);
 
@@ -1594,130 +1426,447 @@
 	return -1;
 }
 
+/*
+    Updates for every maintained name the property: 'update_required'.
+    The property will be checked in another function and updates performed.
+        
+      Action:
+        Check if my IP address has changed. -> ALL names have to be updated.
+        Note: In the update function the property will set to false if update was successful.
+*/
+static RC_TYPE do_check_alias_update_table(DYN_DNS_CLIENT *p_self,char srv_index)
+{
+	int			i;
+	DYNDNS_IPV		ip_v;
+	BOOL			is_dyndns_dual;
+	BOOL			is_cache_current;
+	DYNDNS_INFO_TYPE	*info;
+	char			*ip_alias_type;
+	char			*ip_alias_type2;
+
+	info=&p_self->info[srv_index];
+
+
+	for (i = 0; i < info->alias_info.count; ++i)
+	{
+		ip_alias_type2=NULL;
+
+		ip_v=info->alias_info.names[i].ip_v_enum;
+
+		/*ip type DUAL_LIST is dual of form, 1.1.1.1,::1 -- both ip types in one update connection*/
+		if (!(is_dyndns_dual=(NULL!=strstr(info->alias_info.names[i].ip_v,DUAL_LIST)))) {
+
+			ip_alias_type=safe_malloc(strlen(p_self->info[srv_index].i_face.my_ip_address.name[ip_v])+strlen(info->alias_info.names[i].name)+strlen(info->alias_info.names[i].ip_v)+3);
+			sprintf(ip_alias_type,"%s %s:%s",p_self->info[srv_index].i_face.my_ip_address.name[ip_v],info->alias_info.names[i].name,info->alias_info.names[i].ip_v);
+
+			is_cache_current=!(ip_cache_list_index_of(&p_self->ip_cache_list,ip_alias_type)==-1);
+		}
+		else {
+
+			ip_alias_type=safe_malloc(strlen(p_self->info[srv_index].i_face.my_ip_address.name[ip_4])+strlen(info->alias_info.names[i].name)+6);
+			sprintf(ip_alias_type,"%s %s:ip4",p_self->info[srv_index].i_face.my_ip_address.name[ip_4],info->alias_info.names[i].name);
+
+			ip_alias_type2=safe_malloc(strlen(p_self->info[srv_index].i_face.my_ip_address.name[ip_6])+strlen(info->alias_info.names[i].name)+6);
+			sprintf(ip_alias_type2,"%s %s:ip6",p_self->info[srv_index].i_face.my_ip_address.name[ip_6],info->alias_info.names[i].name);
+
+			is_cache_current=!(ip_cache_list_index_of(&p_self->ip_cache_list,ip_alias_type)==-1 || ip_cache_list_index_of(&p_self->ip_cache_list,ip_alias_type2)==-1);
+		}
+
+		info->alias_info.update_required[i] = 
+
+			/*ip address changed, or failed update?*/
+			(!is_cache_current
+
+			/*pending failed update?*/
+			|| (is_global_update_pending && !(info->alias_info.update_succeeded[i]))
+
+			/*administrative update?*/
+			|| (!(p_self->forced_update_counter)));
+
+		if (info->alias_info.update_required[i]) {	
+	
+			if (is_dyndns_dual)
+
+				DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "IP address for alias '%s:%s' needs update to '%s,%s'...\n",
+				        info->alias_info.names[i].name,info->alias_info.names[i].ip_v, 
+						p_self->info[srv_index].i_face.my_ip_address.name[ip_4],
+						p_self->info[srv_index].i_face.my_ip_address.name[ip_6]));
+
+
+			else
+
+				DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "IP address for alias '%s:%s' needs update to '%s'...\n",
+				        info->alias_info.names[i].name,info->alias_info.names[i].ip_v, 
+						p_self->info[srv_index].i_face.my_ip_address.name[ip_v]));
+			
+			info->alias_info.update_required[i]=!(info->alias_info.fatal_error[i]);
+		}
+
+		free(ip_alias_type); free(ip_alias_type2);
+	}
+	
+	return RC_OK;
+}
+
+/* DynDNS org.specific response validator.
+    'good' or 'nochange' are the good answers,
+
+  3 conditions:
+  pass/good/success/nochange, etc.
+  bad config
+  dyn dns server error (server side trouble)
+  So, for supported servers, we'll have 2 functions to check results:
+  --The present (legacy) function indicating pass/fail
+  --Added function indicating whether it was config error
+
+  'cause on config error, client should stop attempting updates
+  'till config fixed.
+
+  dyndns.org has a fourth condition -- includes "badagent", "good 127.0.0.1" -- 
+  both indicating non-conforming update client:
+
+  badagent 			The user agent was not sent or HTTP method is not permitted (we recommend use of GET request method).
+
+  good 127.0.0.1	This answer indicates good update only when 127.0.0.1 address is requested by update. 
+					In all other cases it warns user that request was ignored because of agent that does not 
+					follow our specifications. 
+*/
+static BOOL is_dyndns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string,char srv_cnt)
+{
+	/*fail on (badauth, nohost, notfqdn, !yours, etc)*/
+
+	(void) p_ok_string;
+	return ( (strstr(p_rsp, DYNDNS_OK_RESPONSE) != NULL) ||
+	         (strstr(p_rsp, DYNDNS_OK_NOCHANGE) != NULL) );
+}
+
+static BOOL is_dyndns_server_rsp_config( DYN_DNS_CLIENT *p_self, char *p_rsp)
+{
+/*Sharing this with servers other than dyndns.org - notes here to distinguish between dyndns.org codes, and those
+  NOT used by dyndns.org*/
+
+/*"Access denied" on bad user or pass from two-dns.de*/
+
+	return (strstr(p_rsp, "!donator")  != NULL || strstr(p_rsp, "badauth") != NULL 
+			|| strstr(p_rsp, "notfqdn") != NULL || strstr(p_rsp, "nohost") != NULL 
+			|| strstr(p_rsp, "numhost")  != NULL || strstr(p_rsp, "badagent") != NULL 
+			|| strstr(p_rsp, "abuse") != NULL || strstr(p_rsp, "good 127.0.0.1") != NULL
+			|| strstr(p_rsp, "!yours") != NULL || strstr(p_rsp, "badsys") != NULL
+			|| strstr(p_rsp, "911") != NULL) || strstr(p_rsp, "Access denied") !=NULL;
+}
+
+/* Freedns afraid.org.specific response validator.
+    ok blabla and n.n.n.n
+    fail blabla and n.n.n.n
+    are the good answers. We search our own IP address in response and that's enough.
+*/
+static BOOL is_freedns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string,char srv_cnt)
+{
+
+	return (((strstr(p_rsp, "ERROR") == NULL) && strstr(p_rsp, p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store]) != NULL)
+			|| strstr(p_rsp, "has not changed") != NULL);	
+}
+
+static BOOL is_freedns_server_rsp_config( DYN_DNS_CLIENT *p_self, char *p_rsp)
+{
+
+	return (strstr(p_rsp,"Invalid update URL") != NULL);
+}
+
+/** generic http dns server ok parser
+	parses a given string. If found is ok,
+	Example : 'SUCCESS CODE='
+*/
+static BOOL is_generic_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string,char srv_cnt)
+{
+	if (p_ok_string == NULL)
+	{
+		return FALSE;
+	}
+	return (strstr(p_rsp, p_ok_string) != NULL);
+}
+
+static BOOL is_generic_server_rsp_config( DYN_DNS_CLIENT *p_self, char *p_rsp)
+{
+
+	/*caveat emptor*/
+
+	return false;
+}
+
+/**
+	the OK codes are:
+		CODE=200
+		CODE=707, for duplicated updates
+*/
+BOOL is_zoneedit_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string,char srv_cnt)
+{
+	(void) p_ok_string;
+
+	return ((strstr(p_rsp, "CODE=\"200\"") != NULL) || (strstr(p_rsp, "CODE=\"707\"") != NULL)
+			 || (strstr(p_rsp, "CODE=\"201\"") != NULL));
+}
+
+static BOOL is_zoneedit_server_rsp_config( DYN_DNS_CLIENT *p_self, char *p_rsp)
+{
+
+	return (strstr(p_rsp, "CODE=\"703\"") != NULL || strstr(p_rsp, "CODE=\"707\"") != NULL 
+			|| strstr(p_rsp, "CODE=\"704\"") != NULL || strstr(p_rsp, "CODE=\"701\"") != NULL 
+			|| strstr(p_rsp, "CODE=\"705\"") != NULL || strstr(p_rsp, "CODE=\"708\"") != NULL);
+}
+
+/**
+	NOERROR is the OK code here
+*/
+BOOL is_easydns_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string,char srv_cnt)
+{
+	return (strstr(p_rsp, "NOERROR") != NULL);
+}
+
+static BOOL is_easydns_server_rsp_config( DYN_DNS_CLIENT *p_self, char *p_rsp)
+{
+
+	return (strstr(p_rsp, "NOACCESS")  != NULL || strstr(p_rsp, "NOSERVICE")  != NULL || strstr(p_rsp, "ILLEGAL INPUT") 
+			 != NULL || strstr(p_rsp, "TOOSOON") != NULL);
+}
+
+static BOOL is_sitelutions_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char* p_ok_string,char srv_cnt)
+{
+
+	return (strstr(p_rsp,"success") != NULL);
+}
+
+static BOOL is_sitelutions_server_rsp_config( DYN_DNS_CLIENT *p_self, char *p_rsp)
+{
+
+	return (strstr(p_rsp, "noauth")  != NULL || strstr(p_rsp, "invalid ip")  != NULL || strstr(p_rsp, "invalid ttl") 
+			 != NULL || strstr(p_rsp, "no record")  != NULL || strstr(p_rsp, "not owner") != NULL);
+}
+
+/* HE ipv6 tunnelbroker specific response validator.
+   own IP address and 'already in use' are the good answers.
+*/
+static BOOL is_he_ipv6_server_rsp_ok(DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string,char srv_cnt)
+{
+	(void)p_ok_string;
+
+	return ((strstr(p_rsp, p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store]) != NULL) ||
+		(strstr(p_rsp, "already in use") != NULL));
+}
+
+/*not yet implemented
+*/
+static BOOL is_he_ipv6_server_rsp_config( DYN_DNS_CLIENT *p_self, char*p_rsp)
+{
+
+	return false;
+}
+
+/* TZO specific response validator.
+   If we have an HTTP 302 the update wasn't good and we're being redirected 
+*/
+static BOOL is_tzo_server_rsp_ok(DYN_DNS_CLIENT *p_self, char *p_rsp, char *p_ok_string,char srv_cnt)
+{
+	
+	return strstr(p_rsp,"200")  != NULL || strstr(p_rsp,"304") != NULL;
+}
+
+static BOOL is_tzo_server_rsp_config( DYN_DNS_CLIENT *p_self, char *p_rsp)
+{
+
+	return (strstr(p_rsp, "480") != NULL || strstr(p_rsp, "405")  != NULL || strstr(p_rsp, "401")  != NULL 
+			|| strstr(p_rsp, "403") != NULL || strstr(p_rsp, "414") != NULL || strstr(p_rsp, "405") 
+			 != NULL || strstr(p_rsp, "407") != NULL || strstr(p_rsp, "415") != NULL);
+}
+
+static BOOL is_dhis_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char* p_ok_string,char srv_cnt)
+{
+
+	return (strstr(p_rsp,p_self->info[srv_cnt].i_face.my_ip_address.name[ip_store]) != NULL);
+}
+
+/*not yet implemented -- at moment, this seems only failure returned
+*/
+static BOOL is_dhis_server_rsp_config( DYN_DNS_CLIENT *p_self, char *p_rsp)
+{
+
+	return !(strstr(p_rsp,"Authorization Required")==NULL);
+}
+
+/*the quiet type*/
+static BOOL is_majimoto_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char* p_ok_string,char srv_cnt)
+{
+
+	return (!(strlen(p_rsp)));
+}
+
+/*not yet implemented -- there *are* relevant return codes on error --
+  presently, use dyndns server config fuction
+*/
+static BOOL is_majimoto_server_rsp_config( DYN_DNS_CLIENT *p_self, char *p_rsp)
+{
+
+	return false;
+}
+
+static BOOL is_zerigo_server_rsp_ok( DYN_DNS_CLIENT *p_self, char *p_rsp, char* p_ok_string,char srv_cnt)
+{
+	return (strstr(p_rsp,"Status: 200")!=NULL);
+}
+
+static BOOL is_zerigo_server_rsp_config( DYN_DNS_CLIENT *p_self, char *p_rsp)
+{
+	return (strstr(p_rsp,"Status: 400")!=NULL || strstr(p_rsp,"Status: 403")!=NULL || strstr(p_rsp,"Status: 404")!=NULL);
+}
+
 static RC_TYPE update_update_state(DYN_DNS_CLIENT *p_self,int updates_needed,int success_updates,
-										  int config_fails,RC_TYPE *rc)
+										  int config_fails,RC_TYPE rc,char srv_index)
 {
-	FILE *fp;
+	FILE			*fp;
+	DYNDNS_INFO_TYPE	*info;
 
 
-	if (config_fails==p_self->alias_info.count)
+	info=&p_self->info[srv_index];
 
-		*rc=RC_DYNDNS_RSP_CONFIG;
+	/*global successes maintained across server iterations in main loop*/
+	is_global_success_updates=(is_global_success_updates || success_updates);
 
-	else {
+	if (config_fails==info->alias_info.count) {
 
-		if (success_updates) {
+		rc=RC_DYNDNS_RSP_CONFIG;
 
-			/*rebuilding the list*/
-			ip_cache_list_destruct(&p_self->ip_cache_list);
+		if (!(srv_index==p_self->srv_cnt-1))
 
-			/*reset forced update period*/
-			p_self->forced_update_counter=p_self->forced_update_period_sec_orig/p_self->cmd_check_period;
-			p_self->forced_update_period_sec=p_self->forced_update_period_sec_orig;			
+			return rc;
+	}
 
-			if ((fp=utf_fopen(p_self->time_cache, "w"))) {
+	/*
+		reset on last server if any server successes
+	*/
+	if (is_global_success_updates && srv_index==p_self->srv_cnt-1) {
 
-				fprintf(fp,"%ld",time(NULL));
+		/*rebuilding the list*/
+		ip_cache_list_destruct(&p_self->ip_cache_list);
 
-				fclose(fp);
-			}
+		/*reset forced update period*/
+		p_self->forced_update_counter=p_self->forced_update_period_sec_orig/p_self->cmd_check_period;
+		p_self->forced_update_period_sec=p_self->forced_update_period_sec_orig;			
 
-			fp=utf_fopen(p_self->ip_cache, "w");
+		if ((fp=utf_fopen(p_self->time_cache, "w"))) {
 
-			{
-				int		i;
-				DYNDNS_IPV	ip_enum;
-				BOOL		is_dyndns_dual;
+			fprintf(fp,"%ld",time(NULL));
+
+			fclose(fp);
+		}
+
+		fp=utf_fopen(p_self->ip_cache, "w");
+
+		{
 
-				for (i=0;i<p_self->alias_info.count;i++) {
+			int		i;
+			int		ii;
+			DYNDNS_IPV	ip_enum;
+			BOOL		is_dyndns_dual;
+				
+			for (ii=0;ii<p_self->srv_cnt;ii++) {
 
-					is_dyndns_dual=(NULL!=strstr(p_self->alias_info.names[i].ip_v,DUAL_LIST));
+				for (i=0;i<p_self->info[ii].alias_info.count;i++) {
 
-					ip_enum=p_self->alias_info.names[i].ip_v_enum;
+					is_dyndns_dual=(NULL!=strstr(p_self->info[ii].alias_info.names[i].ip_v,DUAL_LIST));
 
-					if (p_self->alias_info.update_succeeded[i]) {
+					ip_enum=p_self->info[ii].alias_info.names[i].ip_v_enum;
 
-						/*update saved ip cache list structure, and write it to cache file*/
+					if (p_self->info[ii].alias_info.update_succeeded[i]) { 						
 
 						if (!(is_dyndns_dual)) {
 
-							ip_cache_list_add(p_self,p_self->info.my_ip_address.name[ip_enum],
-								p_self->alias_info.names[i].name,p_self->alias_info.names[i].ip_v);
-								
+							ip_cache_list_add(p_self,p_self->info[ii].i_face.my_ip_address.name[ip_enum],
+								p_self->info[ii].alias_info.names[i].name,p_self->info[ii].
+								alias_info.names[i].ip_v);
+
 							if (fp)
-								fprintf(fp,"%s %s:%s %s\n",p_self->info.my_ip_address.name[ip_enum],
-									p_self->alias_info.names[i].name,p_self->alias_info.names[i].ip_v,p_self->info.dyndns_server_name.name[ip_store]);
+
+								fprintf(fp,"%s %s:%s %s\n",p_self->info[ii].i_face.my_ip_address.name[ip_enum],
+									p_self->info[ii].alias_info.names[i].name,p_self->info[ii].
+									alias_info.names[i].ip_v,p_self->info[ii].dyndns_server_name.name);
 						}
 						else {
-							ip_cache_list_add(p_self,p_self->info.my_ip_address.name[ip_4],
-								p_self->alias_info.names[i].name,"ip4");
+							ip_cache_list_add(p_self,p_self->info[ii].i_face.my_ip_address.name[ip_4],
+								p_self->info[ii].alias_info.names[i].name,"ip4");
 
-							ip_cache_list_add(p_self,p_self->info.my_ip_address.name[ip_6],
-								p_self->alias_info.names[i].name,"ip6");
+							ip_cache_list_add(p_self,p_self->info[ii].i_face.my_ip_address.name[ip_6],
+								p_self->info[ii].alias_info.names[i].name,"ip6");
 
 							if (fp) {
 
-								fprintf(fp,"%s %s:ip4 %s\n",p_self->info.my_ip_address.name[ip_4],
-									p_self->alias_info.names[i].name,p_self->info.dyndns_server_name.name[ip_store]);
+								fprintf(fp,"%s %s:ip4 %s\n",p_self->info[ii].i_face.my_ip_address.name[ip_4],
+									p_self->info[ii].alias_info.names[i].name,p_self->info[ii].dyndns_server_name.name);
 
-								fprintf(fp,"%s %s:ip6 %s\n",p_self->info.my_ip_address.name[ip_6],
-									p_self->alias_info.names[i].name,p_self->info.dyndns_server_name.name[ip_store]);
+								fprintf(fp,"%s %s:ip6 %s\n",p_self->info[ii].i_face.my_ip_address.name[ip_6],
+									p_self->info[ii].alias_info.names[i].name,p_self->info[ii].dyndns_server_name.name);
 							}
 						}
 					}
 				}
-
-				if (fp)
-					fclose(fp);
 			}
-		}
-	
-		/*any pending?*/
-		if (!(updates_needed && !(success_updates==updates_needed))) {
 
-			/*no pendings*/
-			if (success_updates) {
-
-				p_self->is_forced_update_attempted=false;
+			if (fp)
+				fclose(fp);
+		}		
+	}
 
-				*rc=RC_OK;
-			}
-		}
-		else {
+	/*any pending?*/
+	if ((updates_needed && !(success_updates==updates_needed))) {
 
-			if (*rc==RC_OK) /*not break after http client init*/
+		if (rc==RC_OK) /*not break after http client init*/
 			
-				*rc=RC_DYNDNS_RSP_NOTOK;
+			rc=RC_DYNDNS_RSP_NOTOK;
 
-			DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "One or more (%d) alias updates failed...\n",
+		DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "One or more (%d) alias updates failed...\n",
 						updates_needed-success_updates));
+	}
+	else {
+
+		/*no pendings this server*/
+		if (success_updates) {
+
+			/*no pendings any server*/
+			if (!(is_global_in_proc_update_pending) && srv_index==p_self->srv_cnt-1)
+
+				p_self->is_forced_update_attempted=false;
+
+			rc=RC_OK;
 		}
 	}
 
-	return *rc;
+	return rc;
 }
 
-static RC_TYPE do_update_alias_table(DYN_DNS_CLIENT *p_self,char *is_forced_update_reset)
+static RC_TYPE do_update_alias_table(DYN_DNS_CLIENT *p_self,char *is_forced_update_reset,char srv_index)
 {
-	int	i;
-	int	success_updates=0;	
-	int	update_ok=false;
-	int	config_fails=0;
-	int	updates_needed=p_self->alias_info.count;
-	BOOL	is_ipv4;
+	DYNDNS_INFO_TYPE	*info;
+	int			i;
+	int			success_updates=0;	
+	int			update_ok=false;
+	int			config_fails=0;
+	int			updates_needed=p_self->info[srv_index].alias_info.count;
+	BOOL			is_ipv4;
 
 	RC_TYPE rc = RC_OK;
 
 
+	info=&p_self->info[srv_index];
+
+
 	do
 	{
-		for (i = 0; i < p_self->alias_info.count; ++i) {
+		for (i = 0; i < info->alias_info.count; ++i) {
 
-			if (!(p_self->alias_info.update_required[i])) {
+			if (!(info->alias_info.update_required[i])) {
 
-				if (p_self->alias_info.fatal_error[i]) {
+				if (info->alias_info.fatal_error[i]) {
 
-					do_handle_bad_config(p_self,i);
+					do_handle_bad_config(p_self,i,srv_index);
 
 					config_fails++;
 				}
@@ -1727,46 +1876,49 @@
 			else {
 
 				/*dual stack with ip's updated in comma delimited list fashion?*/
-				if (NULL==(strstr(p_self->alias_info.names[i].ip_v,DUAL_LIST))) {
+				if (NULL==(strstr(info->alias_info.names[i].ip_v,DUAL_LIST))) {
 
-					if (!(ip_store==p_self->alias_info.names[i].ip_v_enum))
+					if (!(ip_store==info->alias_info.names[i].ip_v_enum))
 
-						strcpy(p_self->info.my_ip_address.name[ip_store],
-								p_self->info.my_ip_address.name[p_self->alias_info.names[i].ip_v_enum]);
+						strcpy(p_self->info[srv_index].i_face.my_ip_address.name[ip_store],
+								p_self->info[srv_index].i_face.my_ip_address.name[info->alias_info.names[i].ip_v_enum]);
 				}
 				else {
-					sprintf(p_self->info.my_ip_address.name[ip_store],"%s,%s",p_self->info.my_ip_address.name[ip_4],p_self->info.my_ip_address.name[ip_6]);
 
-					if (!(p_self->info.is_got_ip4 && p_self->info.is_got_ip6)) {
+					sprintf(p_self->info[srv_index].i_face.my_ip_address.name[ip_store],"%s,%s",
+						p_self->info[srv_index].i_face.my_ip_address.name[ip_4],
+						p_self->info[srv_index].i_face.my_ip_address.name[ip_6]);
 
-						p_self->alias_info.update_succeeded[i]=false;
+					if (!(p_self->info[srv_index].is_got_ip4 && p_self->info[srv_index].is_got_ip6)) {
+
+						info->alias_info.update_succeeded[i]=false;
 
 						DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Skipping partially empty address (%s) update of alias "\
-							"%s\n",p_self->info.my_ip_address.name[ip_store],p_self->alias_info.names[i].name));
+							"%s\n",p_self->info[srv_index].i_face.my_ip_address.name[ip_store],info->alias_info.names[i].name));
 
 						continue;
 					}
 				}
 
-				if (!(strlen(p_self->info.my_ip_address.name[ip_store]))) {
+				if (!(strlen(p_self->info[srv_index].i_face.my_ip_address.name[ip_store]))) {
 
-					p_self->alias_info.update_succeeded[i]=false;
+					info->alias_info.update_succeeded[i]=false;
 
-					DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Skipping empty address update of alias %s\n",p_self->alias_info.names[i].name));
+					DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Skipping empty address update of alias %s\n",info->alias_info.names[i].name));
 
 					continue;
 				}
 
-				is_ipv4=(p_self->alias_info.names[i].ip_v_enum==ip_4);
+				is_ipv4=(info->alias_info.names[i].ip_v_enum==ip_4);
 
 				/*bind to dynamic dns server according to address type to be updated*/
-				http_client_set_is_ipv4(&p_self->http_to_dyndns,is_ipv4);
+				http_client_set_is_ipv4(&info->http_to_dyndns,is_ipv4);
 
-				if (!((rc=http_client_init_and_connect(&p_self->http_to_dyndns))==RC_OK)) {
+				if (!((rc=http_client_init_and_connect(&info->http_to_dyndns))==RC_OK)) {
 
-					DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Init error:  %s updating alias %s\n",errorcode_get_name(rc),p_self->alias_info.names[i].name));
+					DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "Init error:  %s updating alias %s\n",errorcode_get_name(rc),info->alias_info.names[i].name));
 
-					p_self->alias_info.update_succeeded[i]=false;
+					info->alias_info.update_succeeded[i]=false;
 				}
 				else {
 
@@ -1774,18 +1926,18 @@
 					{
 						HTTP_TRANSACTION http_tr;
 						
-						http_tr.req_len = p_self->info.p_dns_system->p_dns_update_req_func(
-							(struct _DYN_DNS_CLIENT*) p_self,i,(struct DYNDNS_SYSTEM*) 
-							p_self->info.p_dns_system);
+						http_tr.req_len = 
+							info->p_dns_system->p_dns_update_req_func((struct _DYN_DNS_CLIENT*) p_self,srv_index,i,
+							(struct DYNDNS_SYSTEM*) info->p_dns_system);
+
 						http_tr.p_req = (char*) p_self->p_req_buffer;
 						http_tr.p_rsp = (char*) p_self->p_work_buffer;
-						/*save place for a \0 at the end*/
-						http_tr.max_rsp_len = p_self->work_buffer_size - 1;
+						http_tr.max_rsp_len = p_self->work_buffer_size - 1;/*save place for a \0 at the end*/
 						http_tr.rsp_len = 0;
 						p_self->p_work_buffer[http_tr.rsp_len+1] = 0;				
 
 						/*send it*/
-						rc = http_client_transaction(&p_self->http_to_dyndns, &http_tr);
+						rc = http_client_transaction(&info->http_to_dyndns, &http_tr);
 						http_tr.p_rsp[http_tr.rsp_len]=0;
 
 						if (p_self->dbg.level > 2)
@@ -1797,13 +1949,13 @@
 						/*error in send?*/
 						if (!(rc == RC_OK))
 
-							p_self->alias_info.update_succeeded[i]=false;
+							info->alias_info.update_succeeded[i]=false;
 
 						else {
 
 							update_ok =
-								p_self->info.p_dns_system->p_rsp_ok_func((struct _DYN_DNS_CLIENT*)p_self,
-									    http_tr.p_rsp,p_self->info.p_dns_system->p_success_string);
+								info->p_dns_system->p_rsp_ok_func((struct _DYN_DNS_CLIENT*)p_self,
+									    http_tr.p_rsp,info->p_dns_system->p_success_string,srv_index);
 
 							if (update_ok)
 							{
@@ -1817,12 +1969,12 @@
 									*is_forced_update_reset=true;
 								}
 #endif
-								p_self->alias_info.update_required[i]=false;
-								p_self->alias_info.update_succeeded[i]=true;
+								info->alias_info.update_required[i]=false;
+								info->alias_info.update_succeeded[i]=true;
 
 								DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "Alias '%s' to IP '%s' updated successfully.\n",
-											p_self->alias_info.names[i].name,
-											p_self->info.my_ip_address.name[ip_store]));
+											info->alias_info.names[i].name,
+											p_self->info[srv_index].i_face.my_ip_address.name[ip_store]));
 
 								if (p_self->external_command)
 
@@ -1830,24 +1982,24 @@
 							}
 							else {
 
-								p_self->alias_info.update_succeeded[i]=false;
+								info->alias_info.update_succeeded[i]=false;
 
-								if (!(p_self->info.p_dns_system->p_rsp_config_func((struct _DYN_DNS_CLIENT*)p_self,http_tr.p_rsp))) {
+								if (!(info->p_dns_system->p_rsp_config_func((struct _DYN_DNS_CLIENT*)p_self,http_tr.p_rsp))) {
 
-									DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "Error updating alias %s\n",p_self->alias_info.names[i].name));
+									DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "Error updating alias %s\n",info->alias_info.names[i].name));
 								} 
 								else {
 
 									DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "Error validating DYNDNS svr answer. Check usr,pass,hostname!\n"));
 
-									p_self->alias_info.fatal_error[i]=TRUE;
+									info->alias_info.fatal_error[i]=TRUE;
 
 									DBG_PRINTF((LOG_CRIT,"C:" MODULE_TAG "\n"\
 												ERROR_FLAG \
 												"Fatal dyndns server update error for "\
 												"alias, %s.\nThis client should be stopped and corrected for "\
 												"configuration errors, and restarted...\n" \
-												ERROR_FLAG,p_self->alias_info.names[i].name));
+												ERROR_FLAG,info->alias_info.names[i].name));
 
 									config_fails++;
 									updates_needed--;
@@ -1864,7 +2016,7 @@
 				}
 
 				{
-					RC_TYPE rc2 = http_client_shutdown(&p_self->http_to_dyndns);
+					RC_TYPE rc2 = http_client_shutdown(&info->http_to_dyndns);
 
 					if (!(rc2==RC_OK))
 
@@ -1872,7 +2024,7 @@
 
 				}				
 
-				if (i<p_self->alias_info.count-1)
+				if (i<info->alias_info.count-1)
 
 					os_sleep_ms(1000);
 			}
@@ -1883,7 +2035,7 @@
 	}
 	while(0);
 
-	return update_update_state(p_self,updates_needed,success_updates,config_fails,&rc);
+	return update_update_state(p_self,updates_needed,success_updates,config_fails,rc,srv_index);
 }
 
 RC_TYPE get_default_config_data(DYN_DNS_CLIENT *p_self)
@@ -1895,8 +2047,9 @@
 
 	do
 	{
-		p_self->info.p_dns_system = get_dns_system_by_id(DYNDNS_MY_DNS_SYSTEM);
-		if (p_self->info.p_dns_system == NULL)
+
+		p_self->info[0].p_dns_system = get_dns_system_by_id(DYNDNS_MY_DNS_SYSTEM);
+		if (p_self->info[0].p_dns_system == NULL)
 		{
 			rc = RC_DYNDNS_INVALID_DNS_SYSTEM_DEFAULT;
 			break;
@@ -1973,7 +2126,7 @@
 	return rc;
 }
 
-static RC_TYPE get_encoded_user_passwd(DYN_DNS_CLIENT *p_self)
+static RC_TYPE get_encoded_user_passwd(DYN_DNS_CLIENT *p_self,char srv_cnt)
 {
 	RC_TYPE		rc=RC_OK;
 	char		*str_uri_encoded;
@@ -1983,23 +2136,23 @@
 	int		actual_len;
 
 
-	if (!(p_self->info.credentials.my_password) && !(p_self->info.credentials.my_username))
+	if (!(p_self->info[srv_cnt].credentials.my_password) && !(p_self->info[srv_cnt].credentials.my_username))
 
 		return RC_OK;
 
 	size=strlen(format)+1;
 
-	if (!(p_self->info.credentials.my_password))
+	if (!(p_self->info[srv_cnt].credentials.my_password))
 
-		p_self->info.credentials.my_password=safe_malloc(1);
+		p_self->info[srv_cnt].credentials.my_password=safe_malloc(1);
 
-	size+=strlen(p_self->info.credentials.my_password);
+	size+=strlen(p_self->info[srv_cnt].credentials.my_password);
 
-	if (!(p_self->info.credentials.my_username))
+	if (!(p_self->info[srv_cnt].credentials.my_username))
 
-		p_self->info.credentials.my_username=safe_malloc(1);
+		p_self->info[srv_cnt].credentials.my_username=safe_malloc(1);
 
-	size+=strlen(p_self->info.credentials.my_username);
+	size+=strlen(p_self->info[srv_cnt].credentials.my_username);
 
 	do
 	{
@@ -2011,8 +2164,8 @@
 		}
 
 		actual_len = sprintf(p_tmp_buff, format,
-		                     p_self->info.credentials.my_username,
-		                     p_self->info.credentials.my_password);
+		                     p_self->info[srv_cnt].credentials.my_username,
+		                     p_self->info[srv_cnt].credentials.my_password);
 
 		if (actual_len >= size)
 		{
@@ -2022,15 +2175,15 @@
 
 		/*encode*/
 
-		p_self->info.credentials.p_enc_usr_passwd_buffer =
+		p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer =
 		    b64encode(utf_8_uri_encoded(&str_uri_encoded,p_tmp_buff,"&#",";"));
 
 		free(str_uri_encoded);
 
-		p_self->info.credentials.encoded =
-		    (p_self->info.credentials.p_enc_usr_passwd_buffer != NULL);
+		p_self->info[srv_cnt].credentials.encoded =
+		    (p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer != NULL);
 
-		p_self->info.credentials.size = strlen(p_self->info.credentials.p_enc_usr_passwd_buffer);
+		p_self->info[srv_cnt].credentials.size = strlen(p_self->info[srv_cnt].credentials.p_enc_usr_passwd_buffer);
 	}
 	while(0);
 
@@ -2063,6 +2216,8 @@
 	DYN_DNS_CLIENT	*p_self;
 	BOOL		http_to_dyndns_constructed = FALSE;
 	BOOL		http_to_ip_constructed = FALSE;
+	char i;
+
 
 	if (pp_self == NULL)
 	{
@@ -2099,25 +2254,30 @@
 		}
 
 
-		rc = http_client_construct(&p_self->http_to_ip_server);
-		if (rc != RC_OK)
-		{
-			rc = RC_OUT_OF_MEMORY;
-			break;
-		}
+		for (i=0;i<MAX_DNS_SERVER;i++) {
 
-		p_self->info.my_ip_address.name[ip_store]=safe_malloc(DYNDNS_MY_IP_ADDRESS_LENGTH);
-		p_self->info.my_ip_address.name[ip_4]=safe_malloc(DYNDNS_MY_IP_ADDRESS_LENGTH);
-		p_self->info.my_ip_address.name[ip_6]=safe_malloc(DYNDNS_MY_IP_ADDRESS_LENGTH);
+			rc = http_client_construct(&p_self->info[i].http_to_ip_server);
+			if (rc != RC_OK)
+			{
+				rc = RC_OUT_OF_MEMORY;
+				break;
+			}
 
-		http_to_ip_constructed = TRUE;
+			rc = http_client_construct(&p_self->info[i].http_to_dyndns);
+			if (rc != RC_OK)
+			{
+				rc = RC_OUT_OF_MEMORY;
+				break;
+			}
 
-		rc = http_client_construct(&p_self->http_to_dyndns);
-		if (rc != RC_OK)
-		{
-			rc = RC_OUT_OF_MEMORY;
-			break;
+			p_self->info[i].i_face.my_ip_address.name[ip_store]=safe_malloc(DYNDNS_MY_IP_ADDRESS_LENGTH);
+			p_self->info[i].i_face.my_ip_address.name[ip_4]=safe_malloc(DYNDNS_MY_IP_ADDRESS_LENGTH);
+			p_self->info[i].i_face.my_ip_address.name[ip_6]=safe_malloc(DYNDNS_MY_IP_ADDRESS_LENGTH);
+
+			p_self->info[i].credentials.p_enc_usr_passwd_buffer = NULL;
 		}
+
+		http_to_ip_constructed = TRUE;
 		http_to_dyndns_constructed = TRUE;
 
 		(p_self)->cmd = NO_CMD;
@@ -2125,8 +2285,6 @@
 		(p_self)->total_iterations = DYNDNS_DEFAULT_ITERATIONS;
 		(p_self)->initialized = FALSE;
 
-		p_self->info.credentials.p_enc_usr_passwd_buffer = NULL;
-
 		p_self->lang_file = NULL;
 
 	}
@@ -2146,25 +2304,33 @@
 		{
 			free (p_self->p_work_buffer);
 		}
-		if (http_to_dyndns_constructed)
-		{
-			http_client_destruct(&p_self->http_to_dyndns);
-		}
-		if (http_to_ip_constructed)
-		{
-			http_client_destruct(&p_self->http_to_ip_server);
-		}
-		if (p_self->info.my_ip_address.name[ip_store])
-		{
-			free(p_self->info.my_ip_address.name[ip_store]);
-		}
-		if (p_self->info.my_ip_address.name[ip_4])
 		{
-			free(p_self->info.my_ip_address.name[ip_4]);
+			for (i=0;i<MAX_DNS_SERVER;i++) {
+
+				http_client_destruct(&p_self->info[i].http_to_dyndns);
+			}
 		}
-		if (p_self->info.my_ip_address.name[ip_6])
 		{
-			free(p_self->info.my_ip_address.name[ip_6]);
+			for (i=0;i<MAX_DNS_SERVER;i++) {
+
+				http_client_destruct(&p_self->info[i].http_to_ip_server);
+			}
+
+			for (i=0;i<MAX_DNS_SERVER;i++) {
+
+				if (p_self->info[i].i_face.my_ip_address.name[ip_store])
+				{
+					free(p_self->info[i].i_face.my_ip_address.name[ip_store]);
+				}
+				if (p_self->info[i].i_face.my_ip_address.name[ip_4])
+				{
+					free(p_self->info[i].i_face.my_ip_address.name[ip_4]);
+				}
+				if (p_self->info[i].i_face.my_ip_address.name[ip_6])
+				{
+					free(p_self->info[i].i_face.my_ip_address.name[ip_6]);
+				}
+			}
 		}
 	}
 
@@ -2177,7 +2343,10 @@
 */	
 RC_TYPE dyn_dns_destruct(DYN_DNS_CLIENT *p_self)
 {
-	RC_TYPE rc;
+	char	i;
+	char	ii;
+
+
 	if (p_self == NULL)
 	{
 		return RC_OK;
@@ -2188,15 +2357,51 @@
 		dyn_dns_shutdown(p_self);
 	}
 
-	rc = http_client_destruct(&p_self->http_to_ip_server);
-	if (rc != RC_OK)
-	{
+	free(p_self->ip_server_name_global.name);
+	p_self->ip_server_name_global.name=NULL;
+	free(p_self->ip_server_name_global.url);
+	p_self->ip_server_name_global.url=NULL;
 
-	}
+	for (i=0;i<MAX_DNS_SERVER;i++) {
 
-	rc = http_client_destruct(&p_self->http_to_dyndns);
-	if (rc != RC_OK)
-	{
+		http_client_destruct(&p_self->info[i].http_to_ip_server);
+		http_client_destruct(&p_self->info[i].http_to_dyndns);
+
+		free(p_self->info[i].i_face.my_ip_address.name[ip_store]);
+		p_self->info[i].i_face.my_ip_address.name[ip_store]=NULL;
+
+		free(p_self->info[i].i_face.my_ip_address.name[ip_4]);
+		p_self->info[i].i_face.my_ip_address.name[ip_4]=NULL;
+
+		free(p_self->info[i].i_face.my_ip_address.name[ip_6]);
+		p_self->info[i].i_face.my_ip_address.name[ip_6]=NULL;
+
+		free(p_self->info[i].credentials.p_enc_usr_passwd_buffer);
+		p_self->info[i].credentials.p_enc_usr_passwd_buffer=NULL;
+
+		free(p_self->info[i].credentials.my_username);
+		p_self->info[i].credentials.my_username=NULL;
+
+		free(p_self->info[i].credentials.my_password);
+		p_self->info[i].credentials.my_password=NULL;
+
+		free(p_self->info[i].dyndns_server_name.url);
+		p_self->info[i].dyndns_server_name.url=NULL;
+
+		free(p_self->info[i].proxy_server_name.name);
+		p_self->info[i].proxy_server_name.name=NULL;
+
+		free(p_self->info[i].ip_server_name.name);
+		p_self->info[i].ip_server_name.name=NULL;
+
+		free(p_self->info[i].ip_server_name.url);
+		p_self->info[i].ip_server_name.url=NULL;
+
+		for (ii=0;ii<p_self->info[i].alias_info.count;ii++) {
+
+			free(p_self->info[i].alias_info.names[ii].name);
+			p_self->info[i].alias_info.names[ii].name=NULL;
+		}
 
 	}
 
@@ -2212,11 +2417,6 @@
 		p_self->p_req_buffer = NULL;
 	}
 
-	if (p_self->info.credentials.p_enc_usr_passwd_buffer != NULL)
-	{
-		free(p_self->info.credentials.p_enc_usr_passwd_buffer);
-		p_self->info.credentials.p_enc_usr_passwd_buffer = NULL;
-	}
 
 	if (p_self->lang_file != NULL)
 	{
@@ -2244,51 +2444,6 @@
 		p_self->time_cache=NULL;
 	}
 
-	if (p_self->info.credentials.my_username != NULL)
-	{
-
-		free(p_self->info.credentials.my_username);
-		p_self->info.credentials.my_username=NULL;
-	}
-
-	if (p_self->info.credentials.my_password != NULL)
-	{
-
-		free(p_self->info.credentials.my_password);
-		p_self->info.credentials.my_password=NULL;
-	}
-
-	{
-		int i=0;
-
-
-		while (1) {
-
-			if (!(p_self->alias_info.names[i].name != NULL))
-
-				break;
-			else
-			{
-
-				free(p_self->alias_info.names[i].name);
-				p_self->alias_info.names[i].name=NULL;
-			}
-		}
-	}
-
-	if (p_self->info.ip_server_url != NULL)
-	{
-
-		free(p_self->info.ip_server_url);
-		p_self->info.ip_server_url=NULL;
-	}
-
-	if (p_self->info.dyndns_server_url != NULL)
-	{
-
-		free(p_self->info.dyndns_server_url);
-		p_self->info.dyndns_server_url=NULL;
-	}
 
 	if (p_self->external_command != NULL)
 	{
@@ -2297,40 +2452,8 @@
 		p_self->external_command=NULL;
 	}
 
-	if (p_self->info.proxy_server_name.name[ip_store] != NULL)
-	{
-
-		free(p_self->info.proxy_server_name.name[ip_store]);
-		p_self->info.proxy_server_name.name[ip_store]=NULL;
-	}
-
-	if (p_self->info.ip_server_name.name[ip_store] != NULL)
-	{
-
-		free(p_self->info.ip_server_name.name[ip_store]);
-		p_self->info.ip_server_name.name[ip_store]=NULL;
-	}
-
-	if (p_self->info.my_ip_address.name[ip_store] != NULL)
-	{
-
-		free(p_self->info.my_ip_address.name[ip_store]);
-		p_self->info.my_ip_address.name[ip_store]=NULL;
-	}
-
-	if (p_self->info.my_ip_address.name[ip_4] != NULL)
-	{
-
-		free(p_self->info.my_ip_address.name[ip_4]);
-		p_self->info.my_ip_address.name[ip_4]=NULL;
-	}
-
-	if (p_self->info.my_ip_address.name[ip_6] != NULL)
-	{
-
-		free(p_self->info.my_ip_address.name[ip_6]);
-		p_self->info.my_ip_address.name[ip_6]=NULL;
-	}
+	free(p_self->p_pidfilename);
+	p_self->p_pidfilename = NULL;
 
 	ip_cache_list_destruct(&p_self->ip_cache_list);
 
@@ -2404,82 +2527,12 @@
 	return RC_OK;
 }
 
-static RC_TYPE do_check_alias_update_table(DYN_DNS_CLIENT *p_self)
-{
-	int		i;
-	DYNDNS_IPV	ip_v;
-	BOOL		is_dyndns_dual;
-	BOOL		is_cache_current;
-	char		*ip_alias_type;
-	char		*ip_alias_type2;
-
-
-	for (i = 0; i < p_self->alias_info.count; ++i)
-	{
-		ip_alias_type2=NULL;
-
-		ip_v=p_self->alias_info.names[i].ip_v_enum;
-
-		/*ip type DUAL_LIST is dual of form, 1.1.1.1,::1 -- both ip types in one update connection*/
-		if (!(is_dyndns_dual=(NULL!=strstr(p_self->alias_info.names[i].ip_v,DUAL_LIST)))) {
-
-			ip_alias_type=safe_malloc(strlen(p_self->info.my_ip_address.name[ip_v])+strlen(p_self->alias_info.names[i].name)+strlen(p_self->alias_info.names[i].ip_v)+3);
-			sprintf(ip_alias_type,"%s %s:%s",p_self->info.my_ip_address.name[ip_v],p_self->alias_info.names[i].name,p_self->alias_info.names[i].ip_v);
-
-			is_cache_current=!(ip_cache_list_index_of(&p_self->ip_cache_list,ip_alias_type)==-1);
-		}
-		else {
-
-			ip_alias_type=safe_malloc(strlen(p_self->info.my_ip_address.name[ip_4])+strlen(p_self->alias_info.names[i].name)+6);
-			sprintf(ip_alias_type,"%s %s:ip4",p_self->info.my_ip_address.name[ip_4],p_self->alias_info.names[i].name);
-
-			ip_alias_type2=safe_malloc(strlen(p_self->info.my_ip_address.name[ip_6])+strlen(p_self->alias_info.names[i].name)+6);
-			sprintf(ip_alias_type2,"%s %s:ip6",p_self->info.my_ip_address.name[ip_6],p_self->alias_info.names[i].name);
-
-			is_cache_current=!(ip_cache_list_index_of(&p_self->ip_cache_list,ip_alias_type)==-1 || ip_cache_list_index_of(&p_self->ip_cache_list,ip_alias_type2)==-1);
-		}
-
-		p_self->alias_info.update_required[i] = 
-
-			/*ip address changed, or failed update?*/
-			(!is_cache_current
-
-			/*pending failed update?*/
-			|| (is_update_pending && !(p_self->alias_info.update_succeeded[i]))
-
-			/*administrative update?*/
-			|| (!(p_self->forced_update_counter)));
-
-		if (p_self->alias_info.update_required[i]) {	
-	
-			if (is_dyndns_dual)
-
-				DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "IP address for alias '%s:%s' needs update to '%s,%s'...\n",
-				        p_self->alias_info.names[i].name,p_self->alias_info.names[i].ip_v, 
-						p_self->info.my_ip_address.name[ip_4],p_self->info.my_ip_address.name[ip_6]));
-
-
-			else
-
-				DBG_PRINTF((LOG_WARNING,"W:" MODULE_TAG "IP address for alias '%s:%s' needs update to '%s'...\n",
-				        p_self->alias_info.names[i].name,p_self->alias_info.names[i].ip_v, 
-						p_self->info.my_ip_address.name[ip_v]));
-			
-			p_self->alias_info.update_required[i]=!(p_self->alias_info.fatal_error[i]);
-		}
-
-		free(ip_alias_type); free(ip_alias_type2);
-	}
-	
-	return RC_OK;
-}
-
-static RC_TYPE do_handle_bad_config(DYN_DNS_CLIENT *p_self,int i)
+static RC_TYPE do_handle_bad_config(DYN_DNS_CLIENT *p_self,int i,char srv_cnt)
 {
 
 	/*might want to sound an error specific alert too*/
 
-	if (i<p_self->alias_info.count)
+	if (i<p_self->info[srv_cnt].alias_info.count)
 
 		DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "\n"\
 					ERROR_FLAG \
@@ -2487,7 +2540,7 @@
 					"fatal dyndns server update error for "\
 					"alias, %s.\nThis client should be stopped and corrected for "\
 					"configuration errors, and restarted...\n" \
-					ERROR_FLAG,p_self->alias_info.names[i].name));
+					ERROR_FLAG,p_self->info[srv_cnt].alias_info.names[i].name));
 	else
 
 		DBG_PRINTF((LOG_ERR,"E:" MODULE_TAG "\n"\
@@ -2501,21 +2554,21 @@
 	return RC_ERROR;
 }
 
-static RC_TYPE dyn_dns_handle_bad_config(DYN_DNS_CLIENT *p_self)
+static RC_TYPE dyn_dns_handle_bad_config(DYN_DNS_CLIENT *p_self,char srv_cnt)
 {
 
 	/*ip update subsequent dns server return bad config related error*/
 
 	int	i;
 
-	for (i=0;i<p_self->alias_info.count;i++) {
+	for (i=0;i<p_self->info[srv_cnt].alias_info.count;i++) {
 
-		if (p_self->alias_info.fatal_error[i])
+		if (p_self->info[srv_cnt].alias_info.fatal_error[i])
 
 			break;
 	}
 
-	return do_handle_bad_config(p_self,i);
+	return do_handle_bad_config(p_self,i,srv_cnt);
 }
 
 /*
@@ -2528,7 +2581,7 @@
 		- get the current DYN DNS address from DYN DNS server
 		- compare and update if neccessary
 */
-RC_TYPE dyn_dns_update_ip(DYN_DNS_CLIENT *p_self)
+RC_TYPE dyn_dns_update_ip(DYN_DNS_CLIENT *p_self,char srv_cnt)
 {
 
 	RC_TYPE	rc=RC_ERROR;
@@ -2543,9 +2596,9 @@
 		return RC_INVALID_POINTER;
 	}
 
-	if (p_self->is_bad_config)
+	if (p_self->is_global_bad_config)
 
-		return dyn_dns_handle_bad_config(p_self);
+		return dyn_dns_handle_bad_config(p_self,srv_cnt);
 
 	do
 	{
@@ -2558,7 +2611,7 @@
 
 				if ((is_exit=(p_self->net_retries<net_attempts++))) {
 
-					is_update_pending=true;
+					p_self->info[srv_cnt].is_update_pending=true;					
 
 					break;
 				}
@@ -2568,7 +2621,7 @@
 			else {
 
 				/*ask IP server something so will respond and give me my IP */
-				rc = check_my_ip_address(p_self);
+				rc = check_my_ip_address(p_self,srv_cnt);
 
 				if (rc==RC_OK)
 
@@ -2578,7 +2631,7 @@
 
 				if (p_self->net_retries<ip_attempts++) {
 
-					is_update_pending=true;
+					p_self->info[srv_cnt].is_update_pending=true;
 
 					break;
 				}
@@ -2605,7 +2658,7 @@
 			DBG_PRINTF((LOG_INFO,"I:DYNDNS: dyn_dns_update_ip checking alias table...\n"));
 
 			/*step through aliases list, resolve them and check if they point to my IP*/
-			rc = do_check_alias_update_table(p_self);
+			rc = do_check_alias_update_table(p_self,srv_cnt);
 			if (rc != RC_OK)
 			{
 				break;
@@ -2621,7 +2674,7 @@
 
 					if (p_self->net_retries<net_attempts++) {
 
-						is_update_pending=true;
+						p_self->info[srv_cnt].is_update_pending=true;
 
 						break;
 					}
@@ -2631,11 +2684,13 @@
 				else {
 
 					/*update IPs marked as not identical with my IP*/
-					rc = do_update_alias_table(p_self,&is_forced_update_reset);
+					rc = do_update_alias_table(p_self,&is_forced_update_reset,srv_cnt);
 
 					if (rc==RC_OK) {
 
-						is_update_pending=false;
+						p_self->info[srv_cnt].is_update_pending=false;
+
+						p_self->info[srv_cnt].is_bad_config=false;
 
 						break;
 					}
@@ -2644,14 +2699,18 @@
 
 					if (p_self->net_retries<ip_attempts++) {
 
-						is_update_pending=(!(rc==RC_DYNDNS_RSP_CONFIG));						
+						p_self->info[srv_cnt].is_update_pending=(!(rc==RC_DYNDNS_RSP_CONFIG));
+
+						p_self->info[srv_cnt].is_bad_config=!(p_self->info[srv_cnt].is_update_pending);
 						
 						break;
 					}
 
 					if (rc==RC_DYNDNS_RSP_CONFIG) { /*might want to trigger alert here*/
 
-						is_update_pending=false;
+						p_self->info[srv_cnt].is_update_pending=false;
+
+						p_self->info[srv_cnt].is_bad_config=false;
 
 						break;
 					}
@@ -2926,7 +2985,7 @@
 static void alert_if_offline_thread(void *p_data)
 #endif
 {
-	DYN_DNS_CLIENT		*p_dyndns;
+	DYN_DNS_CLIENT	*p_dyndns;
 
 	if (p_data) {
 
@@ -3269,7 +3328,7 @@
 
 
 	*p_ras_thread_data=construct_and_launch_trap_ras_events(dyn_dns_update_ip_handler,p_dyndns,p_dyndns->\
-		                   http_to_ip_server.super.super.p_remote_host_name,\
+		                   info[0].http_to_ip_server.super.super.p_remote_host_name,\
 		                   p_dyndns->dbg.level);
 
 	if (*p_ras_thread_data) {
@@ -3307,20 +3366,6 @@
 	*src+=inc;
 }
 
-RC_TYPE dyn_dns_reinit(DYN_DNS_CLIENT *p_dyndns)
-{
-
-	RC_TYPE	rc=RC_OK;
-
-
-	dyn_dns_shutdown(p_dyndns);
-
-	rc=do_dyn_dns_init(p_dyndns);
-
-
-	return rc;
-}
-
 /*
 	read in ip cache file lines containing ip address, alias pairs
 	rewrite the file so lines not containing an ip type (ip4, ip6, auto) get ip type, auto
@@ -3438,6 +3483,20 @@
 	return rc;
 }
 
+int number_of_aliases(DYN_DNS_CLIENT *p_dyndns)
+{
+	char	i;
+	int	alias_count=0;
+
+
+	for (i=0;i<MAX_DNS_SERVER;i++) {
+
+		alias_count+=p_dyndns->info[i].alias_info.count;
+	}
+
+	return alias_count;
+}
+
 static int increment_iterations(DYN_DNS_CLIENT *p_dyndns)
 {
 	int	iterations;
@@ -3472,17 +3531,17 @@
 
 #ifdef USE_THREADS
 
-	void	**p_ras_thread_data=p_data;
+	void			**p_ras_thread_data=p_data;
 #endif
 
 #else
 	RAS_THREAD_DATA	**p_ras_thread_data= (RAS_THREAD_DATA **) p_data;
-	int		regParamsC=1;
-	wchar_t		*regArgs[50];
-	char		*utf_8_argv[50];
-	int		i=0;
+	int             regParamsC=1;
+	wchar_t         *regArgs[50];
+	char            *utf_8_argv[50];
+	int             i=0;
 
-	RC_TYPE		rc_reg=RC_ERROR;
+	RC_TYPE         rc_reg=RC_ERROR;
 #endif
 
 #ifdef USE_THREADS
@@ -3504,7 +3563,6 @@
 		return rc;
 	}
 
-
 #ifdef _WIN32
 
 	SetLastError(0);
@@ -3538,7 +3596,6 @@
 	/* read cmd line options and set object properties*/
 	rc_cmd_line = get_config_data(p_dyndns, argc, argv);
 
-
 #ifndef _WIN32
 
 	if (rc_cmd_line != RC_OK || p_dyndns->abort)
@@ -3551,7 +3608,6 @@
 
 		return rc_cmd_line;
 
-
 	if (p_dyndns->lang_hard_coded) {
 
 		/*use hard coded defaults -- don't use default locale file*/
@@ -3622,6 +3678,35 @@
 		}
 	}
 
+	/*if pid-file wanted, create it*/
+	if (p_dyndns->p_pidfilename) {
+		
+		if (strlen(p_dyndns->p_pidfilename) != 0)
+		{
+			FILE *fp=NULL;
+			int obj=0;
+			char pid[7];
+
+
+			if ((fp = utf_fopen(p_dyndns->p_pidfilename, "w")))
+			{
+
+#ifndef _WIN32
+				if (0<snprintf(pid, 7, "%d\n", getpid()))
+#else
+				if (0<_snprintf(pid, 7, "%d\n", _getpid()))
+#endif
+					obj = fwrite(pid, strlen(pid), 1, fp);
+
+				fclose(fp);
+			}
+			if (!fp || obj != 1)
+			{
+				return RC_FILE_IO_OPEN_ERROR;
+			}
+		}
+	}
+
 	dyn_dns_print_hello(NULL);
 
 	/*  now that log is open, report any command line errors eventhough registry params made up for them --
@@ -3641,6 +3726,7 @@
 
 	rc = dyn_dns_init(p_dyndns);
 
+
 	if (rc==RC_OK) {
 
 		*init_flag=true;
@@ -3654,7 +3740,18 @@
 
 	if (rc==RC_OK) {
 
-		rc = get_encoded_user_passwd(p_dyndns);
+		char	i;
+		RC_TYPE	pw_rc;
+
+
+		for (i=0;i<p_dyndns->srv_cnt;i++) {
+
+			if (!(RC_OK==(pw_rc=get_encoded_user_passwd(p_dyndns,i))))
+
+				if (rc==RC_OK) /*return first of any error(s)*/
+
+					rc=pw_rc;
+		}
 
 #ifdef _WIN32
 
@@ -3702,6 +3799,9 @@
 	RC_TYPE	rc=RC_OK;
 	BOOL	init_flag=FALSE;
 	int	current_iteration=0;
+	char	bad_config_count;
+	char	i;
+	int	success_count;
 
 #ifdef _WIN32
 
@@ -3723,23 +3823,45 @@
 
 		do
 		{
+			/*state across multiple server updates*/
+			bad_config_count=0;
+			is_global_success_updates=false; /*flagged in update_update_state*/
+			is_global_in_proc_update_pending=false;			
+			success_count=0;
 
-			/*update IP address in a loop*/
-			
-			if (((rc=dyn_dns_update_ip(p_dyndns))==RC_OK))
+			for (i=0;i<p_dyndns->srv_cnt;i++) {
 
-				increment_iterations(p_dyndns);
+				if (p_dyndns->cmd==CMD_STOP)
 
-			else {
+					break;
 
-				DBG_PRINTF((LOG_WARNING,"W:'%s' (0x%x) updating the IPs. (it %d)\n",
-					        errorcode_get_name(rc), rc, current_iteration));
+				if (((rc=dyn_dns_update_ip(p_dyndns,i))==RC_OK))
 
-				p_dyndns->is_bad_config=(rc==RC_DYNDNS_RSP_CONFIG);
+					success_count++;
 
-				rc=dyn_dns_reinit(p_dyndns);
+				else {
+
+					DBG_PRINTF((LOG_WARNING,"W:'%s' (0x%x) updating the IPs. (it %d)\n",
+								errorcode_get_name(rc), rc, current_iteration));
+
+					if (p_dyndns->info[i].is_bad_config)
+
+						bad_config_count++;
+				}
+
+				is_global_in_proc_update_pending=(is_global_in_proc_update_pending || p_dyndns->info[i].is_update_pending);
 			}
 
+			is_global_update_pending=is_global_in_proc_update_pending;
+
+			/*bad config all aliases for all servers?*/
+			p_dyndns->is_global_bad_config=(bad_config_count==p_dyndns->srv_cnt);
+
+			if (success_count==p_dyndns->srv_cnt)
+
+				increment_iterations(p_dyndns);
+
+
 #ifdef USE_SNDFILE
 
 #ifndef USE_THREADS
@@ -3749,8 +3871,7 @@
 
 #endif
 
-			if (p_dyndns->cmd==CMD_STOP)
-			{
+			if (p_dyndns->cmd==CMD_STOP) {
 
 				DBG_PRINTF((LOG_DEBUG,"D:" MODULE_TAG "STOP command received. Exiting.\n"));
 
@@ -3763,15 +3884,6 @@
 
 				break;
 			} 
-			else {
-
-				if (!(rc==RC_OK)) {
-
-					init_flag=false;
-
-					break;
-				}
-			}
 
 			/* sleep the time set in the ->sleep_sec data memeber*/
 			dyn_dns_wait_for_cmd(p_dyndns);
@@ -3780,8 +3892,8 @@
 			inc_update_times(p_dyndns,&(p_dyndns->times_since_last_update),1);
 
 			/*reset the command*/
-			if (!(p_dyndns->cmd==CMD_STOP))
-			{
+			if (!(p_dyndns->cmd==CMD_STOP))	{
+
 				p_dyndns->cmd=NO_CMD;
 			}
 			else {
@@ -3812,8 +3924,8 @@
 #endif
 
 
-	if (init_flag)
-	{
+	if (init_flag) {
+
 		/* dyn_dns_shutdown object */
 		rc = dyn_dns_shutdown(p_dyndns);
 	}
--- src/dyndns.h
+++ src/dyndns.h
@@ -23,7 +23,7 @@
 
 	History:
 		Dec 2007 -- Added get_cmd.h include, for get_config_data_with_error_handling 
-			prototype.
+					prototype.
 */
 
 /*interface for main dydns functions */
@@ -75,7 +75,7 @@
 
 #endif
 
-#define DYNDNS_EXTRA_VERSION
+#define	DYNDNS_EXTRA_VERSION    "-ms_pid_patch_01"
 
 #define DYNDNS_VERSION_STRING	"02.24.44" DYNDNS_VERSION_SND DYNDNS_VERSION_THD DYNDNS_EXTRA_VERSION
 #define DYNDNS_AGENT_NAME	"inadyn-mt/" DYNDNS_VERSION_STRING
@@ -83,26 +83,27 @@
 
 typedef enum
 {
-	DYNDNS_DYNAMIC,
-	DYNDNS_STATIC,
-	DYNDNS_CUSTOM,
-	DYNDNS_DEFAULT,
-	FREEDNS_AFRAID_ORG_DEFAULT,
-	ZONE_EDIT_DEFAULT,
-	CUSTOM_HTTP_BASIC_AUTH,
-	NOIP_DEFAULT,
-	EASYDNS_DEFAULT,
-	DYNDNS_3322_DYNAMIC,
-	SITELUTIONS_DOMAIN,
-	TZO_DEFAULT,
-	DNSOMATIC_DEFAULT,
-	HE_IPV6TB,
-	DYNSIP_DEFAULT,
-	DHIS_DEFAULT,
-	MAJIMOTO_DEFAULT,
-	ZERIGO_DEFAULT,
-	TWODNS_DEFAULT,
-	LAST_DNS_SYSTEM = -1
+    DYNDNS_DYNAMIC,
+    DYNDNS_STATIC,
+    DYNDNS_CUSTOM,
+    DYNDNS_DEFAULT,
+    FREEDNS_AFRAID_ORG_DEFAULT,
+    ZONE_EDIT_DEFAULT,
+    CUSTOM_HTTP_BASIC_AUTH,
+    NOIP_DEFAULT,
+    EASYDNS_DEFAULT,
+    DYNDNS_3322_DYNAMIC,
+    SITELUTIONS_DOMAIN,
+    TZO_DEFAULT,
+    DNSOMATIC_DEFAULT,
+    HE_IPV6TB,
+    HE_DEFAULT,
+    DYNSIP_DEFAULT,
+    DHIS_DEFAULT,
+    MAJIMOTO_DEFAULT,
+    ZERIGO_DEFAULT,
+    TWODNS_DEFAULT,
+    LAST_DNS_SYSTEM = -1
 } DYNDNS_SYSTEM_ID;
 
 /*test values*/
@@ -153,7 +154,6 @@
 /* Conversation with the IP server */
 #define DYNDNS_GET_MY_IP_HTTP_REQUEST  \
 	"GET %s HTTP/1.0\r\nHost: %s\r\nUser-Agent: " DYNDNS_AGENT_NAME " " DYNDNS_EMAIL_ADDR "\r\n\r\n"
-
 /* dyndns.org specific update address format */
 /* 3322.org has the same parameters ...*/
 #define DYNDNS_GET_MY_IP_HTTP_REQUEST_FORMAT \
@@ -226,7 +226,7 @@
 	"GET %s%s&" \
 	"Email=%s&" \
 	"TZOKey=%s&" \
-	"IPAddress=%s " \
+	"IPAddress=%s "	\
 	"HTTP/1.0\r\n" \
 	"Host: %s\r\n" \
 	"User-Agent: "DYNDNS_AGENT_NAME " " DYNDNS_EMAIL_ADDR"\r\n\r\n"
@@ -237,8 +237,18 @@
 	"ipv4b=%s&" \
 	"user_id=%s&" \
 	"pass=%s&" \
-	"tunnel_id=%s " \
+	"tunnel_id=%s "	\
 	"HTTP/1.0\r\n" \
+	"Host: %s\r\n"	\
+	"User-Agent: "DYNDNS_AGENT_NAME " " DYNDNS_EMAIL_ADDR"\r\n\r\n"
+
+/* HE DynDNS specific update request format */
+#define HE_DEFAULT_UPDATE_MY_IP_REQUEST_FORMAT	\
+	"GET %s" \
+	"hostname=%s&"	\
+	"myip=%s " \
+	"HTTP/1.0\r\n"	\
+	"Authorization: Basic %s\r\n"	\
 	"Host: %s\r\n" \
 	"User-Agent: "DYNDNS_AGENT_NAME " " DYNDNS_EMAIL_ADDR"\r\n\r\n"
 
@@ -257,13 +267,13 @@
 #define MAJIMOTO_MY_IP_UPDATE_REQUEST_FORMAT \
 	"GET %s" \
 	"hostname=%s&" \
-	"myip=%s "		\
+	"myip=%s " \
 	"HTTP/1.0\r\n" \
 	"Authorization: Basic %s\r\n" \
 	"Host: %s\r\n" \
 	"User-Agent: "DYNDNS_AGENT_NAME " " DYNDNS_EMAIL_ADDR"\r\n\r\n"
 
-/* zerogo.net specific update request format */
+/* zerigo.net specific update request format */
 #define ZERIGO_MY_IP_UPDATE_REQUEST_FORMAT \
 	"GET %s%s&" \
 	"ip=%s " \
@@ -289,11 +299,11 @@
 
 
 /* SOME DEFAULT CONFIGURATIONS */
-#define DYNDNS_DEFAULT_SLEEP			(600)					/*s*/
-#define DYNDNS_MIN_SLEEP			(30)					/*s*/
-#define DYNDNS_MAX_SLEEP			(10 * 24 * 3600)			/*10 days in s*/
-#define DYNDNS_MIN_FORCED_UPDATE_PERIOD_S	DYNDNS_MIN_SLEEP					
-#define DYNDNS_MAX_FORCED_UPDATE_PERIOD_S	(30 * 24 * 3600)			/* 30 days in sec*/
+#define DYNDNS_DEFAULT_SLEEP			(600)	/*s*/
+#define DYNDNS_MIN_SLEEP			(30)	/*s*/
+#define DYNDNS_MAX_SLEEP			(10 * 24 * 3600)	/*10 days in s*/
+#define DYNDNS_MIN_FORCED_UPDATE_PERIOD_S	DYNDNS_MIN_SLEEP	
+#define DYNDNS_MAX_FORCED_UPDATE_PERIOD_S	(30 * 24 * 3600)	/* 30 days in sec*/
 #define DYNDNS_MY_FORCED_UPDATE_PERIOD_S	DYNDNS_MAX_FORCED_UPDATE_PERIOD_S	/* 30 days in sec*/
 #define DYNDNS_DEFAULT_UPDATE_ADJUST		.5
 #define DYNDNS_MIN_FORCED_UPDATE_ADJUST		-4
@@ -325,13 +335,13 @@
 
 /*attenuation max, min constants -- translate to [-40..0], [-120db..0db]*/
 #define DYNDNS_MAX_WAVE_RANGE			120
-#define DYNDNS_MIN_WAVE_GAIN			-10		/*minimum wave play volume*/
-#define DYNDNS_MAX_WAVE_GAIN			10		/*maximum wave play volume*/
+#define DYNDNS_MIN_WAVE_GAIN			-10	/*minimum wave play volume*/
+#define DYNDNS_MAX_WAVE_GAIN			10	/*maximum wave play volume*/
 
-#define DYNDNS_INFINITE_WAVE			-1		/*infinite times per wave play call to play wave file*/
-#define DYNDNS_DEFAULT_INAUDIBLE		1		/*audible alerts default as on*/
-#define DYNDNS_DEFAULT_ALERT_RETRIES		0		/*network retries before sounding alert*/
-#define DYNDNS_DEFAULT_ALERT_INTERVAL		0		/*ms time between audible alerts*/
+#define DYNDNS_INFINITE_WAVE			-1	/*infinite times per wave play call to play wave file*/
+#define DYNDNS_DEFAULT_INAUDIBLE		1	/*audible alerts default as on*/
+#define DYNDNS_DEFAULT_ALERT_RETRIES		0	/*network retries before sounding alert*/
+#define DYNDNS_DEFAULT_ALERT_INTERVAL		0	/*ms time between audible alerts*/
 #define DYNDNS_DEFAULT_WAVE_FILE		"alarm.wav"	/*default wave file, and path ("current working dir")*/
 #define DYNDNS_DEFAULT_WAVE_BUFF_FACTOR		.25		/*max by which to divide or multiply wave file bytes per second for buffer size*/
 
@@ -347,12 +357,12 @@
 #define DYNDNS_DEFAULT_USER_WAVE_GAIN		10
 
 /*allow attenuate to 120db in DYNDNS_MAX_WAVE_RANGE increments*/
-#define DYNDNS_DECIBEL_STEP			DYNDNS_MAX_WAVE_RANGE/(-1*DYNDNS_MIN_WAVE_GAIN+DYNDNS_MAX_WAVE_GAIN)
+#define DYNDNS_DECIBEL_STEP		DYNDNS_MAX_WAVE_RANGE/(-1*DYNDNS_MIN_WAVE_GAIN+DYNDNS_MAX_WAVE_GAIN)
 
-#define DYNDNS_DEFAULT_WAVE_LOOPS		0		/*default number of times per wave play call to play wave file*/
+#define DYNDNS_DEFAULT_WAVE_LOOPS		0	/*default number of times per wave play call to play wave file*/
 
-#define DYNDNS_DEFAULT_STATUS_INTERVAL		600		/*seconds online status check interval default*/
-#define DYNDNS_DEFAULT_STATUS_OFFLINE_INTERVAL	15		/*seconds online status check interval default, after offline detect*/
+#define DYNDNS_DEFAULT_STATUS_INTERVAL		600	/*seconds online status check interval default*/
+#define DYNDNS_DEFAULT_STATUS_OFFLINE_INTERVAL	15	/*seconds online status check interval default, after offline detect*/
 
 /*local configs*/
 /*address str may contain both ip4,ip6 separated by semi colon*/
@@ -371,6 +381,8 @@
 #define DUAL_LIST		"coupled"
 #define MAX_IP_TYPE_SIZE	8
 
+#define MAX_DNS_SERVER		10
+
 /* typedefs */
 struct _DYN_DNS_CLIENT;
 struct DYNDNS_SYSTEM;
@@ -380,8 +392,8 @@
 /** Function to prepare DNS system specific server requests
 */
 
-typedef int (*DNS_SYSTEM_REQUEST_FUNC)(struct _DYN_DNS_CLIENT *this, int nr, struct DYNDNS_SYSTEM *p_sys_info);
-typedef int (*DNS_SYSTEM_SRV_RESPONSE_OK_FUNC)(struct _DYN_DNS_CLIENT *this, char *p_rsp, const char*p_ok_str);
+typedef int (*DNS_SYSTEM_REQUEST_FUNC)(struct _DYN_DNS_CLIENT *this, char srv_cnt, int nr, struct DYNDNS_SYSTEM *p_sys_info);
+typedef int (*DNS_SYSTEM_SRV_RESPONSE_OK_FUNC)(struct _DYN_DNS_CLIENT *this, char *p_rsp, const char*p_ok_str,char srv_cnt);
 typedef int (*DNS_SYSTEM_SRV_RESPONSE_CONFIG_FUNC)(struct _DYN_DNS_CLIENT *this, char *p_rsp);
 typedef struct
 {
@@ -443,10 +455,17 @@
 
 typedef struct 
 {
-	char	*name[3];
-	int	port;
+	char *name;
+	char *url;
+	int port;
 } DYNDNS_SERVER_NAME;
 
+typedef struct 
+{
+	char *name[3];
+	int port;
+} DYNDNS_MY_IP;
+
 /*a given alias (dyn domain names) can
   be associated with one "ip type", of
   'dual', 'coupled', 'ip4', 'ip6', 'auto',
@@ -465,12 +484,20 @@
 
 typedef struct 
 {
-    	BOOL			my_ip_has_changed[3];
-	BOOL			is_update_ip4;
-	BOOL			is_update_ip6;
-	BOOL			is_update_auto;
-	BOOL			is_got_ip4;
-	BOOL			is_got_ip6;
+	/*multiple of ip types (2 -- IPv4, IPv6)*/
+	DYNDNS_ALIAS_NAME	names[DYNDNS_MAX_ALIAS_NUMBER*2];	
+	int			update_required[DYNDNS_MAX_ALIAS_NUMBER*2];
+	int			update_succeeded[DYNDNS_MAX_ALIAS_NUMBER*2];
+	int			fatal_error[DYNDNS_MAX_ALIAS_NUMBER*2];
+	DYNDNS_HASH_TYPE	hashes[DYNDNS_MAX_ALIAS_NUMBER*2]; 
+	int			count;
+	int			count_dual;
+} DYNDNS_ALIAS_INFO;
+
+typedef struct
+{
+    
+	BOOL my_ip_has_changed[3];
 
 	/*3 strings - ip_4, ip_6 address,
 	  and temp store, ip_store for
@@ -480,28 +507,33 @@
 	  convenient) -- for instance, 
 	  ip type "auto" (based on first 
 	  address returned by ip server)*/
-	DYNDNS_SERVER_NAME	my_ip_address;
+	DYNDNS_MY_IP my_ip_address;
+} DYNDNS_IFACE_INFO;
+
+/*per update server*/
+typedef struct 
+{
+	BOOL is_update_ip4;
+	BOOL is_update_ip6;
+	BOOL is_update_auto;
+	BOOL is_got_ip4;
+	BOOL is_got_ip6;
+
+	HTTP_CLIENT	http_to_ip_server;
+	HTTP_CLIENT	http_to_dyndns;
+
+	DYNDNS_IFACE_INFO	i_face;
 
 	DYNDNS_CREDENTIALS	credentials;
 	DYNDNS_SYSTEM		*p_dns_system;
 	DYNDNS_SERVER_NAME	dyndns_server_name;
-	char			*dyndns_server_url;
 	DYNDNS_SERVER_NAME	ip_server_name;
-	char			*ip_server_url;
 	DYNDNS_SERVER_NAME	proxy_server_name;
-} DYNDNS_INFO_TYPE;
 
-typedef struct 
-{
-	/*multiple of ip types (2 -- IPv4, IPv6)*/
-	DYNDNS_ALIAS_NAME	names[DYNDNS_MAX_ALIAS_NUMBER*2];	
-	int			update_required[DYNDNS_MAX_ALIAS_NUMBER*2];
-	int			update_succeeded[DYNDNS_MAX_ALIAS_NUMBER*2];
-	int			fatal_error[DYNDNS_MAX_ALIAS_NUMBER*2];
-	DYNDNS_HASH_TYPE	hashes[DYNDNS_MAX_ALIAS_NUMBER*2]; 
-	int			count;
-	int			count_dual;
-} DYNDNS_ALIAS_INFO;
+	DYNDNS_ALIAS_INFO	alias_info;
+	BOOL			is_bad_config;
+	BOOL			is_update_pending;
+} DYNDNS_INFO_TYPE;
 
 typedef struct
 {
@@ -533,40 +565,38 @@
 typedef struct DYN_DNS_CLIENT
 {
 	DYN_DNS_CMD	cmd;
-	int		sleep_sec;				/* time between 2 updates*/
+	int		sleep_sec;			/* time between 2 updates*/
 	unsigned	forced_update_period_sec;
-	float		forced_update_adjust;			/* how to round forced update calculation */
-	unsigned	forced_update_period_sec_orig;		/* original read from cmd line */
+	float		forced_update_adjust;		/* how to round forced update calculation */
+	unsigned	forced_update_period_sec_orig;	/* original read from cmd line */
 	int		times_since_last_update;
-	int		forced_update_times;			/* the same forced update period counted in sleep periods*/
-	unsigned	cmd_check_period;			/*time to wait for a command*/
-	unsigned	forced_update_counter;			/*cmd_check_periods tracking forced_update_period expiration*/	
+	int		forced_update_times;		/* the same forced update period counted in sleep periods*/
+	unsigned	cmd_check_period;		/*time to wait for a command*/
+	unsigned	forced_update_counter;		/*cmd_check_periods tracking forced_update_period expiration*/	
 	int		is_forced_update_attempted;
 	int		total_iterations;
 	int		iterations;
-	int		net_retries;				/*failed comm retries*/
-	long		retry_interval;				/*miliseconds wait interval between retries*/
+	int		net_retries;			/*failed comm retries*/
+	long		retry_interval;			/*miliseconds wait interval between retries*/
 	long		retry_pending_interval;
 	int		retry_pending_off;
-	char		*lang_file;				/*language (locale) file full path, and file name*/
-	int		lang_hard_coded;			/*flagged when --lang_file parameter with empty option*/
-	int		audible_off;				/*compiled with USE_SNDFILE defined, but want run without*/
-	char		*wave_file;				/*network status alerts wave file full path, and file name*/
-	int		wave_loops;				/*number of times per wave play call to play wave file*/
-	float		wave_gain;				/*volume at which to play wave file*/
-	int		alert_retries;				/*network retries before sounding alert*/
-	int		alert_interval;				/*time betweens sounding network status alarm*/
-	int		status_interval;			/*ms between online status checks*/
-	int		status_offline_interval;		/*ms between online status checks, after offline detect*/
-	float		wave_buff_factor;			/*multiple of wave file bytes per second*/
+	char		*lang_file;			/*language (locale) file full path, and file name*/
+	int		lang_hard_coded;		/*flagged when --lang_file parameter with empty option*/
+	int		audible_off;			/*compiled with USE_SNDFILE defined, but want run without*/
+	char		*wave_file;			/*network status alerts wave file full path, and file name*/
+	int		wave_loops;			/*number of times per wave play call to play wave file*/
+	float		wave_gain;			/*volume at which to play wave file*/
+	int		alert_retries;			/*network retries before sounding alert*/
+	int		alert_interval;			/*time betweens sounding network status alarm*/
+	int		status_interval;		/*ms between online status checks*/
+	int		status_offline_interval;	/*ms between online status checks, after offline detect*/
+	float		wave_buff_factor;		/*multiple of wave file bytes per second*/
 
 	BOOL		initialized;
 	BOOL		run_in_background;
 	BOOL		debug_to_syslog;
 	BOOL		change_persona;
 
-	HTTP_CLIENT		http_to_ip_server;
-	HTTP_CLIENT		http_to_dyndns;
 	HTTP_TRANSACTION	http_tr;
 	char			*p_work_buffer;		/* for HTTP responses*/
 	int			work_buffer_size;
@@ -576,23 +606,29 @@
 	char			*time_cache;
 	char			*ip_cache;
 
-
 	USER_INFO		sys_usr_info;		/*info about the current account running inadyn*/
-	DYNDNS_INFO_TYPE	info;			/*servers, names, passwd*/
-	DYNDNS_INFO_TYPE	info_online_status;	/*info about url to reach to confirm online status -- defaults to info*/
 
-	DYNDNS_ALIAS_INFO	alias_info;
+
+
+	DYNDNS_INFO_TYPE	info[MAX_DNS_SERVER];	/*servers, names, passwd*/
+	char			srv_cnt;
 
 	IP_CACHE_LIST		ip_cache_list;		/*read in from ip cache file written on ddns update*/
 
+	DYNDNS_SERVER_NAME	info_online_status;	/*info about url to reach to confirm online status -- defaults to info*/
+
 	BOOL			abort_on_network_errors;
 	BOOL			force_addr_update;
 	BOOL			use_proxy;
 	BOOL			abort;
 	BOOL			wildcard;
-	BOOL			is_bad_config;
+	BOOL			is_global_bad_config;	/*all servers*/
+
+	DYNDNS_SERVER_NAME	ip_server_name_global;
+
+	char 			*p_pidfilename;
 
-	IPV6_PRIV_EXT	ipv6_priv_ext;
+	IPV6_PRIV_EXT		ipv6_priv_ext;
 
 	/*dbg*/
 	DBG_TYPE		dbg;
@@ -669,7 +705,7 @@
 		- compare and update if neccessary
 */
 
-RC_TYPE dyn_dns_update_ip(DYN_DNS_CLIENT *p_self);
+RC_TYPE dyn_dns_update_ip(DYN_DNS_CLIENT *p_self,char srv_cnt);
 
 /* MAIN - Dyn DNS update entry point.*/
 
--- src/errorcode.c
+++ src/errorcode.c
@@ -32,56 +32,57 @@
 } ERROR_NAME;
 
 static const ERROR_NAME global_error_table[]  =
-{
-	{RC_OK,"RC_OK"},
-	{RC_ERROR,"RC_ERROR"},
-	{RC_INVALID_POINTER,"RC_INVALID_POINTER"},
-	{RC_OUT_OF_MEMORY,"RC_OUT_OF_MEMORY"},
-	{RC_OUT_BUFFER_OVERFLOW,"RC_OUT_BUFFER_OVERFLOW"},
-
-
-	{RC_IP_SOCKET_CREATE_ERROR,"RC_IP_SOCKET_CREATE_ERROR"},
-	{RC_IP_BAD_PARAMETER,"RC_IP_BAD_PARAMETER"},
-	{RC_IP_INVALID_REMOTE_ADDR,"RC_IP_INVALID_REMOTE_ADDR"},
-	{RC_IP_CONNECT_FAILED,"RC_IP_CONNECT_FAILED"},
-	{RC_IP_SEND_ERROR,"RC_IP_SEND_ERROR"},
-	{RC_IP_RECV_ERROR,"RC_IP_RECV_ERROR"},
-	{RC_IP_OBJECT_NOT_INITIALIZED,"RC_IP_OBJECT_NOT_INITIALIZED"},
-	{RC_IP_OS_SOCKET_INIT_FAILED,"RC_IP_OS_SOCKET_INIT_FAILED"},
-	{RC_IP_PARSER_INVALID_IP,"RC_IP_PARSER_INVALID_IP"},
-	{RC_IP_INVALID_SOCKET,"RC_IP_INVALID_SOCKET"},
-
-	{RC_TCP_OBJECT_NOT_INITIALIZED,"RC_TCP_OBJECT_NOT_INITIALIZED"},
-
-	{RC_HTTP_OBJECT_NOT_INITIALIZED,"RC_HTTP_OBJECT_NOT_INITIALIZED"},
-	{RC_HTTP_BAD_PARAMETER,"RC_HTTP_BAD_PARAMETER"},
-
-	{RC_DYNDNS_INVALID_IP_ADDR,"RC_DYNDNS_INVALID_IP_ADDR"},
-	{RC_DYNDNS_BUFFER_TOO_SMALL,"RC_DYNDNS_BUFFER_TOO_SMALL"},
-	{RC_DYNDNS_INVALID_IP_ADDR_IN_HTTP_RESPONSE,"RC_DYNDNS_INVALID_IP_ADDR_IN_HTTP_RESPONSE"},
-	{RC_DYNDNS_INVALID_RSP_FROM_IP_SERVER,"RC_DYNDNS_INVALID_RSP_FROM_IP_SERVER"},
-	{RC_DYNDNS_TOO_MANY_ALIASES,"RC_DYNDNS_TOO_MANY_ALIASES"},
-	{RC_DYNDNS_INVALID_OPTION,"RC_DYNDNS_INVALID_OPTION"},
-	{RC_DYNDNS_INVALID_OR_MISSING_PARAMETERS,"RC_DYNDNS_INVALID_OR_MISSING_PARAMETERS"},
-	{RC_DYNDNS_INVALID_DNS_SYSTEM_DEFAULT,"RC_DYNDNS_INVALID_DNS_SYSTEM_DEFAULT"},
-	{RC_DYNDNS_UNRESOLVED_ALIAS,"RC_DYNDNS_UNRESOLVED_ALIAS"},
-	{RC_DYNDNS_RSP_NOTOK,"RC_DYNDNS_RSP_NOTOK"},
-	{RC_DYNDNS_RSP_CONFIG,"RC_DYNDNS_RSP_CONFIG"},
-
-	{RC_CMD_PARSER_INVALID_OPTION,"RC_CMD_PARSER_INVALID_OPTION"},
-	{RC_CMD_PARSER_INVALID_OPTION_ARGUMENT,"RC_CMD_PARSER_INVALID_OPTION_ARGUMENT"},
-
-	{RC_OS_ERROR_INSTALLING_SIGNAL_HANDLER,"RC_OS_ERROR_INSTALLING_SIGNAL_HANDLER"},
-	{RC_OS_INVALID_IP_ADDRESS,"RC_OS_INVALID_IP_ADDRESS"},
-	{RC_OS_FORK_FAILURE,"RC_FORK_FAILURE"},
-	{RC_OS_CHANGE_PERSONA_FAILURE,"RC_OS_CHANGE_PERSONA_FAILURE"},
-
-	{RC_FILE_IO_OPEN_ERROR,"RC_FILE_IO_OPEN_ERROR"},
-	{RC_FILE_IO_READ_ERROR,"RC_FILE_IO_READ_ERROR"},
-	{RC_FILE_IO_OUT_OF_BUFFER,"RC_FILE_IO_OUT_OF_BUFFER"},
+    {
+        {RC_OK,"RC_OK"},
+        {RC_ERROR,"RC_ERROR"},
+        {RC_INVALID_POINTER,"RC_INVALID_POINTER"},
+        {RC_OUT_OF_MEMORY,"RC_OUT_OF_MEMORY"},
+        {RC_OUT_BUFFER_OVERFLOW,"RC_OUT_BUFFER_OVERFLOW"},
+
+
+        {RC_IP_SOCKET_CREATE_ERROR,"RC_IP_SOCKET_CREATE_ERROR"},
+        {RC_IP_BAD_PARAMETER,"RC_IP_BAD_PARAMETER"},
+        {RC_IP_INVALID_REMOTE_ADDR,"RC_IP_INVALID_REMOTE_ADDR"},
+        {RC_IP_CONNECT_FAILED,"RC_IP_CONNECT_FAILED"},
+        {RC_IP_SEND_ERROR,"RC_IP_SEND_ERROR"},
+        {RC_IP_RECV_ERROR,"RC_IP_RECV_ERROR"},
+        {RC_IP_OBJECT_NOT_INITIALIZED,"RC_IP_OBJECT_NOT_INITIALIZED"},
+        {RC_IP_OS_SOCKET_INIT_FAILED,"RC_IP_OS_SOCKET_INIT_FAILED"},
+        {RC_IP_PARSER_INVALID_IP,"RC_IP_PARSER_INVALID_IP"},
+        {RC_IP_INVALID_SOCKET,"RC_IP_INVALID_SOCKET"},
+
+        {RC_TCP_OBJECT_NOT_INITIALIZED,"RC_TCP_OBJECT_NOT_INITIALIZED"},
+
+        {RC_HTTP_OBJECT_NOT_INITIALIZED,"RC_HTTP_OBJECT_NOT_INITIALIZED"},
+        {RC_HTTP_BAD_PARAMETER,"RC_HTTP_BAD_PARAMETER"},
+
+        {RC_DYNDNS_TOO_MANY_SERVERS,"RC_DYNDNS_TOO_MANY_SERVERS"},
+        {RC_DYNDNS_INVALID_IP_ADDR,"RC_DYNDNS_INVALID_IP_ADDR"},
+        {RC_DYNDNS_BUFFER_TOO_SMALL,"RC_DYNDNS_BUFFER_TOO_SMALL"},
+        {RC_DYNDNS_INVALID_IP_ADDR_IN_HTTP_RESPONSE,"RC_DYNDNS_INVALID_IP_ADDR_IN_HTTP_RESPONSE"},
+        {RC_DYNDNS_INVALID_RSP_FROM_IP_SERVER,"RC_DYNDNS_INVALID_RSP_FROM_IP_SERVER"},
+        {RC_DYNDNS_TOO_MANY_ALIASES,"RC_DYNDNS_TOO_MANY_ALIASES"},
+        {RC_DYNDNS_INVALID_OPTION,"RC_DYNDNS_INVALID_OPTION"},
+        {RC_DYNDNS_INVALID_OR_MISSING_PARAMETERS,"RC_DYNDNS_INVALID_OR_MISSING_PARAMETERS"},
+        {RC_DYNDNS_INVALID_DNS_SYSTEM_DEFAULT,"RC_DYNDNS_INVALID_DNS_SYSTEM_DEFAULT"},
+        {RC_DYNDNS_UNRESOLVED_ALIAS,"RC_DYNDNS_UNRESOLVED_ALIAS"},
+        {RC_DYNDNS_RSP_NOTOK,"RC_DYNDNS_RSP_NOTOK"},
+        {RC_DYNDNS_RSP_CONFIG,"RC_DYNDNS_RSP_CONFIG"},
+
+        {RC_CMD_PARSER_INVALID_OPTION,"RC_CMD_PARSER_INVALID_OPTION"},
+        {RC_CMD_PARSER_INVALID_OPTION_ARGUMENT,"RC_CMD_PARSER_INVALID_OPTION_ARGUMENT"},
+
+        {RC_OS_ERROR_INSTALLING_SIGNAL_HANDLER,"RC_OS_ERROR_INSTALLING_SIGNAL_HANDLER"},
+        {RC_OS_INVALID_IP_ADDRESS,"RC_OS_INVALID_IP_ADDRESS"},
+        {RC_OS_FORK_FAILURE,"RC_FORK_FAILURE"},
+        {RC_OS_CHANGE_PERSONA_FAILURE,"RC_OS_CHANGE_PERSONA_FAILURE"},
+
+        {RC_FILE_IO_OPEN_ERROR,"RC_FILE_IO_OPEN_ERROR"},
+        {RC_FILE_IO_READ_ERROR,"RC_FILE_IO_READ_ERROR"},
+        {RC_FILE_IO_OUT_OF_BUFFER,"RC_FILE_IO_OUT_OF_BUFFER"},
 
-	{RC_OK,NULL}
-};
+        {RC_OK,NULL}
+    };
 
 static const char* unknown_error = "Unknown error";
 
--- src/errorcode.h
+++ src/errorcode.h
@@ -24,51 +24,52 @@
 
 typedef enum
 {
-	RC_OK						= 0,
-	RC_ERROR					= 1,
-	RC_INVALID_POINTER				= 2,
-	RC_OUT_OF_MEMORY				= 3,
-	RC_OUT_BUFFER_OVERFLOW				= 4,
-
-	RC_IP_SOCKET_CREATE_ERROR			= 0x10,
-	RC_IP_BAD_PARAMETER				= 0x11,
-	RC_IP_INVALID_REMOTE_ADDR			= 0x12,
-	RC_IP_CONNECT_FAILED				= 0x13,
-	RC_IP_SEND_ERROR				= 0x14,
-	RC_IP_RECV_ERROR				= 0x15,
-	RC_IP_OBJECT_NOT_INITIALIZED			= 0x16,
-	RC_IP_OS_SOCKET_INIT_FAILED			= 0x17,
-	RC_IP_PARSER_INVALID_IP				= 0x18,
-	RC_IP_INVALID_SOCKET				= 0x19,
-
-    RC_TCP_OBJECT_NOT_INITIALIZED			= 0x20,
-
-    RC_HTTP_OBJECT_NOT_INITIALIZED			= 0x30,
-    RC_HTTP_BAD_PARAMETER				= 0x31,
-
-	RC_DYNDNS_INVALID_IP_ADDR			= 0x39,
-    RC_DYNDNS_BUFFER_TOO_SMALL				= 0x40,
-	RC_DYNDNS_INVALID_IP_ADDR_IN_HTTP_RESPONSE	= 0x41,
-    RC_DYNDNS_INVALID_RSP_FROM_IP_SERVER		= 0x42,
-    RC_DYNDNS_TOO_MANY_ALIASES				= 0x43,
-    RC_DYNDNS_INVALID_OPTION				= 0x44,
-    RC_DYNDNS_INVALID_OR_MISSING_PARAMETERS		= 0x45,
-    RC_DYNDNS_UNRESOLVED_ALIAS				= 0x46,
-    RC_DYNDNS_INVALID_DNS_SYSTEM_DEFAULT		= 0x47,
-    RC_DYNDNS_RSP_NOTOK					= 0x48,
-	RC_DYNDNS_RSP_CONFIG				= 0x49,
-
-    RC_CMD_PARSER_INVALID_OPTION			= 0x50,
-    RC_CMD_PARSER_INVALID_OPTION_ARGUMENT		= 0x51,
-
-    RC_OS_ERROR_INSTALLING_SIGNAL_HANDLER		= 0x60,
-    RC_OS_INVALID_IP_ADDRESS				= 0x61,
-    RC_OS_FORK_FAILURE					= 0x62,
-    RC_OS_CHANGE_PERSONA_FAILURE			= 0x63,
-
-    RC_FILE_IO_OPEN_ERROR				= 0x70,
-    RC_FILE_IO_READ_ERROR				= 0x71,
-    RC_FILE_IO_OUT_OF_BUFFER				= 0x72
+    RC_OK					= 0,
+    RC_ERROR					= 1,
+    RC_INVALID_POINTER				= 2,
+    RC_OUT_OF_MEMORY				= 3,
+    RC_OUT_BUFFER_OVERFLOW			= 4,
+
+    RC_IP_SOCKET_CREATE_ERROR			= 0x10,
+    RC_IP_BAD_PARAMETER				= 0x11,
+    RC_IP_INVALID_REMOTE_ADDR			= 0x12,
+    RC_IP_CONNECT_FAILED			= 0x13,
+    RC_IP_SEND_ERROR				= 0x14,
+    RC_IP_RECV_ERROR				= 0x15,
+    RC_IP_OBJECT_NOT_INITIALIZED		= 0x16,
+    RC_IP_OS_SOCKET_INIT_FAILED			= 0x17,
+    RC_IP_PARSER_INVALID_IP			= 0x18,
+    RC_IP_INVALID_SOCKET			= 0x19,
+
+    RC_TCP_OBJECT_NOT_INITIALIZED		= 0x20,
+
+    RC_HTTP_OBJECT_NOT_INITIALIZED		= 0x30,
+    RC_HTTP_BAD_PARAMETER			= 0x31,
+
+    RC_DYNDNS_TOO_MANY_SERVERS			= 0x38,
+    RC_DYNDNS_INVALID_IP_ADDR			= 0x39,
+    RC_DYNDNS_BUFFER_TOO_SMALL			= 0x40,
+    RC_DYNDNS_INVALID_IP_ADDR_IN_HTTP_RESPONSE	= 0x41,
+    RC_DYNDNS_INVALID_RSP_FROM_IP_SERVER	= 0x42,
+    RC_DYNDNS_TOO_MANY_ALIASES			= 0x43,
+    RC_DYNDNS_INVALID_OPTION			= 0x44,
+    RC_DYNDNS_INVALID_OR_MISSING_PARAMETERS	= 0x45,
+    RC_DYNDNS_UNRESOLVED_ALIAS			= 0x46,
+    RC_DYNDNS_INVALID_DNS_SYSTEM_DEFAULT	= 0x47,
+    RC_DYNDNS_RSP_NOTOK				= 0x48,
+    RC_DYNDNS_RSP_CONFIG			= 0x49,
+
+    RC_CMD_PARSER_INVALID_OPTION		= 0x50,
+    RC_CMD_PARSER_INVALID_OPTION_ARGUMENT	= 0x51,
+
+    RC_OS_ERROR_INSTALLING_SIGNAL_HANDLER	= 0x60,
+    RC_OS_INVALID_IP_ADDRESS			= 0x61,
+    RC_OS_FORK_FAILURE				= 0x62,
+    RC_OS_CHANGE_PERSONA_FAILURE		= 0x63,
+
+    RC_FILE_IO_OPEN_ERROR			= 0x70,
+    RC_FILE_IO_READ_ERROR			= 0x71,
+    RC_FILE_IO_OUT_OF_BUFFER			= 0x72
 
 } RC_TYPE;
 
--- src/get_cmd.c
+++ src/get_cmd.c
@@ -211,7 +211,7 @@
 	
 	return 1;
 }
-
+		
 /*
 	Parses the incoming argv list.
 	Arguments:
@@ -298,7 +298,6 @@
 					            curr_arg_nr, cmd.argv[curr_arg_nr-1]));
 
 				else {
-
 					/*check arg nr required by the current option*/
 					if (!(is_has_option_args(curr_arg_nr,&cmd,p_curr_opt)))
 					{
--- src/inadyn_cmd.c
+++ src/inadyn_cmd.c
@@ -72,6 +72,7 @@
 static RC_TYPE get_dns_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_dns_server_url_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_ip_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
+static RC_TYPE get_global_ip_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_online_check_url_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_dyndns_system_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_update_period_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
@@ -85,6 +86,7 @@
 #endif
 
 static RC_TYPE get_logfile_name(CMD_DATA *p_cmd, int current_nr, void *p_context);
+static RC_TYPE get_pidfile_name(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE set_silent_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE set_verbose_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_proxy_server_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
@@ -121,6 +123,13 @@
 
 #endif
 
+/*
+	muti-services -- inc or set index based on
+	most recent server name option parameter
+	appearance.
+*/
+static server_index=0;
+
 static CMD_DESCRIPTION_TYPE cmd_options_table[] =
     {
         {"--help",	0,	{help_handler, NULL,0},	"help" },
@@ -132,11 +141,11 @@
         {"--password",	1,	{get_password_handler, NULL,0},	"<password> - your password. Optional."},
         {"-p",		1,	{get_password_handler, NULL,0},	"<password> - your password"},
 
-        {"--alias",	4,	{get_alias_handler, NULL,3},	"<alias host name>[,hash] [dual | " DUAL_LIST " | ip4 | ip6 | auto] - alias host name, optional comma delimted hash, and optional ip version, default auto. This option can appear multiple times." },
-        {"-a",		4,	{get_alias_handler, NULL,3},	"<alias host name>[,hash] [dual | " DUAL_LIST " | ip4 | ip6 | auto] - alias host name, optional comma delimited hash, and optional ip version, default auto. This option can appear multiple times." },
+        {"--alias",	3,	{get_alias_handler, NULL,2},	"<alias host name>[,hash] [dual | " DUAL_LIST " | ip4 | ip6 | auto] - alias host name, optional comma delimted hash, and optional ip version, default auto. This option can appear multiple times." },
+        {"-a",		3,	{get_alias_handler, NULL,2},	"<alias host name>[,hash] [dual | " DUAL_LIST " | ip4 | ip6 | auto] - alias host name, optional comma delimited hash, and optional ip version, default auto. This option can appear multiple times." },
 
-        {"--debug",     1,  {get_debug_level_handler, NULL,0}, "<#> - debug level 0..7; higher number, more log debug messages."},
-        {"-d",          1,  {get_debug_level_handler, NULL,0}, "<#> - debug level 0..7; higher number, more log debug messages."},
+        {"--debug",     1,	{get_debug_level_handler, NULL,0}, "<#> - debug level 0..7; higher number, more log debug messages."},
+        {"-d",          1,	{get_debug_level_handler, NULL,0}, "<#> - debug level 0..7; higher number, more log debug messages."},
 
         /*
         for help display only -- service_main takes care of these handlers
@@ -161,16 +170,20 @@
          "<srv_name[:port] local_url> - local IP is detected by parsing the response after returned by this server and URL.  "\
          "The first IP in found http response is considered 'my IP'."},
 
+         {"--ip_server_name_global",	2,	{get_global_ip_server_name_handler, NULL,0},
+         "<srv_name[:port] local_url> - local IP is detected by parsing the response after returned by this server and URL.  "\
+         "The first IP in found http response is considered 'my IP'.  Same as ip_server_name option, but overrides unchanged dyndns_system default ip servers."},
+
         {"--online_check_url",		2,	{get_online_check_url_handler, NULL,0},
          "<srv_name[:port] local_url> - URL to reach to confirm online status.  "\
          "Default value:  " DYNDNS_MY_ONLINE_CHECK " /"},
 
-        {"--dyndns_server_name",	1,	{get_dns_server_name_handler, NULL,0},
+        {"--dyndns_server_name", 	1,	{get_dns_server_name_handler, NULL,0},
          "<NAME>[:port] - The server that receives the update DNS request.  Allows the use of unknown DNS services that "\
-         "accept HTTP updates.  If no proxy is wanted, then it is enough to set the dyndns system. The default servers "\
-         "will be taken."},
+		 "accept HTTP updates.  If no proxy is wanted, then it is enough to set the dyndns system. The default servers "\
+		 "will be taken."},
 
-        {"--dyndns_server_url",		1,	{get_dns_server_url_handler, NULL,0},
+        {"--dyndns_server_url", 	1, {get_dns_server_url_handler, NULL,0},
          "<name> - full URL relative to DynDNS server root.  Ex: /some_script.php?hostname="},
 
         {"--dyndns_system",		1,	{get_dyndns_system_handler, NULL,0},
@@ -184,6 +197,7 @@
          "\t\t-For sitelutions.com:  default@sitelutions.com\n"
          "\t\t-For dnsomatic.com:  default@dnsomatic.com\n"
          "\t\t-For tunnelbroker.net:  ipv6tb@he.net\n"
+         "\t\t-For dns.he.net:  default@he.net\n"
          "\t\t-For tzo.com:  default@tzo.com\n"
          "\t\t-For dynsip.org:  default@dynsip.org\n"
          "\t\t-For dhis.org:  default@dhis.org\n"
@@ -197,7 +211,7 @@
          "[NAME[:port]]  - the http proxy server name and port. Default is none."},
         {"--update_period",		1,	{get_update_period_handler, NULL,0},"<#> - how often the IP is checked. The period is in [ms]. 30000..864000000.  Default is about 10 min. Max is 10 days"},
         {"--update_period_sec",		1,	{get_update_period_sec_handler, NULL,0},"<#> - how often the IP is checked. The period is in [sec]. 30..864000.  Default is about 10 min. Max is 10 days"},
-        {"--forced_update_period",	1,	{get_forced_update_period_handler, NULL,0},"<#> - how often, in seconds, the IP is updated even if it is not changed. 30 sec..30 days, default, 30 days."},
+        {"--forced_update_period", 	1,	{get_forced_update_period_handler, NULL,0},"<#> - how often, in seconds, the IP is updated even if it is not changed. 30 sec..30 days, default, 30 days."},
 
 #ifdef USE_THREADS
 
@@ -205,36 +219,35 @@
 #endif
 
         {"--log_file",			1,	{get_logfile_name, NULL,0},"<path/file> - log file path and name"},
+        {"--pid_file",			1,	{get_pidfile_name, NULL,0},"pid file path and name"},
         {"--background",		0,	{set_silent_handler, NULL,0},"run in background. output to log file or to syslog"},
-
 	{"--verbose",			1,	{set_verbose_handler, NULL,0},"<#> - set dbg level. 0 to 5"},
 
 	{"--iterations",		1,	{set_iterations_handler, NULL,0},"<#> - set the number of DNS updates. Default is 0, which means infinity."},
-        {"--syslog",			0,	{set_syslog_handler, NULL,0},	"force logging to syslog . (e.g. /var/log/mepossages). Works on **NIX systems only."},
-        {"--change_persona",		1,	{set_change_persona_handler, NULL,0}, "<uid[:gid]> - after init switch to a new user/group. Parameters: <uid[:gid]> to change to. Works on **NIX systems only."},
-        {"--version",			0,	{print_version_handler, NULL,0}, "print the version number\n"},
-        {"--exec",			1,	{get_exec_handler, NULL,0}, "<command> - external command to exec after an IP update. Include the full path."},
-        {"--cache_dir",			1,	{get_cache_dir, NULL,0}, "<path> - cache directory name. (e.g. /tmp/ddns). Defaults to /tmp on **NIX systems."},
-        {"--wildcard",			0,	{wildcard_handler, NULL,0}, "enable domain wildcarding for dyndns.org, 3322.org, or easydns.com."},
-        {"--retries",			1,	{get_retries_handler, NULL,0}, "<#> - network comm retry attempts.  0 to 100, default 0"},
-        {"--retry_interval",		1,	{get_retry_interval_handler, NULL,0}, "<#> - network comm miliseconds retry interval.  0 to 30,000, default 1,000"},
-	{"--retry_pending",		0,	{get_retry_pending_off_handler, NULL,0}, "<#> - retry ip update even after network comm retries exhausted,  default on"},
-	{"--retry_pending_interval",	1,	{get_retry_pending_interval_handler, NULL,0}, "<#> - network comm seconds update retry interval, after retries exhausted.  5..3600, default 300"},
-	{"--lang_file",			1,	{get_lang_file_handler, NULL,1}, "[path/file] - language file path, and file name, defaults to either ../inadyn-mt/lang/en.lng, or etc/inadyn-mt/en.lng.  Empty parameter option gives hard coded english defaults."},
-	{"--addr_pref",			1,	{get_addr_pref_handler, NULL,0}, "<pub | policy | home | careof | crypto | nocrypto | tmp | pubtmp> -  ipv6 address preference for DDNS update.  Defaults to pub."},
-
+        {"--syslog",			0,	{set_syslog_handler, NULL,0},"force logging to syslog . (e.g. /var/log/messages). Works on **NIX systems only."},
+        {"--change_persona",		1,	{set_change_persona_handler, NULL,0},"<uid[:gid]> - after init switch to a new user/group. Parameters: <uid[:gid]> to change to. Works on **NIX systems only."},
+        {"--version",			0,	{print_version_handler, NULL,0},"print the version number\n"},
+        {"--exec",			1,	{get_exec_handler, NULL,0},"<command> - external command to exec after an IP update. Include the full path."},
+        {"--cache_dir",			1,	{get_cache_dir, NULL,0},"<path> - cache directory name. (e.g. /tmp/ddns). Defaults to /tmp on **NIX systems."},
+        {"--wildcard",			0,	{wildcard_handler, NULL,0},"enable domain wildcarding for dyndns.org, 3322.org, or easydns.com."},
+        {"--retries",			1,	{get_retries_handler, NULL,0},"<#> - network comm retry attempts.  0 to 100, default 0"},
+        {"--retry_interval",		1, 	{get_retry_interval_handler, NULL,0},"<#> - network comm miliseconds retry interval.  0 to 30,000, default 1,000"},
+	{"--retry_pending",		0,	{get_retry_pending_off_handler, NULL,0},"<#> - retry ip update even after network comm retries exhausted,  default on"},
+	{"--retry_pending_interval",	1,	{get_retry_pending_interval_handler, NULL,0},"<#> - network comm seconds update retry interval, after retries exhausted.  5..3600, default 300"},
+        {"--lang_file",			1,	{get_lang_file_handler, NULL,1},"[path/file] - language file path, and file name, defaults to either ../inadyn-mt/lang/en.lng, or etc/inadyn-mt/en.lng.  Empty parameter option gives hard coded english defaults."},
+        {"--addr_pref",			1,	{get_addr_pref_handler, NULL,0},"<pub | policy | home | careof | crypto | nocrypto | tmp | pubtmp> -  ipv6 address preference for DDNS update.  Defaults to pub."},
 #ifdef USE_SNDFILE
-	{"--audible",			0,	{get_audible_on_handler, NULL,0}, "audible network status alerts toggle.  default off"},
-	{"--wave_file",			2,	{get_wave_file_handler, NULL,1}, "<path/file [#] - audible network status alerts wave file path, and file name. defaults\n" \
+	{"--audible",			0,	{get_audible_on_handler, NULL,0},"audible network status alerts toggle.  default off"},
+	{"--wave_file",			2,	{get_wave_file_handler, NULL,1},"<path/file [#] - audible network status alerts wave file path, and file name. defaults\n" \
          "\t\tto either ../inadyn-mt/extra/wav/alarm.wav, or etc/inadyn-mt/extra/wav/alarm.wav \n"\
          "\t\t[wave loops: 0..100; -1 for infinite] same as wave_loops below -- optional number of\n"\
          "\t\ttimes per wave play call to repeat wave file play, default 0"},
-	{"--wave_loops",		1,	{get_wave_loops_handler, NULL,0}, "<#> - same as wave_file parameter optional parameter --\n"\
+	{"--wave_loops",		1,	{get_wave_loops_handler, NULL,0},"<#> - same as wave_file parameter optional parameter --\n"\
          "\t\t0..100; -1 for infinite number of times per wave play call to repeat wave file play, default 0"},
-	{"--alert_retries",		1,	{get_alert_retries_handler, NULL,0}, "<#> - network retries before audible network status alerts. [0..100], default 0"},
-	{"--alert_interval",		1,	{get_alert_interval_handler, NULL,0}, "<#> - time in miliseconds between consecutive audible network status alerts. [0..3600000], default 0"},
-	{"--wave_gain",			1,	{get_wave_gain_handler, NULL,0}, "<#> - gain (amplitude adjust) at which to play audible alert (beware clipping), integer or float. [-10..10], default 10 (0db, no attenuation)."},
-	{"--wave_buff",			1,	{get_wave_buff_handler, NULL,0}, "<#> - wave file output buffer size control -- integer or float multiple of wave file bytes per sec. [.25..10], default .25"},
+	{"--alert_retries",		1,	{get_alert_retries_handler, NULL,0},"<#> - network retries before audible network status alerts. [0..100], default 0"},
+	{"--alert_interval",		1,	{get_alert_interval_handler, NULL,0},"<#> - time in miliseconds between consecutive audible network status alerts. [0..3600000], default 0"},
+	{"--wave_gain",			1,	{get_wave_gain_handler, NULL,0},"<#> - gain (amplitude adjust) at which to play audible alert (beware clipping), integer or float. [-10..10], default 10 (0db, no attenuation)."},
+	{"--wave_buff",			1,	{get_wave_buff_handler, NULL,0},"<#> - wave file output buffer size control -- integer or float multiple of wave file bytes per sec. [.25..10], default .25"},
 
 /*possible other options:
 		-time before go into rest period
@@ -252,14 +265,30 @@
 
 #ifdef USE_THREADS
 
-	{"--status_interval",		1, {get_status_interval_handler, NULL,0}, "<#> - seconds [30..864000] interval at which to check online status.  defaults to 600"},
-	{"--status_offline_interval",	1, {get_status_offline_interval_handler, NULL,0}, "<#> - seconds [0..864000] interval at which to check online status, after offline detected.  defaults to 15"},
+	{"--status_interval",		1,	{get_status_interval_handler, NULL,0},"<#> - seconds [30..864000] interval at which to check online status.  defaults to 600"},
+	{"--status_offline_interval",	1,	{get_status_offline_interval_handler, NULL,0},"<#> - seconds [0..864000] interval at which to check online status, after offline detected.  defaults to 15"},
 
 #endif
 #endif
-	{NULL,				0,{0, NULL,0},"" }
+        {NULL,				0,	{0,NULL,0},"" }
     };
 
+static RC_TYPE get_pidfile_name(CMD_DATA *p_cmd, int current_nr, void *p_context)
+{
+	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
+	if (p_self == NULL)
+	{
+		return RC_INVALID_POINTER;
+	}
+
+	p_self->p_pidfilename = (char *) safe_malloc(strlen(p_cmd->argv[current_nr]) + 1);
+	if (p_self->p_pidfilename == NULL)
+	{
+		return  RC_OUT_OF_MEMORY;
+	}
+	strcpy(p_self->p_pidfilename, p_cmd->argv[current_nr]);
+	return RC_OK;
+}
 
 void print_help_page(void)
 {
@@ -401,15 +430,15 @@
 		return RC_INVALID_POINTER;
 	}
 
-	if (p_self->info.credentials.my_username) {
+	if (p_self->info[server_index].credentials.my_username) {
 
-		free(p_self->info.credentials.my_username);
+		free(p_self->info[server_index].credentials.my_username);
 	}
 
 	/*user*/
-	p_self->info.credentials.my_username=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
+	p_self->info[server_index].credentials.my_username=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
 
-	strcpy(p_self->info.credentials.my_username, p_cmd->argv[current_nr]);
+	strcpy(p_self->info[server_index].credentials.my_username, p_cmd->argv[current_nr]);
 
 	return RC_OK;
 }
@@ -422,14 +451,14 @@
 		return RC_INVALID_POINTER;
 	}
 
-	if (p_self->info.credentials.my_password) {
+	if (p_self->info[server_index].credentials.my_password) {
 
-		free(p_self->info.credentials.my_password);
+		free(p_self->info[server_index].credentials.my_password);
 	}
 
 	/*password*/
-	p_self->info.credentials.my_password=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
-	strcpy(p_self->info.credentials.my_password, (p_cmd->argv[current_nr]));
+	p_self->info[server_index].credentials.my_password=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
+	strcpy(p_self->info[server_index].credentials.my_password, (p_cmd->argv[current_nr]));
 	return RC_OK;
 }
 
@@ -455,7 +484,8 @@
 		return RC_INVALID_POINTER;
 	}
 
-	if (p_self->alias_info.count-p_self->alias_info.count_dual >= DYNDNS_MAX_ALIAS_NUMBER) {
+	if (p_self->info[server_index].alias_info.count-p_self->info[server_index].alias_info.count_dual 
+			>= DYNDNS_MAX_ALIAS_NUMBER) {
 
 		return RC_DYNDNS_TOO_MANY_ALIASES;
 	}
@@ -465,42 +495,46 @@
 
 	if (p_hash)	{
 
-		if (p_self->alias_info.hashes[p_self->alias_info.count].str)
+		if (p_self->info[server_index].alias_info.hashes[p_self->info[server_index].alias_info.count].str)
 
-			free(p_self->alias_info.hashes[p_self->alias_info.count].str);
+			free(p_self->info[server_index].alias_info.hashes[p_self->info[server_index].alias_info.count].str);
 
 		/*allocate and copy hash len minus comma*/
-		p_self->alias_info.hashes[p_self->alias_info.count].str=safe_malloc(strlen(p_hash));
-		strcpy(p_self->alias_info.hashes[p_self->alias_info.count].str,(p_hash+1));
+		p_self->info[server_index].alias_info.hashes[p_self->info[server_index].alias_info.count].str
+			=safe_malloc(strlen(p_hash));
+
+		strcpy(p_self->info[server_index].alias_info.hashes[p_self->info[server_index].alias_info.count].str,(p_hash+1));
 
 		alias_len=strlen(p_hash);
 	}
 	
-	if (p_self->alias_info.names[p_self->alias_info.count].name)
+	if (p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].name)
 
-		free(p_self->alias_info.names[p_self->alias_info.count].name);
+		free(p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].name);
 
 	alias_len=strlen(p_cmd->argv[current_nr])-alias_len;
 
 	/*alias*/
-	p_self->alias_info.names[p_self->alias_info.count].name=safe_malloc(alias_len+1);
-	strncpy(p_self->alias_info.names[p_self->alias_info.count].name,p_cmd->argv[current_nr],alias_len);
+	p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].name
+		=safe_malloc(alias_len+1);
+	strncpy(p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].name,
+		p_cmd->argv[current_nr],alias_len);
 
 	/*default to letting ip server determine update type*/
-	strcpy(p_self->alias_info.names[p_self->alias_info.count].ip_v,"auto");
+	strcpy(p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].ip_v,"auto");
 
-	p_self->alias_info.names[p_self->alias_info.count].ip_v_enum=ip_store;
+	p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].ip_v_enum=ip_store;
 
 	/*IPv/type*/
 	if (!(current_nr+1<p_cmd->argc)) {
 
-		p_self->info.is_update_auto=true;
+		p_self->info[server_index].is_update_auto=true;
 	}
 	else {
 
 		if (!(strncmp(p_cmd->argv[current_nr+1],"-",1))) {
 
-			p_self->info.is_update_auto=true;
+			p_self->info[server_index].is_update_auto=true;
 		}
 		else {
 
@@ -513,7 +547,7 @@
 			}
 			else {
 
-				strcpy(p_self->alias_info.names[p_self->alias_info.count].ip_v,ip_ver_str);
+				strcpy(p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].ip_v,ip_ver_str);
 
 				if (strcmp(ip_ver_str,"auto")) {
 
@@ -521,24 +555,24 @@
 
 						if (strcmp(ip_ver_str,"ip4"))
 
-							p_self->alias_info.names[p_self->alias_info.count].ip_v_enum=ip_6;
+							p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].ip_v_enum=ip_6;
 						else
-							p_self->alias_info.names[p_self->alias_info.count].ip_v_enum=ip_4;
+							p_self->info[server_index].alias_info.names[p_self->info[server_index].alias_info.count].ip_v_enum=ip_4;
 					}
 				}
 
-				p_self->info.is_update_ip4=(p_self->info.is_update_ip4 || strstr(ip_ver_str,"ip4")
+				p_self->info[server_index].is_update_ip4=(p_self->info[server_index].is_update_ip4 || strstr(ip_ver_str,"ip4")
 					 || strstr(ip_ver_str,DUAL_LIST));
 
-				p_self->info.is_update_ip6=(p_self->info.is_update_ip6 || strstr(ip_ver_str,"ip6")
+				p_self->info[server_index].is_update_ip6=(p_self->info[server_index].is_update_ip6 || strstr(ip_ver_str,"ip6")
 					 || strstr(ip_ver_str,DUAL_LIST));
 
-				p_self->info.is_update_auto=(p_self->info.is_update_auto || strstr(ip_ver_str,"auto"));
+				p_self->info[server_index].is_update_auto=(p_self->info[server_index].is_update_auto || strstr(ip_ver_str,"auto"));
 			}
 		}
 	}
 
-	p_self->alias_info.count++;
+	p_self->info[server_index].alias_info.count++;
 
 
 	return RC_OK;
@@ -547,19 +581,19 @@
 static RC_TYPE get_alias_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 	DYN_DNS_CLIENT	*p_self=(DYN_DNS_CLIENT *) p_context;
-	char		ip_ver_str[8];
+	char		ip_ver_str[8]={'\0'};
 	RC_TYPE		rc=RC_OK;
 
 
 	if (!(current_nr+1<p_cmd->argc)) {
 
-		p_self->info.is_update_auto=true;
+		p_self->info[server_index].is_update_auto=true;
 	}
 	else {
 
 		if (!(strncmp(p_cmd->argv[current_nr+1],"-",1))) {
 
-			p_self->info.is_update_auto=true;
+			p_self->info[server_index].is_update_auto=true;
 		}
 		else {
 
@@ -586,7 +620,7 @@
 
 		if ((RC_OK==(rc=do_get_alias_handler(p_cmd,current_nr,p_context,"ip6"))))
 
-			p_self->alias_info.count_dual++;
+			p_self->info[server_index].alias_info.count_dual++;
 	}
 
 	return rc;
@@ -632,10 +666,10 @@
 /** Returns the svr name and port if the format is :
  * name[:port] url.
  */
-static RC_TYPE set_url_param(CMD_DATA *p_cmd, int current_nr,DYNDNS_INFO_TYPE *info)
+static RC_TYPE set_url_param(CMD_DATA *p_cmd, int current_nr,DYNDNS_SERVER_NAME *info)
 {
 	RC_TYPE	rc;
-	int	port = -1;
+    	int	port = -1;
 
 	if (info == NULL)
 	{
@@ -643,22 +677,22 @@
 	}
 
 	/*user*/
-    info->ip_server_name.port = HTTP_DEFAULT_PORT;
+    info->port = HTTP_DEFAULT_PORT;
 
-    rc = get_name_and_port(p_cmd->argv[current_nr], &info->ip_server_name.name[ip_store], &port);
+    rc = get_name_and_port(p_cmd->argv[current_nr], &info->name, &port);
 
     if (rc == RC_OK && port != -1)
     {
-        info->ip_server_name.port = port;
+        info->port = port;
     }        
 
-    if (info->ip_server_url)
+    if (info->url)
 
-		free(info->ip_server_url);
+		free(info->url);
 
-    info->ip_server_url=safe_malloc(strlen(p_cmd->argv[current_nr + 1]) + 1);
+    info->url=safe_malloc(strlen(p_cmd->argv[current_nr + 1]) + 1);
 
-    strcpy(info->ip_server_url, p_cmd->argv[current_nr + 1]);
+    strcpy(info->url, p_cmd->argv[current_nr + 1]);
 
     return rc;
 }
@@ -666,7 +700,34 @@
 static RC_TYPE get_ip_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 
-    return set_url_param(p_cmd,current_nr,&(((DYN_DNS_CLIENT *) (p_context))->info));
+    return set_url_param(p_cmd,current_nr,&(((DYN_DNS_CLIENT *) (p_context))->info[server_index].ip_server_name));
+}
+
+static RC_TYPE get_global_ip_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
+{
+	RC_TYPE		rc;
+	DYN_DNS_CLIENT	*p_self=(DYN_DNS_CLIENT *) p_context;
+	int		i;
+
+
+    if ((RC_OK==(rc=set_url_param(p_cmd,current_nr,&p_self->ip_server_name_global)))) {
+
+		for (i=0;i<MAX_DNS_SERVER;i++) {
+
+			if (!(p_self->info[i].ip_server_name.name)) {
+
+				p_self->info[i].ip_server_name.name=safe_malloc(strlen(p_self->ip_server_name_global.name)+1);
+				strcpy(p_self->info[i].ip_server_name.name,p_self->ip_server_name_global.name);
+				
+				p_self->info[i].ip_server_name.url=safe_malloc(strlen(p_self->ip_server_name_global.url)+1);
+				strcpy(p_self->info[i].ip_server_name.url,p_self->ip_server_name_global.url);
+				
+				p_self->info[i].ip_server_name.port=p_self->ip_server_name_global.port;
+			}
+		}
+	}
+
+	return rc;
 }
 
 static RC_TYPE get_online_check_url_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
@@ -675,42 +736,128 @@
     return set_url_param(p_cmd,current_nr,&(((DYN_DNS_CLIENT *) (p_context))->info_online_status));
 }
 
+static char index_of(DYNDNS_SYSTEM *src,DYN_DNS_CLIENT *p_self)
+{
+
+	char i;
+
+
+	for (i=0;i<p_self->srv_cnt;i++) {
+
+		if (src==p_self->info[i].p_dns_system)
+
+			return i;
+	}
+
+	return -1;
+}
+
 static RC_TYPE get_dns_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 	DYN_DNS_CLIENT	*p_self = (DYN_DNS_CLIENT *) p_context;
 	RC_TYPE		rc;
 	int		port = -1;
 
+
 	if (p_self == NULL)
 	{
 		return RC_INVALID_POINTER;
 	}
-   
-    p_self->info.dyndns_server_name.port = HTTP_DEFAULT_PORT;
-    rc = get_name_and_port(p_cmd->argv[current_nr], &p_self->info.dyndns_server_name.name[ip_store], &port);
-    if (rc == RC_OK && port != -1)
-    {
-        p_self->info.dyndns_server_name.port = port;
-    }                                   
+
+    p_self->info[server_index].dyndns_server_name.port = HTTP_DEFAULT_PORT;
+    rc = get_name_and_port(p_cmd->argv[current_nr], &p_self->info[server_index].dyndns_server_name.name, &port);
+
+	if (rc==RC_OK) {
+
+		if (port != -1) {
+
+			p_self->info[server_index].dyndns_server_name.port = port;
+		}
+    }
+
+
 	return rc;
 }
 
+/**
+    Searches the DYNDNS system by the argument.
+    Input is like: system@server.name
+    system=statdns|custom|dyndns|default
+    server name = dyndns.org | freedns.afraid.org
+    The result is a pointer in the table of DNS systems.
+*/
+static RC_TYPE get_dyndns_system_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
+{
+	DYNDNS_SYSTEM	*p_dns_system = NULL;
+	DYN_DNS_CLIENT	*p_self = (DYN_DNS_CLIENT *) p_context;
+	if (p_self == NULL)
+	{
+		return RC_INVALID_POINTER;
+	}
+
+	{
+		DYNDNS_SYSTEM_INFO *it = get_dyndns_system_table();
+		for (; it != NULL && it->id != LAST_DNS_SYSTEM; ++it)
+		{
+			if (strcmp(it->system.p_key, p_cmd->argv[current_nr]) == 0)
+			{
+				p_dns_system = &it->system;
+			}
+		}
+	}
+
+	if (p_dns_system == NULL)
+	{
+		return RC_DYNDNS_INVALID_OPTION;
+	}
+
+
+   	/*new or existing server name can appear anywhere on command line.  if new, increment the global
+	  index (or counter, depending on how implement).  but, first check if it's already in list of
+	  servers and set index (or counter) correspondingly to it.  all "info" (server info structure)
+	  related handlers will use this index (or counter) until a new, or other existing name appears.*/
+
+	if (p_self->srv_cnt) {
+
+		if (!(p_self->srv_cnt<MAX_DNS_SERVER))
+
+			return RC_DYNDNS_TOO_MANY_SERVERS;
+
+
+		if (!(-1==(server_index=index_of(p_dns_system,p_self)))) {
+
+			return RC_OK;			
+		}
+		else {
+
+			server_index=p_self->srv_cnt;
+		}			
+	}
+
+	p_self->info[server_index].p_dns_system = p_dns_system;
+
+	p_self->srv_cnt+=1;
+
+
+	return RC_OK;
+}
+
 RC_TYPE get_dns_server_url_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
-	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
+	DYN_DNS_CLIENT	*p_self = (DYN_DNS_CLIENT *) p_context;
 	if (p_self == NULL)
 	{
 		return RC_INVALID_POINTER;
 	}
 
-	if (p_self->info.dyndns_server_url)
+	if (p_self->info[server_index].dyndns_server_name.url)
 
-		free(p_self->info.dyndns_server_url);
+		free(p_self->info[server_index].dyndns_server_name.url);
 
-	p_self->info.dyndns_server_url=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
+	p_self->info[server_index].dyndns_server_name.url=safe_malloc(strlen(p_cmd->argv[current_nr])+1);
 
 	/*url*/
-	strcpy(p_self->info.dyndns_server_url, p_cmd->argv[current_nr]);
+	strcpy(p_self->info[server_index].dyndns_server_name.url, p_cmd->argv[current_nr]);
 
 	return RC_OK;
 }
@@ -720,8 +867,8 @@
 static RC_TYPE get_proxy_server_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 	DYN_DNS_CLIENT	*p_self = (DYN_DNS_CLIENT *) p_context;
-	RC_TYPE		rc;
-	int		port = -1;
+    	RC_TYPE		rc;
+    	int		port = -1;
 
 	if (p_self == NULL)
 	{
@@ -729,11 +876,11 @@
 	}
 
 	/*user*/
-    p_self->info.proxy_server_name.port = HTTP_DEFAULT_PORT;
-    rc = get_name_and_port(p_cmd->argv[current_nr], &p_self->info.proxy_server_name.name[ip_store], &port);
+    p_self->info[server_index].proxy_server_name.port = HTTP_DEFAULT_PORT;
+    rc = get_name_and_port(p_cmd->argv[current_nr], &p_self->info[server_index].proxy_server_name.name, &port);
     if (rc == RC_OK && port != -1)
     {
-        p_self->info.proxy_server_name.port = port;
+        p_self->info[server_index].proxy_server_name.port = port;
     }                                   
 	return rc;    
 }
@@ -963,10 +1110,10 @@
 static RC_TYPE get_cache_dir(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 
-	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
+	DYN_DNS_CLIENT	*p_self = (DYN_DNS_CLIENT *) p_context;
 
-	char *ip_cache=NULL;
-	char *time_cache=NULL;
+	char		*ip_cache=NULL;
+	char		*time_cache=NULL;
 
 
 	if (p_self == NULL)
@@ -998,49 +1145,12 @@
 	return RC_OK;
 }
 
-/**
-    Searches the DYNDNS system by the argument.
-    Input is like: system@server.name
-    system=statdns|custom|dyndns|default
-    server name = dyndns.org | freedns.afraid.org
-    The result is a pointer in the table of DNS systems.
-*/
-static RC_TYPE get_dyndns_system_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
-{
-	DYNDNS_SYSTEM *p_dns_system = NULL;
-	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
-	if (p_self == NULL)
-	{
-		return RC_INVALID_POINTER;
-	}
-
-	{
-		DYNDNS_SYSTEM_INFO *it = get_dyndns_system_table();
-		for (; it != NULL && it->id != LAST_DNS_SYSTEM; ++it)
-		{
-			if (strcmp(it->system.p_key, p_cmd->argv[current_nr]) == 0)
-			{
-				p_dns_system = &it->system;
-			}
-		}
-	}
-
-	if (p_dns_system == NULL)
-	{
-		return RC_DYNDNS_INVALID_OPTION;
-	}
-
-	p_self->info.p_dns_system = p_dns_system;
-
-	return RC_OK;
-}
-
 static RC_TYPE get_debug_level_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 
-	#define ASCII_ZERO     48
+	#define ASCII_ZERO	48
 
-	int                    dwLevel=0;
+	int	dwLevel=0;
 
 
 	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
@@ -1662,7 +1772,7 @@
 
 typedef struct
 {
-	FILE		*p_file;
+	FILE 		*p_file;
 	PARSER_STATE	state;
 } OPTION_FILE_PARSER;
 
@@ -1889,10 +1999,10 @@
 */
 static RC_TYPE parser_utf_8_read_option(OPTION_FILE_PARSER *p_cfg, char *p_buffer, int maxlen)
 {
-	RC_TYPE rc = RC_OK;
-	BOOL parse_end = FALSE;
-	int count = 0;
-	char c_buff[7];
+	RC_TYPE	rc = RC_OK;
+	BOOL	parse_end = FALSE;
+	int	count = 0;
+	char	c_buff[7];
 
 
 	*p_buffer = 0;
@@ -1945,11 +2055,11 @@
 		- add data to buffer
 		- do not forget a 0 at the end
  * States:
- * NEW_LINE - wait here until some option. Add '--' if not already there
- * SPACE - between options. Like NEW_LINE but no additions
- * DATA - real data. Stop on space.
- * COMMENT - everything beginning with # until EOLine
- * ESCAPE - everything that is otherwise (incl. spaces). Next char is raw copied.
+ * NEW_LINE	- wait here until some option. Add '--' if not already there
+ * SPACE	- between options. Like NEW_LINE but no additions
+ * DATA		- real data. Stop on space.
+ * COMMENT	- everything beginning with # until EOLine
+ * ESCAPE	- everything that is otherwise (incl. spaces). Next char is raw copied.
 */
 static RC_TYPE parser_utf_16_read_option(OPTION_FILE_PARSER *p_cfg, char *p_buffer, int maxlen)
 {
@@ -2029,12 +2139,12 @@
 	const int		buffer_size = DYNDNS_SERVER_NAME_LENGTH;
 	OPTION_FILE_PARSER	parser;
 
-	UTF_PARSE_FUNC		parse_func=parser_utf_8_read_option;
+	UTF_PARSE_FUNC parse_func=parser_utf_8_read_option;
 
 #ifdef _WIN32
 
-	int		is_bom=0;	/*win32 utf byte order mark?*/
-	int		is_bom_8=0;
+	int	is_bom=0;	/*win32 utf byte order mark?*/
+	int	is_bom_8=0;
 #endif
 
 
@@ -2320,8 +2430,7 @@
 			rc = get_cmd_parse_data_with_error_handling(argv, argc, cmd_options_table,pf_err_handler);
 		}
 
-		if (rc != RC_OK ||
-		        p_self->abort)
+		if (rc != RC_OK || p_self->abort)
 		{
 			break;
 		}
@@ -2329,63 +2438,73 @@
 		/*settings that may change due to cmd line options*/
 		{
 			int	len=0;
+			int	i;
 
 			
-    		/*ip server*/
-            if (!(p_self->info.ip_server_name.name[ip_store]))
-            {
-				p_self->info.ip_server_name.name[ip_store]=safe_malloc(strlen(p_self->info.p_dns_system->p_ip_server_name)+1);
-				strcpy(p_self->info.ip_server_name.name[ip_store], p_self->info.p_dns_system->p_ip_server_name);
-
-				p_self->info.ip_server_url=safe_malloc(strlen(p_self->info.p_dns_system->p_ip_server_url)+1);
-				strcpy(p_self->info.ip_server_url, p_self->info.p_dns_system->p_ip_server_url);				
-            }
-
-            if (!(p_self->info_online_status.ip_server_name.name[ip_store]))
+			if (!(p_self->info_online_status.name)) 
 			{
-				p_self->info_online_status.ip_server_name.name[ip_store]=safe_malloc(strlen(DYNDNS_MY_ONLINE_CHECK)+1);
-				strcpy(p_self->info_online_status.ip_server_name.name[ip_store],DYNDNS_MY_ONLINE_CHECK);
+				p_self->info_online_status.name=safe_malloc(strlen(DYNDNS_MY_ONLINE_CHECK)+1);
+				strcpy(p_self->info_online_status.name,DYNDNS_MY_ONLINE_CHECK);
 
-				p_self->info_online_status.ip_server_url=safe_malloc(strlen(DYNDNS_MY_ONLINE_CHECK_URL)+1);
-				strcpy(p_self->info_online_status.ip_server_url,DYNDNS_MY_ONLINE_CHECK_URL);
+				p_self->info_online_status.url=safe_malloc(strlen(DYNDNS_MY_ONLINE_CHECK_URL)+1);
+				strcpy(p_self->info_online_status.url,DYNDNS_MY_ONLINE_CHECK_URL);
 
-				p_self->info_online_status.ip_server_name.port=80;
-            }
+				p_self->info_online_status.port=80;
+			}
+
+			if (!(p_self->srv_cnt))
+
+				p_self->srv_cnt=1; /*default server set in main*/
 
-    		/*dyndns server*/
-            if (!(p_self->info.dyndns_server_name.name[ip_store]))
-            {
-				if (!(0==(len=strlen(p_self->info.p_dns_system->p_dyndns_server_name)))) {
+			for (i=0;i<p_self->srv_cnt;i++) {
+
+    				/*dyndns server*/
+				if (!(p_self->info[i].dyndns_server_name.name))
+				{
+					if (!(0==(len=strlen(p_self->info[i].p_dns_system->p_dyndns_server_name)))) {
 
-					p_self->info.dyndns_server_name.name[ip_store]=safe_malloc(len+1);
-        				strcpy(p_self->info.dyndns_server_name.name[ip_store], p_self->info.p_dns_system->p_dyndns_server_name);
+						p_self->info[i].dyndns_server_name.name=safe_malloc(len+1);
+        					strcpy(p_self->info[i].dyndns_server_name.name, p_self->info[i].p_dns_system->p_dyndns_server_name);
+					}				
+				}
+
+ 				/*ip server*/
+				if (!(p_self->info[i].ip_server_name.name))
+				{
+					p_self->info[i].ip_server_name.name=safe_malloc(strlen(p_self->info[i].p_dns_system->p_ip_server_name)+1);
+					strcpy(p_self->info[i].ip_server_name.name, p_self->info[i].p_dns_system->p_ip_server_name);
+					
+					p_self->info[i].ip_server_name.url=safe_malloc(strlen(p_self->info[i].p_dns_system->p_ip_server_url)+1);
+					strcpy(p_self->info[i].ip_server_name.url, p_self->info[i].p_dns_system->p_ip_server_url);				
 				}
-			}
 
-			if (!(p_self->info.dyndns_server_url)) 
-			{
-				if (!(0==(len=strlen(p_self->info.p_dns_system->p_dyndns_server_url)))) {
 
-					p_self->info.dyndns_server_url=safe_malloc(len+1);
-      					strcpy(p_self->info.dyndns_server_url, p_self->info.p_dns_system->p_dyndns_server_url);
+				if (!(p_self->info[i].dyndns_server_name.url)) 
+				{
+					if (!(0==(len=strlen(p_self->info[i].p_dns_system->p_dyndns_server_url)))) {
+
+						p_self->info[i].dyndns_server_name.url=safe_malloc(len+1);
+    						strcpy(p_self->info[i].dyndns_server_name.url, p_self->info[i].p_dns_system->p_dyndns_server_url);
+					}
 				}
 			}
 		}
 
 		/*check if the neccessary params have been provided*/
-		if ((!(p_self->info.dyndns_server_name.name[ip_store])) || (!(p_self->info.ip_server_name.name[ip_store]))
-			|| (!(p_self->info.dyndns_server_url)) || (p_self->alias_info.count == 0))
+		if ((!(p_self->info[0].dyndns_server_name.name)) || (!(p_self->info[0].ip_server_name.name))
+			|| (!(p_self->info[0].dyndns_server_name.url)) || (p_self->info[0].alias_info.count == 0))
 
 		{
 			rc = RC_DYNDNS_INVALID_OR_MISSING_PARAMETERS;
 			break;
 		}
+
 		/*forced update*/
 		if ((fp=utf_fopen(p_self->time_cache, "r")))
 		{
 			if (fgets (cached_time, sizeof (cached_time), fp)) {
 
-				time_t			current;
+				time_t		current;
 				unsigned long	cached;
 				unsigned long	dif;
 				unsigned long	fup_store=p_self->forced_update_period_sec;
@@ -2404,7 +2523,6 @@
 
 					p_self->forced_update_period_sec-=dif;
 
-
 					/*unsigned wrap around?*/
 
 					if (fup_store<p_self->forced_update_period_sec)
--- src/lang.c
+++ src/lang.c
@@ -659,14 +659,20 @@
 	RC_TYPE	rc=RC_OK;
 
 
-	DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "Language file search locale:  %s...\n",szLocale));
-
 	memset(langFile,0,7);
 
+	lang_code(langFile,szLocale);
+
+	if (szLocale)
+
+		DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "Language file search locale:  %s...\n",szLocale));
+	else
+		DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "Language file search locale NULL.  Will use language code:  %s...\n",langFile));
+
 
 	/*pass to langFile function, 2 character language code, with appended, .lng*/
 
-	searchedLangFile(pLOG_FILE,&lang_file_and_path,strcat(lang_code(langFile,szLocale),".lng"));
+	searchedLangFile(pLOG_FILE,&lang_file_and_path,strcat(langFile,".lng"));
 
 
 	rc=do_init_lang_strings(pLOG_FILE,lang_file_and_path);
--- src/os.c
+++ src/os.c
@@ -28,7 +28,7 @@
 */
 
 #define SLEEP_INTERVAL	125
-#define MAXSTRING		2048
+#define MAXSTRING	2048
 
 #ifndef EXCLUDE_CONFIG_H
 
@@ -58,7 +58,7 @@
 HANDLE	hLogWriteMutex=0;
 
 /*Win32 unicode console output*/
-int	is_console=1;
+int		is_console=1;
 
 #endif
 
@@ -70,17 +70,17 @@
 
 char *print_time(void)
 {
-	time_t now;
-	struct tm *timeptr;
-	static const char wday_name[7][3] = {
-	                                        "Sun", "Mon", "Tue", "Wed",
-	                                        "Thu", "Fri", "Sat"
-	                                    };
-	static const char mon_name[12][3] = {
-	                                        "Jan", "Feb", "Mar", "Apr", "May", "Jun",
-	                                        "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
-	                                    };
-	static char result[26];
+	time_t			now;
+	struct			tm *timeptr;
+	static const char	wday_name[7][3] =	{
+	                                        		"Sun", "Mon", "Tue", "Wed",
+	                                        		"Thu", "Fri", "Sat"
+	                                    		};
+	static const char	mon_name[12][3] =	{
+								"Jan", "Feb", "Mar", "Apr", "May", "Jun",
+								"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
+							};
+	static char		result[26];
 
 
 	time(&now);
@@ -272,7 +272,7 @@
 
 	tmp_buff[MAXSTRING-1]='\0';
 
-
+//on windows, os.h defines as _vsnprintf - though, vsnprintf may be available on winNT
 	vsnprintf(message, buff_size-1, langStr(szLangStr,tmp_buff,MAXSTRING), args);
 
 	return message;
@@ -323,7 +323,7 @@
 		unsigned int	b1;
 		unsigned int	b0;
 		unsigned long	ipa;
-		int n;
+		int		n;
 
 		ipa = 0x0;
 		n = sscanf(p_name, IP_V4_IP_ADDR_FORMAT, &b3, &b2, &b1, &b0);
@@ -492,9 +492,9 @@
 void os_printf(int prio,char *fmt,...)
 {
 
-	va_list	args;
-	int	is_wide=0;
-	char	message[MAXSTRING];
+	va_list		args;
+	int		is_wide=0;
+	char		message[MAXSTRING];
 
 
 	flush_buffers();
--- src/os.h
+++ src/os.h
@@ -46,8 +46,8 @@
 	#include <winsock2.h>
 	#include <windows.h> 
 
-	#undef	OS_DEF_OK
-	#define	OS_DEF_OK 1
+	#undef						OS_DEF_OK
+	#define						OS_DEF_OK 1
 
 	#ifndef BOOL 
 
@@ -55,14 +55,14 @@
 			#define				BOOL WINBOOL 
 		#else
 
-			/*Lagacy Windows functions*/
+			/*Legacy Windows functions*/
 			#ifdef _WIN_LEG
 
 				#define vsnprintf	_vsnprintf
 			#endif
 		#endif
-	
-		#define	HAVE_OS_BOOL 1 
+
+		#define					HAVE_OS_BOOL 1 
 	#endif 
 
 	int isWinNT();
@@ -71,14 +71,14 @@
 #ifdef RMC_DEBUG_VERSION
 
 	#undef		OS_DEF_OK
-    	#define		OS_DEF_OK 1
-    	#define		PSOS_OS 1    
+	#define		OS_DEF_OK 1
+	#define		PSOS_OS 1    
 
 	#include	<rmctypes.h>
 	#include	<rmcmacros.h>
 
 	#define		HAVE_OS_BOOL 1    
-    
+
 	#include	<psos.h>    
 	#include	"psos_net.h"
 #endif
@@ -86,29 +86,29 @@
 #if OS_DEF_OK == 0
 
 /*default to Unix*/
-    #define	UNIX_OS  1
-    #define	HAVE_OS_SYSLOG 1
+	#define	UNIX_OS  1
+	#define	HAVE_OS_SYSLOG 1
 
-    #include <unistd.h>
-    #include <stdio.h>
-    #include <stdlib.h>
-    #include <errno.h>
-    #include <string.h>
-    #include <sys/types.h>
-    #include <sys/socket.h>
-    #include <netinet/in.h>
-    #include <arpa/inet.h>
-    #include <sys/wait.h>
-    #include <signal.h>
-    #include <sys/socket.h>
-    #include <netdb.h>
-    #include <syslog.h>
+	#include <unistd.h>
+	#include <stdio.h>
+	#include <stdlib.h>
+	#include <errno.h>
+	#include <string.h>
+	#include <sys/types.h>
+	#include <sys/socket.h>
+	#include <netinet/in.h>
+	#include <arpa/inet.h>
+	#include <sys/wait.h>
+	#include <signal.h>
+	#include <sys/socket.h>
+	#include <netdb.h>
+	#include <syslog.h>
 
-typedef int SOCKET;
-    #define closesocket close
+	typedef int SOCKET;
+	#define closesocket close
 
-    #define FAR         
-typedef struct hostent HOSTENT;
+	#define FAR         
+	typedef struct hostent HOSTENT;
 
 #endif
 
@@ -160,26 +160,26 @@
 
 	typedef enum
 	{
-		OS_CTRL_C_SIGNAL = 0,
-		OS_CTRL_CLOSE_SIGNAL = 1,
-		OS_CTRL_BREAK_SIGNAL = 2,
-		OS_CTRL_LOGOFF_SIGNAL = 3,
-		OS_CTRL_SHUTDOWN_SIGNAL = 4,
-		LAST_SIGNAL = -1
+		OS_CTRL_C_SIGNAL	= 0,
+		OS_CTRL_CLOSE_SIGNAL	= 1,
+		OS_CTRL_BREAK_SIGNAL	= 2,
+		OS_CTRL_LOGOFF_SIGNAL	= 3,
+		OS_CTRL_SHUTDOWN_SIGNAL	= 4,
+		LAST_SIGNAL		= -1
 	} OS_SIGNALS;
 
 	typedef struct
 	{
-		OS_SIGNALS signal;
-		void *p_in_data;
-		void *p_out_data;
+		OS_SIGNALS	signal;
+		void		*p_in_data;
+		void		*p_out_data;
 	} OS_SIGNAL_TYPE;
 
 	typedef int (*OS_SIGNAL_HANDLER_FUNC) (OS_SIGNAL_TYPE, void*);
 	typedef struct
 	{
-		OS_SIGNAL_HANDLER_FUNC p_func;
-		void *p_in_data;
+		OS_SIGNAL_HANDLER_FUNC	p_func;
+		void			*p_in_data;
 	} OS_SIGNAL_HANDLER_TYPE;
 
 	typedef struct
@@ -230,11 +230,11 @@
 	/* Threads */
 	typedef struct
 	{
-		void (*p_func) (void*);
-		void *p_params;
-		int priority;
-		unsigned int nStackSize;
-		unsigned int dwCreateFlags;
+		void		(*p_func) (void*);
+		void		*p_params;
+		int		priority;
+		unsigned int	nStackSize;
+		unsigned int	dwCreateFlags;
 	} OS_THREAD_TYPE;
 
 
@@ -282,14 +282,13 @@
 #ifndef _WIN32
 	pthread_t		timer_thread;
 #else
-	unsigned long	timer_thread;
+	unsigned long		timer_thread;
 #endif
 
 	semaphore_t		sem;
 	mutex_t			mutex_timer;
 
 	unsigned		interval_ms;
-
 	/*be careful of overflow*/
 	volatile unsigned long	time_ms;
 
--- src/path.c
+++ src/path.c
@@ -635,7 +635,7 @@
 	FILE	*fp=NULL;
 
 
-	if (!(root_dir))
+	if (!(root_dir) || !(in_dir))
 
 		return NULL;
 
@@ -768,11 +768,16 @@
 
 	*dest=NULL;
 
+	if (!(cross_platform_cwd(&cwd))) {
+
+		DBG_PRINTF((LOG_INFO,"I:" MODULE_TAG "cwd giving NULL in searchedProgFile...\n"));
+
+		return NULL;
+	}
+
 	normed_path=safe_malloc(strlen(path)+2);
 	strcat(strcpy(normed_path,path),DIR_DELIM_STR);
 
-	cross_platform_cwd(&cwd);
-
 #ifdef _WIN32
 
 	if (!(progMetaFile(pLOG_FILE,dest,normed_path,path_len,langFileName,str_to_lwr(ancestor_path(&a_path,root,cwd)),cwd))) {
--- src/wave_util.c
+++ src/wave_util.c
@@ -306,6 +306,15 @@
 	if (dl_ret=do_open_shared_lib(s_lib,"/usr/lib/"))
 		return dl_ret;
 
+	if (dl_ret=do_open_shared_lib(s_lib,"/usr/local/lib/"))
+		return dl_ret;
+
+	if (dl_ret=do_open_shared_lib(s_lib,"/usr/local/lib32/"))
+		return dl_ret;
+
+	if (dl_ret=do_open_shared_lib(s_lib,"/usr/local/lib64/"))
+		return dl_ret;
+
 	if (dl_ret=do_open_shared_lib(s_lib,"/usr/lib64/"))
 		return dl_ret;
 
