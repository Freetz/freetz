
This patch has been created from AVM's opensrc packages for 7490.05.59 and 7272.05.59
by applying to the kernel sources they contain the following command:

    diff -durN --no-dereference -x fusiv_src 7490.05.59 7272.05.59 > this.patch

--- linux-2.6.32/.config
+++ linux-2.6.32/.config
@@ -64,22 +64,33 @@
 # CONFIG_AMAZON_SE is not set
 # CONFIG_AR9 is not set
 CONFIG_IFX_CLOCK_CHANGE=y
-CONFIG_VR9=y
+# CONFIG_VR9 is not set
+CONFIG_DMA_PACKET_ARBITRATION_ENABLED=y
+# CONFIG_HN1 is not set
+CONFIG_AR10=y
 
 #
-# VR9 Boards
+# AR10 Boards
 #
-# CONFIG_VR9_REF_BOARD is not set
-CONFIG_VR9_AVM_FRITZ_BOX=y
-# CONFIG_LTQ_RT288 is not set
+# CONFIG_AR10_REF_BOARD is not set
+CONFIG_AR10_AVM_FRITZ_BOX=y
+
+#
+# AR10 Boards Family
+#
+CONFIG_AR10_EVAL_BOARD=y
+# CONFIG_AR10_FAMILY_BOARD_1_1 is not set
+# CONFIG_AR10_FAMILY_BOARD_1_2 is not set
+# CONFIG_AR10_FAMILY_BOARD_2 is not set
+
+#
+# Emulator Support
+#
+# CONFIG_USE_EMULATOR is not set
 
 #
 # Extra Configuration
 #
-CONFIG_DMA_PACKET_ARBITRATION_ENABLED=y
-# CONFIG_GRX_25M_MODEL is not set
-# CONFIG_HN1 is not set
-# CONFIG_AR10 is not set
 CONFIG_AR9VR9_C55_MEMORY_SIZE=0x0
 CONFIG_AR9VR9_C55_MEMORY_START=0x0
 # CONFIG_AR9VR9_AVM_CPUFREQ is not set
@@ -181,7 +192,7 @@
 CONFIG_SYS_SUPPORTS_MULTITHREADING=y
 CONFIG_MIPS_MT_FPAFF=y
 # CONFIG_MIPS_VPE_LOADER is not set
-CONFIG_PERFCTRS=y
+# CONFIG_PERFCTRS is not set
 CONFIG_MTSCHED=y
 # CONFIG_MIPS_MT_SMTC_IM_BACKSTOP is not set
 # CONFIG_MIPS_MT_SMTC_IRQAFF is not set
@@ -208,7 +219,7 @@
 CONFIG_HAVE_MLOCKED_PAGE_BIT=y
 CONFIG_KSM=y
 CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
-# CONFIG_AVM_LOW_MEMORY_STRATEGY is not set
+CONFIG_AVM_LOW_MEMORY_STRATEGY=y
 CONFIG_SMP=y
 CONFIG_SMP_UP=y
 CONFIG_SYS_SUPPORTS_SMP=y
@@ -226,7 +237,6 @@
 # CONFIG_HZ_1000 is not set
 # CONFIG_HZ_1024 is not set
 CONFIG_SYS_SUPPORTS_100HZ=y
-CONFIG_SYS_SUPPORTS_250HZ=y
 CONFIG_SYS_SUPPORTS_1000HZ=y
 CONFIG_HZ=100
 CONFIG_PREEMPT_NONE=y
@@ -367,9 +377,9 @@
 # CONFIG_IFX_PCIE_PHY_25MHZ_MODE is not set
 # CONFIG_IFX_PCIE_PHY_100MHZ_MODE is not set
 CONFIG_IFX_PCIE_1ST_CORE=y
-CONFIG_IFX_PCIE_HW_SWAP=y
-# CONFIG_IFX_PCIE_INBOUND_NO_HW_SWAP is not set
-# CONFIG_IFX_PCIE_VR9_A11_HRST is not set
+# CONFIG_IFX_PCIE_HW_SWAP is not set
+CONFIG_IFX_PCIE_INBOUND_NO_HW_SWAP=y
+# CONFIG_IFX_PCIE_2ND_CORE is not set
 # CONFIG_PCIEASPM is not set
 CONFIG_ARCH_SUPPORTS_MSI=y
 # CONFIG_PCI_MSI is not set
@@ -379,7 +389,6 @@
 # CONFIG_PCI_STUB is not set
 # CONFIG_PCI_DISABLE_COMMON_QUIRKS is not set
 # CONFIG_PCI_IOV is not set
-# CONFIG_IFX_PCI is not set
 CONFIG_MMU=y
 # CONFIG_PCCARD is not set
 # CONFIG_HOTPLUG_PCI is not set
@@ -532,8 +541,7 @@
 CONFIG_BRIDGE=y
 # CONFIG_BRIDGE_SNOOPING is not set
 # CONFIG_NET_DSA is not set
-CONFIG_VLAN_8021Q=y
-# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_VLAN_8021Q is not set
 # CONFIG_DECNET is not set
 CONFIG_LLC=y
 # CONFIG_LLC2 is not set
@@ -630,9 +638,7 @@
 # CONFIG_DEVTMPFS is not set
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-CONFIG_FW_LOADER=y
-# CONFIG_FIRMWARE_IN_KERNEL is not set
-CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER is not set
 # CONFIG_DEBUG_DRIVER is not set
 # CONFIG_DEBUG_DEVRES is not set
 # CONFIG_SYS_HYPERVISOR is not set
@@ -698,7 +704,6 @@
 # CONFIG_MTD_INTEL_VR_NOR is not set
 CONFIG_MTD_PLATRAM=y
 CONFIG_MTD_PLATNOR=y
-# CONFIG_MTD_IFX_NOR is not set
 
 #
 # Self-contained MTD device drivers
@@ -738,7 +743,9 @@
 CONFIG_MTD_IFX_NAND_LATCH_ENABLE=y
 CONFIG_MTD_IFX_NAND=y
 CONFIG_MTD_IFX_NAND_FLASH_SIZE=128
-# CONFIG_MTD_IFX_HSNAND is not set
+# CONFIG_MTD_IFX_MLCNAND is not set
+# CONFIG_NAND_CS0 is not set
+CONFIG_NAND_CS1=y
 # CONFIG_MTD_ONENAND is not set
 
 #
@@ -901,10 +908,12 @@
 # CONFIG_AR7240_S26_PHY is not set
 # CONFIG_ATHRS27_PHY is not set
 CONFIG_LANTIQ_11G_PHY=y
-CONFIG_WLAN_OFFLOAD_PHY=y
+# CONFIG_WLAN_OFFLOAD_PHY is not set
 # CONFIG_NETDEV_10000 is not set
 # CONFIG_TR is not set
-# CONFIG_WLAN is not set
+CONFIG_WLAN=y
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
 
 #
 # Enable WiMAX (Networking options) to see the WiMAX drivers
@@ -948,8 +957,6 @@
 # CONFIG_ATM_HE is not set
 # CONFIG_ATM_SOLOS is not set
 # CONFIG_IFX_ATM is not set
-# CONFIG_IFX_PTM is not set
-# CONFIG_IFX_ADTRAN_PTM is not set
 CONFIG_IFX_ETHSW_API=y
 
 #
@@ -961,8 +968,6 @@
 # CONFIG_LTQ_STP is not set
 # CONFIG_LTQ_VLAN is not set
 # CONFIG_LTQ_WOL is not set
-# CONFIG_IFX_ETHSW_API_COC is not set
-# CONFIG_IFX_ETHSW_API_COC_PMCU is not set
 # CONFIG_GPHY_DRIVER is not set
 CONFIG_IFX_PPA_NAPI_ENABLE=y
 CONFIG_IFX_PPA=y
@@ -972,17 +977,13 @@
 # CONFIG_DEBUG_AVM_PPA_VDEV is not set
 CONFIG_IFX_PPA_API_PROC=n
 CONFIG_IFX_PPA_MFE=y
-CONFIG_IFX_PPA_QOS=y
-CONFIG_IFX_PPA_QOS_WFQ=y
-CONFIG_IFX_PPA_QOS_RATE_SHAPING=y
+# CONFIG_IFX_PPA_QOS is not set
 CONFIG_IFX_PPA_DATAPATH=n
-# CONFIG_IFX_PPA_A5 is not set
+CONFIG_IFX_PPA_A5=y
 # CONFIG_IFX_PPA_D5 is not set
-CONFIG_IFX_PPA_E5=y
-# CONFIG_IFX_PPE_E5_OFFCHIP_BONDING is not set
+# CONFIG_IFX_PPA_E5 is not set
 CONFIG_IFX_PPA_IPv6_ENABLE=y
-CONFIG_PTM_VECTORING=y
-# CONFIG_IFX_7PORT_SWITCH is not set
+# CONFIG_PTM_VECTORING is not set
 CONFIG_IFX_ETH_FRAMEWORK=y
 # CONFIG_FDDI is not set
 # CONFIG_HIPPI is not set
@@ -1106,7 +1107,6 @@
 CONFIG_SERIAL_AVM_ASC=y
 CONFIG_SERIAL_AVM_ASC_CONSOLE=y
 # CONFIG_SERIAL_IFX_ASC is not set
-# CONFIG_SERIAL_IFX_USIF_UART is not set
 CONFIG_UNIX98_PTYS=y
 # CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
 CONFIG_LEGACY_PTYS=y
@@ -1159,13 +1159,13 @@
 CONFIG_IFX_PMU_POWER_GATING=y
 CONFIG_IFX_GPIO=y
 CONFIG_IFX_RCU=y
-# CONFIG_IFX_SI is not set
 # CONFIG_IFX_LEDC is not set
-CONFIG_IFX_WDT=y
-CONFIG_DSL_MEI_CPE_DRV=y
+# CONFIG_IFX_WDT is not set
+CONFIG_IFXMIPS_DSL_CPE_MEI=y
+# CONFIG_DSL_MEI_CPE_DRV is not set
 # CONFIG_IFX_PMON is not set
-# CONFIG_IFX_DCDC is not set
 CONFIG_IFX_TS=y
+# CONFIG_IFX_INA219 is not set
 CONFIG_I2C=y
 CONFIG_I2C_BOARDINFO=y
 CONFIG_I2C_COMPAT=y
@@ -1244,7 +1244,6 @@
 CONFIG_SPI_BITBANG=y
 CONFIG_IFX_SPI=y
 # CONFIG_IFX_SPI_DEBUG is not set
-# CONFIG_IFX_SPI_ASYNCHRONOUS is not set
 CONFIG_IFX_SPI_FLASH=y
 # CONFIG_IFX_SPI_AT45_FLASH is not set
 # CONFIG_IFX_USIF_SPI is not set
@@ -1346,8 +1345,7 @@
 # USB Host Controller Drivers
 #
 # CONFIG_USB_C67X00_HCD is not set
-CONFIG_USB_XHCI_HCD=n
-# CONFIG_USB_XHCI_HCD_DEBUGGING is not set
+# CONFIG_USB_XHCI_HCD is not set
 # CONFIG_USB_EHCI_HCD is not set
 # CONFIG_USB_OXU210HP_HCD is not set
 # CONFIG_USB_ISP116X_HCD is not set
@@ -1421,7 +1419,7 @@
 # CONFIG_USB_SERIAL_CP210X is not set
 # CONFIG_USB_SERIAL_CYPRESS_M8 is not set
 # CONFIG_USB_SERIAL_EMPEG is not set
-CONFIG_USB_SERIAL_FTDI_SIO=n
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
 # CONFIG_USB_SERIAL_FUNSOFT is not set
 # CONFIG_USB_SERIAL_VISOR is not set
 # CONFIG_USB_SERIAL_IPAQ is not set
@@ -1785,8 +1783,8 @@
 CONFIG_DEBUG_KERNEL=y
 # CONFIG_DEBUG_SHIRQ is not set
 CONFIG_DETECT_SOFTLOCKUP=y
-# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
-CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC=y
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=1
 # CONFIG_DETECT_HUNG_TASK is not set
 # CONFIG_SCHED_DEBUG is not set
 # CONFIG_SCHEDSTATS is not set
@@ -1946,7 +1944,6 @@
 # OCF Configuration
 #
 # CONFIG_OCF_OCF is not set
-# CONFIG_CRYPTO_CRYPTODEV is not set
 # CONFIG_CRYPTO_HW is not set
 # CONFIG_CRYPTO_DEV_DEU is not set
 # CONFIG_BINARY_PRINTF is not set
--- linux-2.6.32/arch/mips/atheros/avm_hw_config.c
+++ linux-2.6.32/arch/mips/atheros/avm_hw_config.c
@@ -283,6 +283,7 @@
     { .hwrev = 201,                .table = avm_hardware_config_hw201 },          /*--- FRITZ!Powerline 540E ---*/
     { .hwrev = 205,                .table = avm_hardware_config_hw205 },          /*--- FRITZ!Repeater DVBC ---*/
     { .hwrev = 206,                .table = avm_hardware_config_hw206 },          /*--- FRITZ!Repeater 11ac ---*/
+    { .hwrev = 207,                .table = avm_hardware_config_hw195 },          /*--- FRITZ!Box AVM 6842 LTE ---*/
 };
 EXPORT_SYMBOL(avm_hw_config_tables);
 
--- linux-2.6.32/arch/mips/include/asm/avm_cache.h
+++ linux-2.6.32/arch/mips/include/asm/avm_cache.h
@@ -76,6 +76,7 @@
     { 200, CONF_CM_CACHABLE_NONCOHERENT }, /*--- FRITZ!Repeater 450 ---*/
     { 205, CONF_CM_CACHABLE_NONCOHERENT }, /*--- FRITZ!Repeater DVB-C ---*/
     { 206, CONF_CM_CACHABLE_NONCOHERENT }, /*--- FRITZ!Repeater 11ac ---*/
+    { 207, CONF_CM_CACHABLE_NONCOHERENT }, /*--- FRITZ!Box AVM 6842 LTE ---*/
 };
 
 
--- linux-2.6.32/arch/mips/include/asm/mach-atheros/atheros_gpio.h
+++ linux-2.6.32/arch/mips/include/asm/mach-atheros/atheros_gpio.h
@@ -332,6 +332,35 @@
 };
 
 /*------------------------------------------------------------------------------------------*\
+ * AVM 6842 LTE (identisch HW195)
+\*------------------------------------------------------------------------------------------*/
+struct _gpio_function gpio_func_hw207[] = {
+    { IGNORE_FUNCTION,        GPIO_OUTPUT_PIN },  /*--- GPIO  0:  JTCK            ---*/
+    { IGNORE_FUNCTION,        GPIO_INPUT_PIN  },  /*--- GPIO  1:  JTDI            ---*/
+    { IGNORE_FUNCTION,        GPIO_OUTPUT_PIN },  /*--- GPIO  2:  JTDO            ---*/
+    { IGNORE_FUNCTION,        GPIO_OUTPUT_PIN },  /*--- GPIO  3:  JTMS            ---*/
+    { NO_FUNCTION,            GPIO_INPUT_PIN  },  /*--- GPIO  4:  WLAN_TASTER     ---*/
+    { GPIO_OUT_SPI_CS_0,      GPIO_OUTPUT_PIN },  /*--- GPIO  5:  SPI_CS          ---*/
+    { GPIO_OUT_SPI_CLK,       GPIO_OUTPUT_PIN },  /*--- GPIO  6:  SPI_CLK         ---*/
+    { GPIO_OUT_SPI_MOSI,      GPIO_OUTPUT_PIN },  /*--- GPIO  7:  SPI_MOSI        ---*/
+    { GPIO_IN_SPI_MISO,       GPIO_INPUT_PIN  },  /*--- GPIO  8:  SPI_MISO        ---*/
+    { GPIO_IN_UART0_SIN,      GPIO_INPUT_PIN  },  /*--- GPIO  9:  UART_I_DECT     ---*/
+    { GPIO_OUT_UART0_SOUT,    GPIO_OUTPUT_PIN },  /*--- GPIO 10:  UART_SOUT       ---*/
+    { NO_FUNCTION,            GPIO_INPUT_PIN  },  /*--- GPIO 11:  ETHER_INT       ---*/
+    { GPIO_IN_SLIC_PCM_FS,    GPIO_INPUT_PIN  },  /*--- GPIO 12:  TDM_FSC (slave) ---*/
+    { GPIO_IN_I2S_MCLK,       GPIO_INPUT_PIN  },  /*--- GPIO 13:  TDM_DCL (slave) ---*/
+    { GPIO_OUT_SLIC_DATA_OUT, GPIO_OUTPUT_PIN },  /*--- GPIO 14:  TDM_DO          ---*/
+    { GPIO_IN_SLIC_DATA_IN,   GPIO_INPUT_PIN  },  /*--- GPIO 15:  TDM_DI          ---*/
+    { NO_FUNCTION,            GPIO_INPUT_PIN  },  /*--- GPIO 16:  DECT_TASTER     ---*/
+    { NO_FUNCTION,            GPIO_INPUT_PIN  },  /*--- GPIO 17:                  ---*/
+    { NO_FUNCTION,            GPIO_OUTPUT_PIN },  /*--- GPIO 18:  LTE_PWR_EN      ---*/
+    { GPIO_OUT_ATT_LED,       GPIO_OUTPUT_PIN },  /*--- GPIO 19:  XLNA_BIAS0      ---*/
+    { NO_FUNCTION,            GPIO_OUTPUT_PIN },  /*--- GPIO 20:  SDCLK           ---*/
+    { GPIO_OUT_PWR_LED,       GPIO_OUTPUT_PIN },  /*--- GPIO 21:  XLNA_BIAS1      ---*/
+    { NO_FUNCTION,            GPIO_OUTPUT_PIN }   /*--- GPIO 22:  SDIN            ---*/
+};
+
+/*------------------------------------------------------------------------------------------*\
  * FRITZ!Powerline 540E
 \*------------------------------------------------------------------------------------------*/
 struct _gpio_function gpio_func_hw201[] = {
@@ -371,6 +400,7 @@
     { 194, gpio_func_hw194, 23 }, /*--- FRITZ!Repeater 310 ---*/
     { 195, gpio_func_hw195, 23 }, /*--- FRITZ!Box 6842 LTE ---*/
     { 201, gpio_func_hw201, 23 }, /*--- FRITZ!Powerline 540E ---*/
+    { 207, gpio_func_hw207, 23 }, /*--- AVM 6842 LTE ---*/
 };
 #endif /*--- #ifdef CONFIG_MACH_AR934x ---*/
 
--- linux-2.6.32/arch/mips/include/asm/mach-infineon/ifx_yield.h
+++ linux-2.6.32/arch/mips/include/asm/mach-infineon/ifx_yield.h
@@ -65,16 +65,8 @@
 #define LANTIQ_YIELD_MASK2                          ( 0x1 << YIELD_SIGNAL_TIMER1 )
                                                     
                                                    
+extern void ifx_yield_en(unsigned int reg, unsigned int bit, unsigned int on);
 
-/*--------------------------------------------------------------------------------*\
-\*--------------------------------------------------------------------------------*/
-static inline void ifx_yield_en(unsigned int reg, unsigned int bit, unsigned int on) {
-    if(on) {
-        *IFX_YIELDEN(reg) |= 0x1 << (bit);
-        return;
-    }
-    *IFX_YIELDEN(reg) &= ~(0x1 << (bit));
-}
 #define YIELDEN_USB0_IR(on)        ifx_yield_en(1,21,on)
 #define YIELDEN_USB1_IR(on)        ifx_yield_en(1,22,on)
 #define YIELDEN_USB_OCIR(on)       ifx_yield_en(2,3,on)
--- linux-2.6.32/arch/mips/include/asm/mach-ur8/hw_nwss.h
+++ linux-2.6.32/arch/mips/include/asm/mach-ur8/hw_nwss.h
@@ -2,6 +2,11 @@
 #define _HW_NWSS_H_
 
 /*------------------------------------------------------------------------------------------*\
+ * NWSS Defines
+\*------------------------------------------------------------------------------------------*/
+#define UR8_NWSS_CHANNELS 18
+
+/*------------------------------------------------------------------------------------------*\
  * NWSS DMA Register
 \*------------------------------------------------------------------------------------------*/
 union nwss_status {
@@ -85,16 +90,28 @@
     volatile unsigned int  gp_mailbox[8]; 
 };
 
+struct __nwss_td_desc {
+    volatile unsigned int   nextPktPtr;   /* next (hardware) packet pointer */
+             unsigned short channel_no;   /* Affected channel               */
+             unsigned short channel_type; /* Channel type: 0 = Tx, 1 = Rx   */
+};
+
+struct __nwss_td_desc_size {
+    volatile unsigned int td_desc_size :  2;
+    volatile unsigned int reserved     : 30;
+};
+
+
 /*------------------------------------------------------------------------------------------*\
  * Global Register zusammen auf 0x030000000
 \*------------------------------------------------------------------------------------------*/
 struct ur8_nwss_register {
     struct __nwss_global_registers  global;
     volatile unsigned int           DSP_Register[(0xA000-0x40)/sizeof(unsigned int)];
-    struct __nwss_channel_cfg       Channel_Cfg[18];
+    struct __nwss_channel_cfg       Channel_Cfg[UR8_NWSS_CHANNELS];
     volatile unsigned int           reserved[(0xB000-0xA120)/sizeof(unsigned int)];
-    volatile unsigned int           TearDown_Array_Pointer;
-    volatile unsigned int           TearDown_Array_pSize;
+    volatile struct __nwss_td_desc *TearDown_Array_Pointer;
+    struct __nwss_td_desc_size      TearDown_Array_pSize;
 };
 
 /*------------------------------------------------------------------------------------------*\
@@ -243,5 +260,4 @@
 };
 
 
-
 #endif /*--- #ifndef _HW_NWSS_H_ ---*/
--- /dev/null
+++ linux-2.6.32/arch/mips/include/asm/mach-ur8/ur8_cppi.h
@@ -0,0 +1,34 @@
+/*------------------------------------------------------------------------------------------*\
+ *   Copyright (C) 2013 AVM GmbH <fritzbox_info@avm.de>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation version 2 of the License.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+\*------------------------------------------------------------------------------------------*/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <asm/mach-ur8/ur8.h>
+#include <asm/mach-ur8/hw_nwss.h>
+
+
+/*------------------------------------------------------------------------------------------*\
+ * Initialize teardown descriptors
+ * Get Tx or Rx teardown descriptor for given channel
+\*------------------------------------------------------------------------------------------*/
+extern unsigned int ur8_teardown_init(void) __attribute__ ((weak));
+extern void *ur8_get_tx_teardown_BD(unsigned char chNum) __attribute__ ((weak));
+extern void *ur8_get_rx_teardown_BD(unsigned char chNum) __attribute__ ((weak));
+
+
--- linux-2.6.32/arch/mips/include/asm/yield_context.h
+++ linux-2.6.32/arch/mips/include/asm/yield_context.h
@@ -54,4 +54,8 @@
 \*--------------------------------------------------------------------------------*/
 int yield_context_init_on(int cpu, unsigned int yield_tc, unsigned int yield_mask);
 
+/*--------------------------------------------------------------------------------*\
+ * same as cat /proc/yield/stat - but dump as printk
+\*--------------------------------------------------------------------------------*/
+void yield_context_dump(void);
 #endif/*--- #ifndef __yield_context_h__ ---*/
--- linux-2.6.32/arch/mips/kernel/traps.c
+++ linux-2.6.32/arch/mips/kernel/traps.c
@@ -411,6 +411,8 @@
 #endif /*--- #if defined(CONFIG_MIPS_MT_SMP) || defined(CONFIG_MIPS_MT_SMTC) ---*/
 
 	console_verbose();
+    restore_printk();
+
 	spin_lock_irq(&die_lock);
 	bust_spinlocks(1);
 #if defined(CONFIG_MIPS_MT_SMP) || defined(CONFIG_MIPS_MT_SMTC)
@@ -434,7 +436,6 @@
 		ssleep(5);
 		panic("Fatal exception");
 	}
-
 	do_exit(SIGSEGV);
 }
 
@@ -1418,7 +1419,6 @@
 Atheros: Exception 0xbfc00380 wird auch auf nmi_exception_handler gelegt
 \*--------------------------------------------------------------------------------*/
 void nmi_exception_handler(struct pt_regs *regs) {
-
 #if defined(CONFIG_MACH_ATHEROS)
     static struct pt_regs tmp_regs;
 #endif
@@ -1431,6 +1431,9 @@
         vpe_status = dvpe();
 #endif/*--- #ifdef CONFIG_SMP ---*/
 	bust_spinlocks(1);
+
+    console_verbose();
+    restore_printk();
     {
         extern void set_reboot_status_to_NMI(void);
 #if defined(CONFIG_VR9) || defined(CONFIG_AR10)
@@ -1490,7 +1493,6 @@
 #endif  /*--- #else ---*//*--- #if defined(CONFIG_MACH_ATHEROS) ---*/
 
 #if defined(CONFIG_LANTIQ) || defined(CONFIG_MACH_ATHEROS)
-    restore_printk();
 
 #if defined(CONFIG_MIPS_MT_SMP) || defined(CONFIG_MIPS_MT_SMTC)
     mips_mt_regdump(vpe_status);
@@ -1510,7 +1512,6 @@
 
     panic("HardwareWatchDog");
 #endif /*--- #if defined(CONFIG_LANTIQ) || defined(CONFIG_MACH_ATHEROS) ---*/
-
 	die("NMI", regs);
 }
 #if defined(CONFIG_NMI_ARBITER_WORKAROUND)
--- linux-2.6.32/arch/mips/kernel/yield_context.c
+++ linux-2.6.32/arch/mips/kernel/yield_context.c
@@ -189,6 +189,7 @@
 \*--------------------------------------------------------------------------------*/
 int request_yield_handler(int signal, int (*yield_handler)(int signal, void *ref), void *ref){
     struct _yield_ctrl *pyield_ctrl = &yield_ctrl;
+    unsigned long flags;
 
     /*--- printk("%s: signal=%x func=%p ref=%p\n", __func__, signal, yield_handler, ref); ---*/
     if(pyield_ctrl->yield_all_init == 0) {
@@ -210,9 +211,9 @@
 		printk(KERN_ERR "%s signal %d in mask %04x not supported\n", __func__, signal, pyield_ctrl->yield_all_mask);
         return -ERANGE;
     }
-    spin_lock(&pyield_ctrl->handler[signal].progress);
+    spin_lock_irqsave(&pyield_ctrl->handler[signal].progress, flags);
     if(pyield_ctrl->handler[signal].yield_handler) {
-        spin_unlock(&pyield_ctrl->handler[signal].progress);
+        spin_unlock_irqrestore(&pyield_ctrl->handler[signal].progress, flags);
 		printk(KERN_ERR "%s signalhandler for signal %d already installed\n", __func__, signal);
         return -EBUSY;
     }
@@ -226,7 +227,7 @@
     init_generic_stat(&pyield_ctrl->handler[signal].consumption);
     init_generic_stat(&pyield_ctrl->handler[signal].latency);
 #endif/*--- #if defined(YIELD_STAT) ---*/
-    spin_unlock(&pyield_ctrl->handler[signal].progress);
+    spin_unlock_irqrestore(&pyield_ctrl->handler[signal].progress, flags);
     return signal;
 }
 EXPORT_SYMBOL(request_yield_handler);
@@ -234,25 +235,25 @@
 \*--------------------------------------------------------------------------------*/
 int free_yield_handler(int signal, void *ref){
     struct _yield_ctrl *pyield_ctrl = &yield_ctrl;
+    unsigned long flags;
 
     if(pyield_ctrl->yield_all_init == 0) {
-		printk(KERN_WARNING "%s not initialized\n", __func__);
+		printk(KERN_ERR "%s not initialized\n", __func__);
         return -ENODEV;
     }
     if((signal >= MAX_YIELDSIGNALS)) {
         return -ERANGE;
     }
-    spin_lock(&pyield_ctrl->handler[signal].progress);
+    spin_lock_irqsave(&pyield_ctrl->handler[signal].progress, flags);
     if(pyield_ctrl->handler[signal].ref == ref) {
         pyield_ctrl->handler[signal].yield_handler = NULL;
         pyield_ctrl->handler[signal].ref           = NULL;
-        spin_unlock(&pyield_ctrl->handler[signal].progress);
-    } else  {
-        spin_unlock(&pyield_ctrl->handler[signal].progress);
-		printk(KERN_WARNING "%s false ref\n", __func__);
-        return -ERANGE;
+        spin_unlock_irqrestore(&pyield_ctrl->handler[signal].progress, flags);
+        return 0;
     }
-    return 0;
+    spin_unlock_irqrestore(&pyield_ctrl->handler[signal].progress, flags);
+    printk(KERN_ERR "%s false ref\n", __func__);
+    return -ERANGE;
 }
 EXPORT_SYMBOL(free_yield_handler);
 /*--------------------------------------------------------------------------------*\
@@ -265,7 +266,10 @@
     if((signal >= MAX_YIELDSIGNALS)) {
         return;
     }
-    atomic_sub(1, &pyield_ctrl->handler[signal].enable);
+    if(atomic_sub_return(1, &pyield_ctrl->handler[signal].enable) < 0){
+		printk(KERN_ERR "%s warning unbalanced disable\n", __func__);
+        dump_stack();
+    }
 }
 EXPORT_SYMBOL(disable_yield_handler);
 /*--------------------------------------------------------------------------------*\
@@ -284,6 +288,7 @@
 extern void prom_printf(const char *, ...);    
 /*--------------------------------------------------------------------------------*\
  * own non-Linux-YIELD-Kontext-Thread!
+ * use __raw_spin_lock() because no error-output and error-handling allowed
 \*--------------------------------------------------------------------------------*/
 static void yield_context_thread(void) {
     struct _yield_handler *pyieldh;
@@ -327,15 +332,15 @@
             }
             pyieldh = &pyield_ctrl->handler[signal];
             pyieldh->counter++;
-            spin_lock(&pyieldh->progress);
+            __raw_spin_lock(&pyieldh->progress.raw_lock);
             if(unlikely(pyieldh->yield_handler == NULL)) {
-                spin_unlock(&pyieldh->progress);
+                __raw_spin_unlock(&pyieldh->progress.raw_lock);
                 signal++;
                 settings >>= 1;
                 continue;
             }
             if(atomic_read(&pyieldh->enable) <= 0) {
-                spin_unlock(&pyieldh->progress);
+                __raw_spin_unlock(&pyieldh->progress.raw_lock);
                 signal++;
                 settings >>= 1;
                 continue;
@@ -354,7 +359,7 @@
             generic_stat(&pyieldh->consumption, get_cycles() - start_time);
 #endif/*--- #if defined(YIELD_STAT) ---*/
 
-            spin_unlock(&pyieldh->progress);
+            __raw_spin_unlock(&pyieldh->progress.raw_lock);
             signal++;
             settings >>= 1;
         }
@@ -362,15 +367,17 @@
     }
 }
 
-#ifdef CONFIG_PROC_FS
-static struct proc_dir_entry *g_yield_procdev;
-
 /*--------------------------------------------------------------------------------*\
 \*--------------------------------------------------------------------------------*/
 static int yield_proc_stat(char *buf, char **start, off_t offset, int count, int *eof, void *data) {
+    char tmpbuf[256];
     struct _yield_ctrl *pyield_ctrl = &yield_ctrl;
     unsigned int i, tc, stack_used, *p;
+    unsigned long flags;
 	int idx = 0;
+    if(buf == NULL) {
+        buf = tmpbuf;
+    }
     for(tc = 0; tc < YIELD_MAX_TC; tc++) {
         struct _yield_per_tc *pyield_tc = (struct _yield_per_tc *)pyield_ctrl->per_tc[tc];
         if(pyield_tc == NULL) {
@@ -389,7 +396,8 @@
                 pyield_tc->yield_tc, pyield_tc->yield_mask, pyield_tc->yield_counter, 
                 stack_used * sizeof(unsigned int), sizeof(pyield_tc->yield_sp),
                 stack_used * sizeof(unsigned int) == sizeof(pyield_tc->yield_sp) ? "stack overflow!!!" : ""
-                ); 
+                );
+        if(buf == tmpbuf) printk(KERN_ERR"%s", buf), idx = 0;
         for(i = 0; i < MAX_YIELDSIGNALS; i++) {
             struct _yield_handler *pyieldh = &pyield_ctrl->handler[i]; 
 #if defined(YIELD_STAT)
@@ -403,34 +411,37 @@
                                                                            pyieldh->counter,
                                                                            pyieldh->unhandled
                               );
+                if(buf == tmpbuf) printk(KERN_ERR"%s", buf), idx = 0;
 #if defined(YIELD_STAT)
                 pstat = &pyieldh->consumption;
 
-                spin_lock(&pyieldh->progress);
+                spin_lock_irqsave(&pyieldh->progress, flags);
                 cnt = pstat->cnt;
                 max = pstat->max;
                 min = pstat->min;
                 avg64 = pstat->avg;
                 init_generic_stat(pstat);
-                spin_unlock(&pyieldh->progress);
+                spin_unlock_irqrestore(&pyieldh->progress, flags);
 
                 if(cnt) {
                     do_div(avg64, cnt);
                     idx += sprintf(buf+idx, "\t\t\tcycle-stat: [%lu]consumption: min=%lu max=%lu avg=%lu\n", cnt,
                                                    min, max, (unsigned long)avg64);
+                    if(buf == tmpbuf) printk(KERN_ERR"%s", buf), idx = 0;
                 }
                 pstat = &pyieldh->latency;
-                spin_lock(&pyieldh->progress);
+                spin_lock_irqsave(&pyieldh->progress, flags);
                 cnt = pstat->cnt;
                 max = pstat->max;
                 min = pstat->min;
                 avg64 = pstat->avg;
                 init_generic_stat(pstat);
-                spin_unlock(&pyieldh->progress);
+                spin_unlock_irqrestore(&pyieldh->progress, flags);
                 if(cnt) {
                     do_div(avg64, cnt);
                     idx += sprintf(buf+idx, "\t\t\tcycle-stat: [%lu]latency: min=%lu max=%lu avg=%lu\n", cnt,
                                                    min, max, (unsigned long)avg64);
+                    if(buf == tmpbuf) printk(KERN_ERR"%s", buf), idx = 0;
                 }
 #endif/*--- #if defined(YIELD_STAT) ---*/
             }
@@ -440,6 +451,14 @@
 }
 /*--------------------------------------------------------------------------------*\
 \*--------------------------------------------------------------------------------*/
+void yield_context_dump(void){
+    yield_proc_stat(NULL, NULL, 0, 0, NULL, NULL);
+}
+EXPORT_SYMBOL(yield_context_dump);
+#ifdef CONFIG_PROC_FS
+static struct proc_dir_entry *g_yield_procdev;
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
 static int yield_proc_init(void) {
 
 	g_yield_procdev= proc_mkdir("yield", NULL);
@@ -518,7 +537,7 @@
 	mips_ihb();
 	val = read_c0_vpeconf0();
 	if (!(val & VPECONF0_MVP)) {
-		printk(KERN_WARNING "[%s] error only Master VPE's are allowed to configure MT\n", __func__);
+		printk(KERN_ERR "[%s] error only Master VPE's are allowed to configure MT\n", __func__);
 		local_irq_restore(flags);
         kfree(pyield_tc);
 		return;
--- linux-2.6.32/arch/mips/mach-infineon/common/ifxmips_core.c
+++ linux-2.6.32/arch/mips/mach-infineon/common/ifxmips_core.c
@@ -4,6 +4,25 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <asm/prom.h>
+#include <ifx_regs.h>
+
+
+#if defined(CONFIG_VR9)
+static DEFINE_SPINLOCK(ifx_yield_lock);
+/*--------------------------------------------------------------------------------*\
+\*--------------------------------------------------------------------------------*/
+void ifx_yield_en(unsigned int reg, unsigned int bit, unsigned int on) {
+    unsigned long flags;
+    spin_lock_irqsave(&ifx_yield_lock, flags);
+    if(on) {
+        *IFX_YIELDEN(reg) |= 0x1 << (bit);
+    } else {
+        *IFX_YIELDEN(reg) &= ~(0x1 << (bit));
+    }
+    spin_unlock_irqrestore(&ifx_yield_lock, flags);
+}
+EXPORT_SYMBOL(ifx_yield_en);
+#endif /*--- #if defined(CONFIG_VR9) ---*/
 
 /*------------------------------------------------------------------------------------------*\
 \*------------------------------------------------------------------------------------------*/
--- linux-2.6.32/arch/mips/ur8/Makefile
+++ linux-2.6.32/arch/mips/ur8/Makefile
@@ -9,6 +9,7 @@
 			vbus.o \
 			ur8_mtd.o \
 			avm_hw_config.o \
+			ur8_cppi.o \
 			ur8_reset.o
 
 obj-$(CONFIG_PCI) +=  ur8_pci.o \
@@ -16,3 +17,5 @@
 				ur8_pci_generic.o
 
 EXTRA_CFLAGS += -Werror
+ur8_cppi.o: EXTRA_CFLAGS += -Wall -Wextra -Werror
+
--- /dev/null
+++ linux-2.6.32/arch/mips/ur8/ur8_cppi.c
@@ -0,0 +1,86 @@
+/*------------------------------------------------------------------------------------------*\
+ *   Copyright (C) 2013 AVM GmbH <fritzbox_info@avm.de>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation version 2 of the License.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+\*------------------------------------------------------------------------------------------*/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <asm/mach-ur8/ur8.h>
+#include <asm/mach-ur8/hw_nwss.h>
+#include <asm/mach-ur8/ur8_cppi.h>
+
+#define VIRT_TO_PHYS(addr) CPHYSADDR((addr))
+
+static struct __nwss_td_desc (*TDArray)[2 * UR8_NWSS_CHANNELS] = NULL;
+static struct __nwss_td_desc *TDArrayInMemory = NULL;
+struct ur8_nwss_register *UR8_NWSS = (struct ur8_nwss_register *) &(*(volatile unsigned int *)(UR8_NWSS_BASE));
+
+
+/*------------------------------------------------------------------------------------------*\
+\*------------------------------------------------------------------------------------------*/
+unsigned int ur8_teardown_init(void) {
+    unsigned int size = 0;
+    unsigned char channel;
+
+    if(TDArrayInMemory != NULL) {
+        return 0;
+    }
+    size = ((sizeof (struct __nwss_td_desc) * UR8_NWSS_CHANNELS * 2) + 512);
+    TDArrayInMemory = kmalloc(size, GFP_ATOMIC);
+    if(TDArrayInMemory == NULL) {
+        printk(KERN_ERR "Could not allocate memory for CPPI teardown descriptors.\n");
+        return 1;
+    }
+    memset(TDArrayInMemory, 0, size);
+
+    TDArray = (struct __nwss_td_desc (*)[])(((unsigned int) TDArrayInMemory & 0xFFFFFF00) + 512);
+
+    /* initialize teardown array with channel numbers */
+    for(channel = 0; channel < UR8_NWSS_CHANNELS; channel++) {
+        /* store channel number in teardown descriptor */
+        (*TDArray)[2 * channel].channel_no = channel; /* Tx teardown descriptor */
+        (*TDArray)[2 * channel].channel_type = 0;
+        (*TDArray)[2 * channel + 1].channel_no = channel; /* Rx teardown descriptor */
+        (*TDArray)[2 * channel + 1].channel_type = 0;
+    }
+
+    UR8_NWSS->TearDown_Array_Pointer = (volatile struct __nwss_td_desc *) VIRT_TO_PHYS((unsigned int) TDArray);
+    UR8_NWSS->TearDown_Array_pSize.td_desc_size = (sizeof(struct __nwss_td_desc) / 4) - 1;
+
+    return 0;
+}
+EXPORT_SYMBOL(ur8_teardown_init);
+
+
+/*------------------------------------------------------------------------------------------*\
+ * Return the Address of the TX Teardown Buffer Descriptor from the SW array
+\*------------------------------------------------------------------------------------------*/
+void *ur8_get_tx_teardown_BD(unsigned char chNum) {
+    return (void *) &(*TDArray)[chNum];
+}
+EXPORT_SYMBOL(ur8_get_tx_teardown_BD);
+
+
+/*------------------------------------------------------------------------------------------*\
+ * Return the Address of the RX Teardown Buffer Descriptor from the SW array
+\*------------------------------------------------------------------------------------------*/
+void *ur8_get_rx_teardown_BD(unsigned char chNum) {
+    return (void *) &(*TDArray)[chNum + 1];
+}
+EXPORT_SYMBOL(ur8_get_rx_teardown_BD);
+
+
--- linux-2.6.32/drivers/char/avm_new/Makefile
+++ linux-2.6.32/drivers/char/avm_new/Makefile
@@ -122,4 +122,4 @@
 
 EXTRA_CFLAGS	+= -Wall -Wextra
 # EXTRA_CFLAGS	+= -g -ggdb -save-temps
-EXTRA_CFLAGS	+= -DAVM_NEW_HWREV_LIST="\" 156 191 171 137 168 197 139 145 167 141 144 170 175 177 181 183 196 202 203 185 193 192 198 189 179 188 180 96 184 195 190 201 194 200 205 172 173 \""
+EXTRA_CFLAGS	+= -DAVM_NEW_HWREV_LIST="\" 156 191 171 137 168 197 139 145 167 141 144 170 175 177 181 183 196 202 203 185 193 192 198 189 179 188 180 96 184 195 207 190 201 194 200 205 172 173 \""
--- linux-2.6.32/drivers/char/flash_update/flash_update.c
+++ linux-2.6.32/drivers/char/flash_update/flash_update.c
@@ -1,4 +0,0 @@
-/*------------------------------------------------------------------------------------------*\
- *  Dummy file
-\*------------------------------------------------------------------------------------------*/
-
--- linux-2.6.32/drivers/char/flash_update/init_flash_update
+++ linux-2.6.32/drivers/char/flash_update/init_flash_update
@@ -1,17 +0,0 @@
-#! /bin/sh
-
-KERNEL_CLASS=$1
-DRIVER_NAME=$2
-
-if [ -z "$KERNEL_CLASS" ] ; then
-    KERNEL_CLASS=26
-fi
-
-for i in `find . -name Makefile.$KERNEL_CLASS` ; do
-    dest=${i%.$KERNEL_CLASS}
-    source="`pwd`/$i"
-    rm -f $dest
-    ln -fvs $source $dest
-done
-
-exit 0
--- linux-2.6.32/drivers/char/flash_update/Makefile.24
+++ linux-2.6.32/drivers/char/flash_update/Makefile.24
@@ -1,9 +0,0 @@
-###################################################################################################################
-#
-#   vim: noexpandtab
-#
-#	dummy Makefile with no function
-#
-###################################################################################################################
-
-include $(TOPDIR)/Rules.make
--- linux-2.6.32/drivers/char/flash_update/Makefile.26
+++ linux-2.6.32/drivers/char/flash_update/Makefile.26
@@ -1,8 +0,0 @@
-###################################################################################################################
-#
-#   vim: noexpandtab
-#
-#	dummy Makefile with no function
-#
-###################################################################################################################
-
--- linux-2.6.32/drivers/char/tffs-2.0/tffs_open.c
+++ linux-2.6.32/drivers/char/tffs-2.0/tffs_open.c
@@ -226,11 +226,10 @@
             if(open_data->stream.workspace == NULL) {
                 DBG((KERN_ERR "%s: tffs_open: no memory for (write) workspace\n", MODULE_NAME));
                 if(open_data->panic_mode == 0) {
-#if defined(CONFIG_TFFS_CRYPT)
                     if(!tffs_panic_mode && open_data->z_Buffer) {
+#if defined(CONFIG_TFFS_CRYPT)
                         vfree(open_data->z_Buffer - 4);
 #else /*--- #if defined(CONFIG_TFFS_CRYPT) ---*/
-                     if(!tffs_panic_mode) {
                         vfree(open_data->z_Buffer);
 #endif /*--- #else ---*/ /*--- #if defined(CONFIG_TFFS_CRYPT) ---*/
                         open_data->z_Buffer = NULL;
@@ -319,11 +318,10 @@
 
             if(status) {
                 if(open_data->panic_mode == 0) {
-#if defined(CONFIG_TFFS_CRYPT)
                     if(!tffs_panic_mode && open_data->z_Buffer) {
+#if defined(CONFIG_TFFS_CRYPT)
                         vfree(open_data->z_Buffer - 4);
 #else /*--- #if defined(CONFIG_TFFS_CRYPT) ---*/
-                    if(!tffs_panic_mode) {
                         vfree(open_data->z_Buffer);
 #endif /*--- #else ---*/ /*--- #if defined(CONFIG_TFFS_CRYPT) ---*/
                         open_data->z_Buffer = NULL;
@@ -351,11 +349,10 @@
             if(open_data->stream.workspace == NULL) {
                 DBG((KERN_ERR "%s: tffs_open: no memory for (read) workspace\n", MODULE_NAME));
                 if(open_data->panic_mode == 0) {
-#if defined(CONFIG_TFFS_CRYPT)
                     if(!tffs_panic_mode && open_data->z_Buffer) {
+#if defined(CONFIG_TFFS_CRYPT)
                         vfree(open_data->z_Buffer - 4);
 #else /*--- #if defined(CONFIG_TFFS_CRYPT) ---*/
-                    if(!tffs_panic_mode) {
                         vfree(open_data->z_Buffer);
 #endif /*--- #else ---*/ /*--- #if defined(CONFIG_TFFS_CRYPT) ---*/
                         open_data->z_Buffer = NULL;
--- linux-2.6.32/drivers/mtd/mtd_blkdevs.c
+++ linux-2.6.32/drivers/mtd/mtd_blkdevs.c
@@ -56,18 +56,22 @@
 
 	switch(rq_data_dir(req)) {
 	case READ:
-		for (; nsect > 0; nsect--, block++, buf += tr->blksize)
-			if (tr->readsect(dev, block, buf))
-				return -EIO;
+		for (; nsect > 0; nsect--, block++, buf += tr->blksize) {
+            int ret = tr->readsect(dev, block, buf);
+			if (ret && (ret != -EUCLEAN))
+				return ret;
+        }
 		return 0;
 
 	case WRITE:
 		if (!tr->writesect)
 			return -EIO;
 
-		for (; nsect > 0; nsect--, block++, buf += tr->blksize)
-			if (tr->writesect(dev, block, buf))
-				return -EIO;
+		for (; nsect > 0; nsect--, block++, buf += tr->blksize) {
+            int ret = tr->writesect(dev, block, buf);
+			if (ret && (ret != -EUCLEAN))
+				return ret;
+        }
 		return 0;
 
 	default:
@@ -110,7 +114,7 @@
 
 		spin_lock_irq(rq->queue_lock);
 
-		if (!__blk_end_request_cur(req, res))
+		if (!__blk_end_request_cur(req, (!res || (res == -EUCLEAN)) ? 0 : res))
 			req = NULL;
 	}
 
--- linux-2.6.32/drivers/mtd/nand/nand_base.c
+++ linux-2.6.32/drivers/mtd/nand/nand_base.c
@@ -1852,16 +1852,18 @@
                 chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
 
                 goto verify_retry;
-            } else if(mtd->ecc_stats.corrected - stats.corrected) {
-                printk(KERN_ERR "VERIFY-ERROR on page: %d: rewrite also results in a correctable error\n", page);
             } else if(mtd->ecc_stats.failed - stats.failed) {
                 printk(KERN_ERR "VERIFY-ERROR on page: %d: non correctable error detected\n", page);
                 return -EIO;
+            } else if(mtd->ecc_stats.corrected - stats.corrected) {
+                printk(KERN_ERR "VERIFY-ERROR on page: %d: rewrite also results in a correctable error\n", page);
             }
         }
 
-        if (chip->verify_buf(mtd, buf, mtd->writesize))
+        if (chip->verify_buf(mtd, buf, mtd->writesize)) {
+            printk(KERN_ERR "VERIFY-ERROR on page: %d: verify read results in a mismatch\n", page);
             return -EIO;
+        }
     }
 #endif
 	return 0;
--- linux-2.6.32/drivers/net/avm_cpmac/configs/avmnet_hw_config.h
+++ linux-2.6.32/drivers/net/avm_cpmac/configs/avmnet_hw_config.h
@@ -52,6 +52,7 @@
 #include "config_HW194.h"
 #include "config_HW195.h"
 #include "config_HW201v2.h"
+#include "config_HW207.h"
 #endif
 #if defined(CONFIG_MACH_ATHEROS) && defined(CONFIG_MACH_QCA955x)
 #include "config_HW200.h"
@@ -245,6 +246,13 @@
         .nr_avm_devices = NUM_ENTITY( avmnet_hw195_avm_devices ),
         .avm_devices = avmnet_hw195_avm_devices
     },
+    {
+        // 6842 intel
+        .hw_id = 207,
+        .config = &avmnet_HW207,
+        .nr_avm_devices = NUM_ENTITY( avmnet_hw207_avm_devices ),
+        .avm_devices = avmnet_hw207_avm_devices
+    },
 #endif /*--- #if defined(CONFIG_MACH_ATHEROS) && defined(CONFIG_MACH_QCA955x) ---*/
 #if defined(CONFIG_MACH_ATHEROS) && defined(CONFIG_MACH_QCA955x)
     {
--- linux-2.6.32/drivers/net/avm_cpmac/configs/config_7360.h
+++ linux-2.6.32/drivers/net/avm_cpmac/configs/config_7360.h
@@ -14,7 +14,6 @@
 #include "../switch/ifx/7port/swi_7port.h"
 #include "../switch/ifx/7port/mac_7port.h"
 #include "../phy/avmnet_ar803x.h"
-#include "../phy/phy_wasp.h"
 
 extern avmnet_module_t hw181_avmnet_mac_7port_0;
 extern avmnet_module_t hw181_avmnet_mac_7port_1;
--- linux-2.6.32/drivers/net/avm_cpmac/configs/config_HW202.h
+++ linux-2.6.32/drivers/net/avm_cpmac/configs/config_HW202.h
@@ -14,7 +14,6 @@
 #include "../switch/ifx/7port/swi_7port.h"
 #include "../switch/ifx/7port/mac_7port.h"
 #include "../phy/avmnet_ar803x.h"
-#include "../phy/phy_wasp.h"
 
 extern avmnet_module_t hw202_avmnet_mac_7port_0;
 extern avmnet_module_t hw202_avmnet_mac_7port_1;
--- /dev/null
+++ linux-2.6.32/drivers/net/avm_cpmac/configs/config_HW207.h
@@ -0,0 +1,284 @@
+#if !defined(__AVM_NET_CFG_ATHEROS_207)
+#define __AVM_NET_CFG_ATHEROS_207
+
+#include <avmnet_module.h>
+#include <avmnet_config.h>
+#include "../switch/atheros/atheros_mac.h"
+#include "../phy/avmnet_ar803x.h"
+#include "../phy/avmnet_ar8326.h"
+
+#include <atheros.h>
+
+extern avmnet_module_t hw207_gmac0;
+extern avmnet_module_t hw207_gmac1;
+
+avmnet_device_t avmnet_hw207_avm_device_0 ____cacheline_aligned =
+{
+   .device            = NULL,
+   .device_name       = "eth0",
+   .external_port_no  = 0,
+   .device_ops        = {
+                          /*--- .ndo_get_stats        = athr_gmac_get_stats, ---*/
+                          .ndo_open             = avmnet_netdev_open,
+                          .ndo_stop             = avmnet_netdev_stop,
+                          /*--- .ndo_do_ioctl         = athr_gmac_do_ioctl, ---*/
+                          .ndo_tx_timeout       = athr_gmac_tx_timeout,
+                          .ndo_start_xmit       = athr_gmac_hard_start
+                        },
+   .mac_module        = &hw207_gmac0,
+   .vlanID            = 0, // GMAC0
+   .sizeof_priv       = sizeof(avmnet_netdev_priv_t),
+   .device_setup      = athr_gmac_setup_eth,
+   .device_setup_priv = athr_gmac_setup_eth_priv,
+};
+
+avmnet_device_t avmnet_hw207_avm_device_1 ____cacheline_aligned =
+{
+   .device            = NULL,
+   .device_name       = "eth3",
+   .external_port_no  = 3,
+   .device_ops        = {
+                          /*--- .ndo_get_stats        = athr_gmac_get_stats, ---*/
+                          .ndo_open             = avmnet_netdev_open,
+                          .ndo_stop             = avmnet_netdev_stop,
+                          /*--- .ndo_do_ioctl         = athr_gmac_do_ioctl, ---*/
+                          .ndo_tx_timeout       = athr_gmac_tx_timeout,
+                          .ndo_start_xmit       = athr_gmac_hard_start
+                        },
+   .mac_module        = &hw207_gmac1,
+   .vlanID            = 1, // GMAC1, SW MAC 1
+   .sizeof_priv       = sizeof(avmnet_netdev_priv_t),
+   .device_setup      = athr_gmac_setup_eth,
+   .device_setup_priv = athr_gmac_setup_eth_priv,
+};
+
+avmnet_device_t avmnet_hw207_avm_device_2 ____cacheline_aligned =
+{
+   .device            = NULL,
+   .device_name       = "eth2",
+   .external_port_no  = 2,
+   .device_ops        = {
+                          /*--- .ndo_get_stats        = athr_gmac_get_stats, ---*/
+                          .ndo_open             = avmnet_netdev_open,
+                          .ndo_stop             = avmnet_netdev_stop,
+                          /*--- .ndo_do_ioctl         = athr_gmac_do_ioctl, ---*/
+                          .ndo_tx_timeout       = athr_gmac_tx_timeout,
+                          .ndo_start_xmit       = athr_gmac_hard_start
+                        },
+   .mac_module        = &hw207_gmac1,
+   .vlanID            = 2, // GMAC1, SW MAC 2
+   .sizeof_priv       = sizeof(avmnet_netdev_priv_t),
+   .device_setup      = athr_gmac_setup_eth,
+   .device_setup_priv = athr_gmac_setup_eth_priv,
+};
+
+avmnet_device_t avmnet_hw207_avm_device_3 ____cacheline_aligned =
+{
+   .device            = NULL,
+   .device_name       = "eth1",
+   .external_port_no  = 1,
+   .device_ops        = {
+                          /*--- .ndo_get_stats        = athr_gmac_get_stats, ---*/
+                          .ndo_open             = avmnet_netdev_open,
+                          .ndo_stop             = avmnet_netdev_stop,
+                          /*--- .ndo_do_ioctl         = athr_gmac_do_ioctl, ---*/
+                          .ndo_tx_timeout       = athr_gmac_tx_timeout,
+                          .ndo_start_xmit       = athr_gmac_hard_start
+                        },
+   .mac_module        = &hw207_gmac1,
+   .vlanID            = 3, // GMAC1, SW MAC 3
+   .sizeof_priv       = sizeof(avmnet_netdev_priv_t),
+   .device_setup      = athr_gmac_setup_eth,
+   .device_setup_priv = athr_gmac_setup_eth_priv,
+};
+
+avmnet_device_t *avmnet_hw207_avm_devices[] = {
+    &avmnet_hw207_avm_device_0,
+    &avmnet_hw207_avm_device_1,
+    &avmnet_hw207_avm_device_2,
+    &avmnet_hw207_avm_device_3
+}; 
+
+avmnet_module_t avmnet_HW207 ____cacheline_aligned =
+{
+    .name           = "athmac",
+    .type           = avmnet_modtype_switch,
+    .priv           = NULL,
+    .initdata       = { .mac = { .flags = 0 }},
+
+    .init           = athmac_init,
+    .setup          = athmac_setup,
+    .exit           = athmac_exit,
+    
+    .parent         = NULL,
+    .num_children   = 2,
+    .children       = { &hw207_gmac0, &hw207_gmac1 }
+};
+
+extern avmnet_module_t hw207_ath_switch, hw207_module_eth0, hw207_module_eth1, hw207_module_eth2, hw207_module_eth3;
+
+avmnet_module_t hw207_gmac0 ____cacheline_aligned =
+{
+    .name           = "gmac0",
+    .type           = avmnet_modtype_switch,
+    .priv           = NULL,
+    .initdata.mac   = { .flags = AVMNET_CONFIG_FLAG_BASEADDR | AVMNET_CONFIG_FLAG_IRQ, 
+                        .base_addr = ATH_GE0_BASE, 
+                        .irq = ATH_CPU_IRQ_GE0,
+                        .mac_nr = 0 
+                      },
+
+    .init           = athmac_gmac_init,
+    .setup          = athmac_gmac_setup,
+    .exit           = athmac_gmac_exit,
+
+    .reg_read       = athmac_reg_read,
+    .reg_write      = athmac_reg_write,
+    .lock           = athmac_lock,
+    .unlock         = athmac_unlock,
+    .status_changed = athmac_status_changed,
+    .poll           = athmac_poll,
+    .set_status     = athgmac_set_status,
+    .setup_irq      = athmac_setup_irq,
+
+    .parent         = &avmnet_HW207,
+    .num_children   = 1,
+    .children       = { &hw207_module_eth0 },
+};
+
+avmnet_module_t hw207_gmac1 ____cacheline_aligned =
+{
+    .name           = "gmac1",
+    .type           = avmnet_modtype_switch,
+    .priv           = NULL,
+    .initdata.mac   = {  .flags = AVMNET_CONFIG_FLAG_BASEADDR
+                                | AVMNET_CONFIG_FLAG_IRQ
+                                | AVMNET_CONFIG_FLAG_SWITCHPORT,
+                         .base_addr = ATH_GE1_BASE, 
+                         .irq = ATH_CPU_IRQ_GE1, 
+                         .mac_nr = 1
+                      },
+
+    .init           = athmac_gmac_init,
+    .setup          = athmac_gmac_setup,
+    .exit           = athmac_gmac_exit,
+
+    .reg_read       = athmac_reg_read,
+    .reg_write      = athmac_reg_write,
+    .lock           = athmac_lock,
+    .unlock         = athmac_unlock,
+    .status_changed = athmac_status_changed,
+    .poll           = athmac_poll,
+    .set_status     = athgmac_set_status,
+    .setup_irq      = athmac_setup_irq,
+
+    .parent         = &avmnet_HW207,
+    .num_children   = 1,
+    .children       = { &hw207_ath_switch },
+};
+
+avmnet_module_t hw207_ath_switch ____cacheline_aligned =
+{
+    .name           = "ar8326",
+    .type           = avmnet_modtype_switch,
+    .priv           = NULL,
+    .initdata       = { .swi = { .flags = AVMNET_CONFIG_FLAG_IRQ, .irq = ATH_MISC_IRQ_ENET_LINK }},
+
+    .init           = avmnet_ar8326_init,
+    .setup          = avmnet_ar8326_setup,
+    .exit           = avmnet_ar8326_exit,
+
+    .reg_read       = avmnet_s27_rd_phy,
+    .reg_write      = avmnet_s27_wr_phy,
+    .lock           = avmnet_s27_lock,
+    .unlock         = avmnet_s27_unlock,
+    .status_changed = avmnet_ar8326_status_changed,
+    .poll           = avmnet_ar8326_status_poll,
+    .set_status     = avmnet_ar8326_set_status,
+    .setup_irq      = avmnet_ar8326_setup_interrupt,
+
+    .parent         = &hw207_gmac1,
+    .num_children   = 3,
+    .children       = { &hw207_module_eth1, &hw207_module_eth2, &hw207_module_eth3 }
+};
+
+avmnet_module_t hw207_module_eth0 ____cacheline_aligned =
+{
+    .name           = "ar803x0",
+    .device_id      = &avmnet_hw207_avm_device_0,
+    .type           = avmnet_modtype_phy,
+    .priv           = NULL,
+    .initdata.phy   = { .flags =   AVMNET_CONFIG_FLAG_RESET 
+                                 | AVMNET_CONFIG_FLAG_PHY_GBIT
+                                 | AVMNET_CONFIG_FLAG_IRQ
+                                 | AVMNET_CONFIG_FLAG_MDIOADDR
+                                 | AVMNET_CONFIG_FLAG_RX_DELAY
+                                 | AVMNET_CONFIG_FLAG_TX_DELAY,
+                                 .tx_delay = 0x2d47,
+                                 .rx_delay = 0x2ee,
+                                 .mdio_addr = 0, 
+                                 .irq = ATH_GPIO_IRQn(11), 
+                                 .reset = 108 
+                      },
+
+     AR803X_STDFUNCS,
+
+    .ethtool_ops    = AR803X_ETHOPS,
+
+    .parent         = &hw207_gmac0,
+    .num_children   = 0,
+    .children       = {}
+};
+
+avmnet_module_t hw207_module_eth1 ____cacheline_aligned =
+{
+    .name           = "ar803x1",
+    .device_id      = &avmnet_hw207_avm_device_1,
+    .type           = avmnet_modtype_phy,
+    .priv           = NULL,
+    .initdata.phy   = { .flags = AVMNET_CONFIG_FLAG_MDIOADDR | AVMNET_CONFIG_FLAG_INTERNAL, .mdio_addr = 0 },
+
+     AR803X_STDFUNCS,
+
+    .ethtool_ops    = AR803X_ETHOPS,
+
+    .parent         = &hw207_ath_switch,
+    .num_children   = 0,
+    .children       = {}
+};
+
+avmnet_module_t hw207_module_eth2 ____cacheline_aligned =
+{
+    .name           = "ar803x2",
+    .device_id      = &avmnet_hw207_avm_device_2,
+    .type           = avmnet_modtype_phy,
+    .priv           = NULL,
+    .initdata.phy   = { .flags = AVMNET_CONFIG_FLAG_MDIOADDR | AVMNET_CONFIG_FLAG_INTERNAL, .mdio_addr = 1 },
+
+     AR803X_STDFUNCS,
+
+    .ethtool_ops    = AR803X_ETHOPS,
+
+    .parent         = &hw207_ath_switch,
+    .num_children   = 0,
+    .children       = {}
+};
+
+avmnet_module_t hw207_module_eth3 ____cacheline_aligned =
+{
+    .name           = "ar803x3",
+    .device_id      = &avmnet_hw207_avm_device_3,
+    .type           = avmnet_modtype_phy,
+    .priv           = NULL,
+    .initdata.phy   = { .flags = AVMNET_CONFIG_FLAG_MDIOADDR | AVMNET_CONFIG_FLAG_INTERNAL, .mdio_addr = 2 },
+
+     AR803X_STDFUNCS,
+    
+    .ethtool_ops    = AR803X_ETHOPS,
+
+    .parent         = &hw207_ath_switch,
+    .num_children   = 0,
+    .children       = {}
+};
+
+#endif
--- linux-2.6.32/drivers/net/avm_cpmac/phy/phy_wasp.c
+++ linux-2.6.32/drivers/net/avm_cpmac/phy/phy_wasp.c
@@ -123,7 +123,12 @@
 
     avmnet_cfg_register_module(this);
 
-    avmnet_cfg_add_seq_procentry(this, "mdio_regs", &phy_reg_fops); // cannot be done before avmnet_cfg_register_module
+    /* WASP might not expect MDIO queries in normal operation. Therefore they
+     * might be harmful. Additionally, the results of a register dump are
+     * meaningless at the moment, because the contain only the last data from
+     * the pre boot phase.
+     * => Do no register dump for the moment. */
+    /*--- avmnet_cfg_add_seq_procentry(this, "mdio_regs", &phy_reg_fops); // cannot be done before avmnet_cfg_register_module ---*/
 
     ctx = (struct avmnet_phy_wasp_context *) this->priv;
     ctx->heartbeat.this = this;
--- linux-2.6.32/drivers/net/avm_cpmac/switch/atheros/atheros_gmac.c
+++ linux-2.6.32/drivers/net/avm_cpmac/switch/atheros/atheros_gmac.c
@@ -833,7 +833,7 @@
     switch (mac->mac_unit) {
         case 0:
             /*------------------------------------------------------------------------------*\
-             * DMA Descriptor fr den MAC Header und den Atheros Spezial Header (14 Bytes)   1.
+             * DMA Descriptor fr den MAC Header ohne den Atheros Spezial Header (12 Bytes)   1.
              * DMA Descriptor fr den Inhalt des Paketes ohne MAC Header (offset 12 Bytes)   2.
             \*------------------------------------------------------------------------------*/
             head_ds = athr_gmac_get_tx_ds(mac, skb);
@@ -1454,7 +1454,6 @@
         switch(mac->mac_unit) {
             case 1:
                 {
-                    /*--- struct vlan_ethhdr *eth_head = vlan_eth_hdr(skb); ---*/
                     p_athr_special_header_t header;
 
                     /*
@@ -1462,10 +1461,18 @@
                      * and then remove the special header
                      */
                     header = (p_athr_special_header_t)(skb->data + 12);
-                    port = header->portnum;
 
-                    memmove(skb->data + 2, skb->data, 12);
-                    skb_pull(skb, 2);
+                    if (likely(header->version == 2) && (header->type == 0)) {
+                        port = header->portnum;
+                        memmove(skb->data + 2, skb->data, 12);
+                        skb_pull(skb, 2);
+                    } else {
+                        AVMNET_ERR("[%s] Received illegal Frame on %s version %d priority %d type %d portnum %d\n", __func__, 
+                                this->name, header->version, header->priority, header->type, header->portnum);
+                        athr_gmac_buffer_free(skb);
+                        athr_gmac_ring_incr(head);
+                        continue;
+                    }
                 }
                 break;
             case 0:
@@ -1483,7 +1490,7 @@
          */
         if(unlikely(mac->devices_lookup[port] == NULL)){
             AVMNET_ERR("[%s] Received Frame from illegal port %d on %s\n", __func__, port, this->name);
-            dev_kfree_skb_any(skb);
+            athr_gmac_buffer_free(skb);
             athr_gmac_ring_incr(head);
             continue;
         }
--- linux-2.6.32/drivers/spi/ifxmips_sflash.c
+++ linux-2.6.32/drivers/spi/ifxmips_sflash.c
@@ -187,6 +187,7 @@
         .name = "Winbond",
         .id = JED_MANU_WINBOND,
         .flashes = {
+            { "w25x10", 0x4014, 8 * 1024 * 1024, 256, SECT_4K, },
             { "w25x10", 0x3011, 64 * 1024, 2, SECT_4K, },
             { "w25x20", 0x3012, 64 * 1024, 4, SECT_4K, },
             { "w25x40", 0x3013, 64 * 1024, 8, SECT_4K, },
--- linux-2.6.32/kernel/module.c
+++ linux-2.6.32/kernel/module.c
@@ -617,6 +617,7 @@
 MODINFO_ATTR(srcversion);
 
 static char last_unloaded_module[MODULE_NAME_LEN+1];
+static unsigned long last_unloaded_module_jiffies;
 
 #ifdef CONFIG_MODULE_UNLOAD
 /* Init the unload section of the module. */
@@ -872,6 +873,7 @@
 	mutex_lock(&module_mutex);
 	/* Store the name of the last unloaded module for diagnostic purposes */
 	strlcpy(last_unloaded_module, mod->name, sizeof(last_unloaded_module));
+    last_unloaded_module_jiffies = jiffies;
 	free_module(mod);
 
  out:
@@ -3114,8 +3116,11 @@
 	list_for_each_entry_rcu(mod, &modules, list)
 		printk(" %s%s", mod->name, module_flags(mod, buf));
 	preempt_enable();
-	if (last_unloaded_module[0])
-		printk(" [last unloaded: %s]", last_unloaded_module);
+	if (last_unloaded_module[0]) {
+        struct timespec sincetime;
+        jiffies_to_timespec(jiffies - last_unloaded_module_jiffies, &sincetime);
+		printk(" [last unloaded: %s before %lu.%03lu s]", last_unloaded_module, sincetime.tv_sec, sincetime.tv_nsec / (1000* 1000));
+    }
 	printk("\n");
 }
 
--- linux-2.6.32/kernel/panic.c
+++ linux-2.6.32/kernel/panic.c
@@ -75,7 +75,6 @@
     *(volatile unsigned int *)(0xbf101000 + 0xF4) = (1<<4);    /*--- disable WATCHDOG-preWarning ---*/
 #endif /*--- #if defined(CONFIG_VR9) ---*/ 
 #endif
-
 	/*
 	 * It's possible to come here directly from a panic-assertion and
 	 * not have preempt disabled. Some functions called from here want
@@ -84,6 +83,8 @@
 	preempt_disable();
 
 	bust_spinlocks(1);
+    console_verbose();
+    restore_printk();
     dump_stack();
 	va_start(args, fmt);
 	vsnprintf(buf, sizeof(buf), fmt, args);
--- linux-2.6.32/kernel/sched.c
+++ linux-2.6.32/kernel/sched.c
@@ -5596,6 +5596,7 @@
 {
 	struct pt_regs *regs = get_irq_regs();
 
+	console_verbose();
     restore_printk();
 	printk(KERN_ERR "BUG: scheduling while atomic: %s/%d/0x%08x\n",
 		prev->comm, prev->pid, preempt_count());
@@ -5610,7 +5611,12 @@
 	else
 		dump_stack();
 
+#ifdef CONFIG_SMP
+    /*--- get information about all cpus ! ---*/
+    BUG();
+#else
 	panic("BUG: scheduling while atomic: %s/%d/0x%08x\n", prev->comm, prev->pid, preempt_count());
+#endif
 }
 
 /*
--- linux-2.6.32/kernel/softlockup.c
+++ linux-2.6.32/kernel/softlockup.c
@@ -150,21 +150,26 @@
 	per_cpu(print_timestamp, this_cpu) = touch_timestamp;
 
 	spin_lock(&print_lock);
-	console_loglevel = 9;
+    console_verbose();
+	if (softlockup_panic) {
+        restore_printk();
+    }
 	printk(KERN_ERR "BUG: soft lockup - CPU#%d stuck for %lus! [%s:%d]\n",
 			this_cpu, now - touch_timestamp,
 			current->comm, task_pid_nr(current));
+#ifdef CONFIG_SMP
+	if (softlockup_panic) {
+        /*--- get information about all cpus ! ---*/
+        BUG();
+    }
+#endif
 	print_modules();
 	print_irqtrace_events(current);
 	if (regs) 
 		show_regs(regs);
 	else
 		dump_stack();
-#if defined(CONFIG_MIPS_MT_SMP) || defined(CONFIG_MIPS_MT_SMTC)
-    arch_trigger_all_cpu_backtrace();
-#endif /*--- #if defined(CONFIG_MIPS_MT_SMP) || defined(CONFIG_MIPS_MT_SMTC) ---*/
 	spin_unlock(&print_lock);
-
 	if (softlockup_panic)
 		panic("softlockup: hung tasks");
 }
--- linux-2.6.32/lib/spinlock_debug.c
+++ linux-2.6.32/lib/spinlock_debug.c
@@ -58,6 +58,7 @@
 
 	if (lock->owner && lock->owner != SPINLOCK_OWNER_INIT)
 		owner = lock->owner;
+    console_verbose();
     restore_printk();
 	printk(KERN_EMERG "BUG: spinlock %s on CPU#%d, %s/%d\n",
 		msg, raw_smp_processor_id(),
@@ -69,6 +70,7 @@
 		owner ? task_pid_nr(owner) : -1,
 		lock->owner_cpu);
 	dump_stack();
+    BUG(); /*--- get information about all cpus ! ---*/
 }
 
 #define SPIN_BUG_ON(cond, lock, msg) if (unlikely(cond)) spin_bug(lock, msg)
@@ -118,6 +120,7 @@
 		    if (lock->owner && lock->owner != SPINLOCK_OWNER_INIT)
 			    owner = lock->owner;
 			print_once = 0;
+            console_verbose();
             restore_printk();
 			printk(KERN_EMERG "BUG: spinlock lockup on CPU#%d, "
 					"%s/%d, %p\n",
@@ -128,9 +131,7 @@
 		        owner ? task_pid_nr(owner) : -1,
 		        lock->owner_cpu);
 			dump_stack();
-#ifdef CONFIG_SMP
-			trigger_all_cpu_backtrace();
-#endif
+            BUG(); /*--- get information about all cpus ! ---*/
 		}
 	}
 }
@@ -169,11 +170,13 @@
 	if (!debug_locks_off())
 		return;
 
+    console_verbose();
     restore_printk();
 	printk(KERN_EMERG "BUG: rwlock %s on CPU#%d, %s/%d, %p\n",
 		msg, raw_smp_processor_id(), current->comm,
 		task_pid_nr(current), lock);
 	dump_stack();
+    BUG(); /*--- get information about all cpus ! ---*/
 }
 
 #define RWLOCK_BUG_ON(cond, lock, msg) if (unlikely(cond)) rwlock_bug(lock, msg)
