--- src/openvpn/pool.c
+++ src/openvpn/pool.c
@@ -326,7 +326,7 @@
 static struct in6_addr
 ifconfig_pool_handle_to_ipv6_base (const struct ifconfig_pool* pool, ifconfig_pool_handle hand)
 {
-  struct in6_addr ret = in6addr_any;
+  struct in6_addr ret = IN6ADDR_ANY_INIT;
 
   /* IPv6 pools are always INDIV (--linear) */
   if (hand >= 0 && hand < pool->size_ipv6 )
--- src/openvpn/socket.c
+++ src/openvpn/socket.c
@@ -1151,6 +1151,7 @@
 	    {
 	      int status;
 	      int err;
+	      static const struct in6_addr my_in6addr_any = IN6ADDR_ANY_INIT;
 	      CLEAR(sock->info.lsa->local.addr.in6);
 	      if (sock->local_host)
 		{
@@ -1166,7 +1167,7 @@
 	      else
 		{
 		  sock->info.lsa->local.addr.in6.sin6_family = AF_INET6;
-		  sock->info.lsa->local.addr.in6.sin6_addr = in6addr_any;
+		  sock->info.lsa->local.addr.in6.sin6_addr = my_in6addr_any;
 		  status = 0;
 		}
 	      if (!status == 0)
@@ -1202,6 +1203,7 @@
 {
   struct gc_arena gc = gc_new ();
   int af;
+  static const struct in6_addr my_in6addr_any = IN6ADDR_ANY_INIT;
 
   if (!sock->did_resolve_remote)
     {
@@ -1218,7 +1220,7 @@
               case AF_INET6:
                 CLEAR(sock->info.lsa->remote.addr.in6);
                 sock->info.lsa->remote.addr.in6.sin6_family = AF_INET6;
-                sock->info.lsa->remote.addr.in6.sin6_addr = in6addr_any;
+                sock->info.lsa->remote.addr.in6.sin6_addr = my_in6addr_any;
                 break;
             }
 
@@ -2321,10 +2323,11 @@
 const char *
 print_in6_addr (struct in6_addr a6, unsigned int flags, struct gc_arena *gc)
 {
+  static const struct in6_addr my_in6addr_any = IN6ADDR_ANY_INIT;
   struct buffer out = alloc_buf_gc (64, gc);
   char tmp_out_buf[64];		/* inet_ntop wants pointer to buffer */
 
-  if ( memcmp(&a6, &in6addr_any, sizeof(a6)) != 0 || 
+  if ( memcmp(&a6, &my_in6addr_any, sizeof(a6)) != 0 || 
        !(flags & IA_EMPTY_IF_UNDEF))
     {
       inet_ntop (AF_INET6, &a6, tmp_out_buf, sizeof(tmp_out_buf)-1);
