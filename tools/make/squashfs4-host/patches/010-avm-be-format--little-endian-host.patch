--- squashfs-tools/Makefile
+++ squashfs-tools/Makefile
@@ -115,7 +115,8 @@
 	caches-queues-lists.o
 
 UNSQUASHFS_OBJS = unsquashfs.o unsquash-1.o unsquash-2.o unsquash-3.o \
-	unsquash-4.o swap.o compressor.o unsquashfs_info.o
+	unsquash-4.o swap.o compressor.o unsquashfs_info.o \
+	unsquash-4-be.o
 
 CFLAGS ?= -O2
 CFLAGS += $(EXTRA_CFLAGS) $(INCLUDEDIR) -D_FILE_OFFSET_BITS=64 \
@@ -290,6 +291,9 @@
 unsquash-4.o: unsquashfs.h unsquash-4.c squashfs_fs.h squashfs_swap.h \
 	read_fs.h
 
+unsquash-4-be.o: unsquashfs.h unsquash-4-be.c squashfs_fs.h squashfs_compat.h \
+	squashfs_compat_4_be.h
+
 unsquashfs_xattr.o: unsquashfs_xattr.c unsquashfs.h squashfs_fs.h xattr.h
 
 unsquashfs_info.o: unsquashfs.h squashfs_fs.h
--- squashfs-tools/squashfs_compat_4_be.h
+++ squashfs-tools/squashfs_compat_4_be.h
@@ -0,0 +1,242 @@
+#ifndef SQUASHFS_COMPAT_4_BE
+#define SQUASHFS_COMPAT_4_BE
+/*
+ * Squashfs
+ *
+ * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2014
+ * Phillip Lougher <phillip@squashfs.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * squashfs_compat_4_be.h
+ *
+ * Copyright (C) 2014
+ * Peter Hämmerlein <opensource@peh-consulting.de>
+ *
+ * look at unsquashfs-4-be.c for additional information
+ *
+ */
+
+/* definitions for squashfs 4 with big endian encoding */
+
+#define SQUASHFS_SWAP_SUPER_BLOCK_4_BE(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_super_block));\
+	SQUASHFS_SWAP((s)->s_magic, d, 0, 32);\
+	SQUASHFS_SWAP((s)->inodes, d, 32, 32);\
+	SQUASHFS_SWAP((s)->mkfs_time, d, 64, 32);\
+	SQUASHFS_SWAP((s)->block_size, d, 96, 32);\
+	SQUASHFS_SWAP((s)->fragments, d, 128, 32);\
+	SQUASHFS_SWAP((s)->compression, d, 160, 16);\
+	SQUASHFS_SWAP((s)->block_log, d, 176, 16);\
+	SQUASHFS_SWAP((s)->flags, d, 192, 16);\
+	SQUASHFS_SWAP((s)->no_ids, d, 208, 16);\
+	SQUASHFS_SWAP((s)->s_major, d, 224, 16);\
+	SQUASHFS_SWAP((s)->s_minor, d, 240, 16);\
+	SQUASHFS_SWAP((s)->root_inode, d, 256, 64);\
+	SQUASHFS_SWAP((s)->bytes_used, d, 320, 64);\
+	SQUASHFS_SWAP((s)->id_table_start, d, 384, 64);\
+	SQUASHFS_SWAP((s)->xattr_id_table_start, d, 448, 64);\
+	SQUASHFS_SWAP((s)->inode_table_start, d, 512, 64);\
+	SQUASHFS_SWAP((s)->directory_table_start, d, 576, 64);\
+	SQUASHFS_SWAP((s)->fragment_table_start, d, 640, 64);\
+	SQUASHFS_SWAP((s)->lookup_table_start, d, 704, 64);\
+}
+
+#define SQUASHFS_SWAP_BASE_INODE_CORE_4_BE(s, d, n)\
+	SQUASHFS_MEMSET(s, d, n);\
+	SQUASHFS_SWAP((s)->inode_type, d, 0, 16);\
+	SQUASHFS_SWAP((s)->mode, d, 16, 16);\
+	SQUASHFS_SWAP((s)->uid, d, 32, 16);\
+	SQUASHFS_SWAP((s)->guid, d, 48, 16);\
+	SQUASHFS_SWAP((s)->mtime, d, 64, 32);\
+	SQUASHFS_SWAP((s)->inode_number, d, 96, 32);
+
+#define SQUASHFS_SWAP_BASE_INODE_HEADER_4_BE(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_4_BE(s, d, \
+			sizeof(struct squashfs_base_inode_header))\
+}
+
+#define SQUASHFS_SWAP_IPC_INODE_HEADER_4_BE(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_4_BE(s, d, \
+			sizeof(struct squashfs_ipc_inode_header))\
+	SQUASHFS_SWAP((s)->nlink, d, 128, 32);\
+}
+
+#define SQUASHFS_SWAP_LIPC_INODE_HEADER_4_BE(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_4_BE(s, d, \
+			sizeof(struct squashfs_lipc_inode_header));\
+	SQUASHFS_SWAP((s)->nlink, d, 128, 32);\
+	SQUASHFS_SWAP((s)->xattr, d, 160, 32);\
+}
+
+#define SQUASHFS_SWAP_DEV_INODE_HEADER_4_BE(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_4_BE(s, d, \
+			sizeof(struct squashfs_dev_inode_header)); \
+	SQUASHFS_SWAP((s)->nlink, d, 128, 32);\
+	SQUASHFS_SWAP((s)->rdev, d, 160, 32);\
+}
+
+#define SQUASHFS_SWAP_LDEV_INODE_HEADER_4_BE(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_4_BE(s, d, \
+			sizeof(struct squashfs_ldev_inode_header)); \
+	SQUASHFS_SWAP((s)->nlink, d, 128, 32);\
+	SQUASHFS_SWAP((s)->rdev, d, 160, 32);\
+	SQUASHFS_SWAP((s)->xattr, d, 192, 32);\
+}
+
+#define SQUASHFS_SWAP_SYMLINK_INODE_HEADER_4_BE(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_4_BE(s, d, \
+			sizeof(struct squashfs_symlink_inode_header));\
+	SQUASHFS_SWAP((s)->nlink, d, 128, 32);\
+	SQUASHFS_SWAP((s)->symlink_size, d, 160, 32);\
+}
+
+#define SQUASHFS_SWAP_REG_INODE_HEADER_4_BE(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_4_BE(s, d, \
+			sizeof(struct squashfs_reg_inode_header));\
+	SQUASHFS_SWAP((s)->start_block, d, 128, 32);\
+	SQUASHFS_SWAP((s)->fragment, d, 160, 32);\
+	SQUASHFS_SWAP((s)->offset, d, 192, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 224, 32);\
+}
+
+#define SQUASHFS_SWAP_LREG_INODE_HEADER_4_BE(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_4_BE(s, d, \
+			sizeof(struct squashfs_lreg_inode_header));\
+	SQUASHFS_SWAP((s)->start_block, d, 128, 64);\
+	SQUASHFS_SWAP((s)->file_size, d, 192, 64);\
+	SQUASHFS_SWAP((s)->sparse, d, 256, 64);\
+	SQUASHFS_SWAP((s)->nlink, d, 320, 32);\
+	SQUASHFS_SWAP((s)->fragment, d, 352, 32);\
+	SQUASHFS_SWAP((s)->offset, d, 384, 32);\
+	SQUASHFS_SWAP((s)->xattr, d, 416, 32);\
+}
+
+#define SQUASHFS_SWAP_DIR_INODE_HEADER_4_BE(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_4_BE(s, d, \
+			sizeof(struct squashfs_dir_inode_header));\
+	SQUASHFS_SWAP((s)->start_block, d, 128, 32);\
+	SQUASHFS_SWAP((s)->nlink, d, 160, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 192, 16);\
+	SQUASHFS_SWAP((s)->offset, d, 208, 16);\
+	SQUASHFS_SWAP((s)->parent_inode, d, 224, 32);\
+}
+
+#define SQUASHFS_SWAP_LDIR_INODE_HEADER_4_BE(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_SWAP_BASE_INODE_CORE_4_BE(s, d, \
+			sizeof(struct squashfs_ldir_inode_header));\
+	SQUASHFS_SWAP((s)->nlink, d, 128, 32);\
+	SQUASHFS_SWAP((s)->file_size, d, 160, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 192, 32);\
+	SQUASHFS_SWAP((s)->parent_inode, d, 224, 32);\
+	SQUASHFS_SWAP((s)->i_count, d, 256, 16);\
+	SQUASHFS_SWAP((s)->offset, d, 272, 16);\
+	SQUASHFS_SWAP((s)->xattr, d, 288, 32);\
+}
+
+#define SQUASHFS_SWAP_DIR_INDEX_4_BE(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_index));\
+	SQUASHFS_SWAP((s)->index, d, 0, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 32, 32);\
+	SQUASHFS_SWAP((s)->size, d, 64, 8);\
+}
+
+#define SQUASHFS_SWAP_DIR_HEADER_4_BE(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_header));\
+	SQUASHFS_SWAP((s)->count, d, 0, 32);\
+	SQUASHFS_SWAP((s)->start_block, d, 32, 32);\
+	SQUASHFS_SWAP((s)->inode_number, d, 64, 32);\
+}
+
+#define SQUASHFS_SWAP_DIR_ENTRY_4_BE(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_entry));\
+	SQUASHFS_SWAP((s)->offset, d, 0, 16);\
+	SQUASHFS_SWAP((s)->inode_number, d, 16, 16);\
+	SQUASHFS_SWAP((s)->type, d, 32, 16);\
+	SQUASHFS_SWAP((s)->size, d, 48, 16);\
+}
+
+#define SQUASHFS_SWAP_INODE_T_4_BE(s, d) SQUASHFS_SWAP_LONG_LONGS_4_BE(s, d, 1)
+
+#define SQUASHFS_SWAP_SHORTS_4_BE(s, d, n) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, n * 2);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \
+			16)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, 16);\
+}
+
+#define SQUASHFS_SWAP_INTS_4_BE(s, d, n) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, n * 4);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \
+			32)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, 32);\
+}
+
+#define SQUASHFS_SWAP_LONG_LONGS_4_BE(s, d, n) {\
+	int entry;\
+	int bit_position;\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, n * 8);\
+	for(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \
+			64)\
+		SQUASHFS_SWAP(s[entry], d, bit_position, 64);\
+}
+
+#define SQUASHFS_SWAP_FRAGMENT_INDEXES_4_BE(s, d, n) SQUASHFS_SWAP_LONG_LONGS_4_BE(s, d, n)
+#define SQUASHFS_SWAP_LOOKUP_BLOCKS_4_BE(s, d, n) SQUASHFS_SWAP_LONG_LONGS_4_BE(s, d, n)
+
+#define SQUASHFS_SWAP_FRAGMENT_ENTRY_4_BE(s, d) {\
+	SQUASHFS_SWAP_START\
+	SQUASHFS_MEMSET(s, d, sizeof(struct squashfs_fragment_entry));\
+	SQUASHFS_SWAP((s)->start_block, d, 0, 64);\
+	SQUASHFS_SWAP((s)->size, d, 64, 32);\
+}
+
+#define SQUASHFS_FRAGMENT_BYTES_4_BE(A)	((A) * sizeof(struct squashfs_fragment_entry))
+
+#define SQUASHFS_FRAGMENT_INDEX_4_BE(A)	(SQUASHFS_FRAGMENT_BYTES_4_BE(A) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEX_OFFSET_4_BE(A)	(SQUASHFS_FRAGMENT_BYTES_4_BE(A) % \
+						SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEXES_4_BE(A)	((SQUASHFS_FRAGMENT_BYTES_4_BE(A) + \
+					SQUASHFS_METADATA_SIZE - 1) / \
+					SQUASHFS_METADATA_SIZE)
+
+#define SQUASHFS_FRAGMENT_INDEX_BYTES_4_BE(A)	(SQUASHFS_FRAGMENT_INDEXES_4_BE(A) *\
+						sizeof(long long))
+
+#endif
--- squashfs-tools/unsquash-4-be.c
+++ squashfs-tools/unsquash-4-be.c
@@ -0,0 +1,451 @@
+/*
+ * Unsquash a squashfs filesystem.  This is a highly compressed read only
+ * filesystem.
+ *
+ * Copyright (c) 2009, 2010, 2011, 2012, 2013
+ * Phillip Lougher <phillip@squashfs.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
+ * or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * unsquash-4-be.c
+ *
+ * Copyright (C) 2014
+ * Peter Hämmerlein <opensource@peh-consulting.de>
+ *
+ * - unsquashfs code adopted for squashfs 4 images with big endian data
+ *   format, which was given up starting with version 4.0 by the original
+ *   code
+ * - that format is very unusual and was IMHO seen at AVM's 6490 router
+ *   first
+ * - the filesystem structures are swapped, but the block length value at
+ *   the very beginning of each compressed block is kept in little endian
+ *   order -> the regular unsquashfs code gets confused here
+ *
+ */
+
+#include "unsquashfs.h"
+#include "squashfs_fs.h"
+#include "squashfs_compat.h"
+#include "squashfs_compat_4_be.h"
+
+static struct squashfs_fragment_entry *fragment_table;
+static unsigned int *id_table;
+
+int read_fragment_table_4_be(long long *directory_table_end)
+{
+	int res, i;
+	int bytes = SQUASHFS_FRAGMENT_BYTES_4_BE(sBlk.s.fragments);
+	int indexes = SQUASHFS_FRAGMENT_INDEXES_4_BE(sBlk.s.fragments);
+	long long fragment_table_index[indexes];
+
+	TRACE("read_fragment_table: %d fragments, reading %d fragment indexes "
+		"from 0x%llx\n", sBlk.s.fragments, indexes,
+		sBlk.s.fragment_table_start);
+
+	if(sBlk.s.fragments == 0) {
+		*directory_table_end = sBlk.s.fragment_table_start;
+		return TRUE;
+	}
+
+	fragment_table = malloc(bytes);
+	if(fragment_table == NULL)
+		EXIT_UNSQUASH("read_fragment_table: failed to allocate "
+			"fragment table\n");
+
+	if(swap) {
+		long long sfragment_table_index[indexes];
+
+		res = read_fs_bytes(fd, sBlk.s.fragment_table_start,
+			SQUASHFS_FRAGMENT_INDEX_BYTES_4_BE(sBlk.s.fragments),
+			sfragment_table_index);
+		if(res == FALSE) {
+			ERROR("read_fragment_table: failed to read fragment "
+				"table index\n");
+			return FALSE;
+		}
+		SQUASHFS_SWAP_FRAGMENT_INDEXES_4_BE(fragment_table_index,
+			sfragment_table_index, indexes);
+	} else {
+		res = read_fs_bytes(fd, sBlk.s.fragment_table_start,
+			SQUASHFS_FRAGMENT_INDEX_BYTES_4_BE(sBlk.s.fragments),
+			fragment_table_index);
+		if(res == FALSE) {
+			ERROR("read_fragment_table: failed to read fragment "
+				"table index\n");
+			return FALSE;
+		}
+	}
+
+	for(i = 0; i < indexes; i++) {
+		int expected = (i + 1) != indexes ? SQUASHFS_METADATA_SIZE :
+					bytes & (SQUASHFS_METADATA_SIZE - 1);
+		int length = read_block(fd, fragment_table_index[i], NULL,
+			expected, ((char *) fragment_table) + (i *
+			SQUASHFS_METADATA_SIZE));
+		TRACE("Read fragment table block %d, from 0x%llx, length %d\n",
+			i, fragment_table_index[i], length);
+		if(length == FALSE) {
+			ERROR("read_fragment_table: failed to read fragment "
+				"table block\n");
+			return FALSE;
+		}
+	}
+
+	if(swap) {
+		struct squashfs_fragment_entry sfragment;
+		for(i = 0; i < sBlk.s.fragments; i++) {
+			SQUASHFS_SWAP_FRAGMENT_ENTRY_4_BE((&sfragment),
+				(&fragment_table[i]));
+			memcpy((char *) &fragment_table[i], (char *) &sfragment,
+				sizeof(struct squashfs_fragment_entry));
+		}
+	}
+
+	*directory_table_end = fragment_table_index[0];
+	return TRUE;
+}
+
+void read_fragment_4_be(unsigned int fragment, long long *start_block, int *size)
+{
+	TRACE("read_fragment: reading fragment %d\n", fragment);
+
+	struct squashfs_fragment_entry *fragment_entry = &fragment_table[fragment];
+	*start_block = fragment_entry->start_block;
+	*size = fragment_entry->size;
+}
+
+struct inode *read_inode_4_be(unsigned int start_block, unsigned int offset)
+{
+	static union squashfs_inode_header header;
+	static union squashfs_inode_header s_header;
+	long long start = sBlk.s.inode_table_start + start_block;
+	int bytes = lookup_entry(inode_table_hash, start);
+	char *block_ptr = inode_table + bytes + offset;
+	static struct inode i;
+	memcpy(&s_header, block_ptr, sizeof(s_header));
+
+	TRACE("read_inode: reading inode [%d:%d]\n", start_block,  offset);
+
+	if(bytes == -1)
+		EXIT_UNSQUASH("read_inode: inode table block %lld not found\n",
+			start);
+
+	SQUASHFS_SWAP_BASE_INODE_HEADER_4_BE(&header.base, &s_header.base);
+	memcpy(&s_header, block_ptr, sizeof(s_header));
+
+	i.uid = (uid_t) id_table[header.base.uid];
+	i.gid = (uid_t) id_table[header.base.guid];
+	i.mode = lookup_type[header.base.inode_type] | header.base.mode;
+	i.type = header.base.inode_type;
+	i.time = header.base.mtime;
+	i.inode_number = header.base.inode_number;
+
+	switch(header.base.inode_type) {
+		case SQUASHFS_DIR_TYPE: {
+			struct squashfs_dir_inode_header *inode = &header.dir;
+
+			SQUASHFS_SWAP_DIR_INODE_HEADER_4_BE(inode, &s_header.dir);
+
+			i.data = inode->file_size;
+			i.offset = inode->offset;
+			i.start = inode->start_block;
+			i.xattr = SQUASHFS_INVALID_XATTR;
+			break;
+		}
+		case SQUASHFS_LDIR_TYPE: {
+			struct squashfs_ldir_inode_header *inode = &header.ldir;
+
+			SQUASHFS_SWAP_LDIR_INODE_HEADER_4_BE(inode, &s_header.ldir);
+
+			i.data = inode->file_size;
+			i.offset = inode->offset;
+			i.start = inode->start_block;
+			i.xattr = inode->xattr;
+			break;
+		}
+		case SQUASHFS_FILE_TYPE: {
+			struct squashfs_reg_inode_header *inode = &header.reg;
+
+			SQUASHFS_SWAP_REG_INODE_HEADER_4_BE(inode, &s_header.reg);
+
+			i.data = inode->file_size;
+			i.frag_bytes = inode->fragment == SQUASHFS_INVALID_FRAG
+				?  0 : inode->file_size % sBlk.s.block_size;
+			i.fragment = inode->fragment;
+			i.offset = inode->offset;
+			i.blocks = inode->fragment == SQUASHFS_INVALID_FRAG ?
+				(i.data + sBlk.s.block_size - 1) >>
+				sBlk.s.block_log :
+				i.data >> sBlk.s.block_log;
+			i.start = inode->start_block;
+			i.sparse = 0;
+			i.block_ptr = block_ptr + sizeof(*inode);
+			i.xattr = SQUASHFS_INVALID_XATTR;
+			break;
+		}
+		case SQUASHFS_LREG_TYPE: {
+			struct squashfs_lreg_inode_header *inode = &header.lreg;
+
+			SQUASHFS_SWAP_LREG_INODE_HEADER_4_BE(inode, &s_header.lreg);
+
+			i.data = inode->file_size;
+			i.frag_bytes = inode->fragment == SQUASHFS_INVALID_FRAG
+				?  0 : inode->file_size % sBlk.s.block_size;
+			i.fragment = inode->fragment;
+			i.offset = inode->offset;
+			i.blocks = inode->fragment == SQUASHFS_INVALID_FRAG ?
+				(inode->file_size + sBlk.s.block_size - 1) >>
+				sBlk.s.block_log :
+				inode->file_size >> sBlk.s.block_log;
+			i.start = inode->start_block;
+			i.sparse = inode->sparse != 0;
+			i.block_ptr = block_ptr + sizeof(*inode);
+			i.xattr = inode->xattr;
+			break;
+		}
+		case SQUASHFS_SYMLINK_TYPE:
+		case SQUASHFS_LSYMLINK_TYPE: {
+			struct squashfs_symlink_inode_header *inode = &header.symlink;
+
+			SQUASHFS_SWAP_SYMLINK_INODE_HEADER_4_BE(inode, &s_header.symlink);
+
+			i.symlink = malloc(inode->symlink_size + 1);
+			if(i.symlink == NULL)
+				EXIT_UNSQUASH("read_inode: failed to malloc "
+					"symlink data\n");
+			strncpy(i.symlink, block_ptr +
+				sizeof(struct squashfs_symlink_inode_header),
+				inode->symlink_size);
+			i.symlink[inode->symlink_size] = '\0';
+			TRACE("linked_to = %s\n", i.symlink);
+			i.data = inode->symlink_size;
+
+			/* SQUASHFS_LSYMLINK_TYPE xattr handling is missing here */
+			i.xattr = SQUASHFS_INVALID_XATTR;
+			break;
+		}
+		case SQUASHFS_BLKDEV_TYPE:
+		case SQUASHFS_CHRDEV_TYPE: {
+			struct squashfs_dev_inode_header *inode = &header.dev;
+
+			SQUASHFS_SWAP_DEV_INODE_HEADER_4_BE(inode, &s_header.dev);
+
+			i.data = inode->rdev;
+			i.xattr = SQUASHFS_INVALID_XATTR;
+			break;
+		}
+		case SQUASHFS_LBLKDEV_TYPE:
+		case SQUASHFS_LCHRDEV_TYPE: {
+			struct squashfs_ldev_inode_header *inode = &header.ldev;
+
+			SQUASHFS_SWAP_LDEV_INODE_HEADER_4_BE(inode, &s_header.ldev);
+
+			i.data = inode->rdev;
+			i.xattr = inode->xattr;
+			break;
+		}
+		case SQUASHFS_FIFO_TYPE:
+		case SQUASHFS_SOCKET_TYPE:
+			i.data = 0;
+			i.xattr = SQUASHFS_INVALID_XATTR;
+			break;
+		case SQUASHFS_LFIFO_TYPE:
+		case SQUASHFS_LSOCKET_TYPE: {
+			struct squashfs_lipc_inode_header *inode = &header.lipc;
+
+			SQUASHFS_SWAP_LIPC_INODE_HEADER_4_BE(inode, &s_header.lipc);
+
+			i.data = 0;
+			i.xattr = inode->xattr;
+			break;
+		}
+		default:
+			EXIT_UNSQUASH("Unknown inode type %d in read_inode!\n",
+				header.base.inode_type);
+	}
+	return &i;
+}
+
+struct dir *squashfs_opendir_4_be(unsigned int block_start, unsigned int offset,
+	struct inode **i)
+{
+	struct squashfs_dir_header dirh;
+	char buffer[sizeof(struct squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1]
+		__attribute__((aligned));
+	struct squashfs_dir_entry *dire = (struct squashfs_dir_entry *) buffer;
+	long long start;
+	int bytes;
+	int dir_count, size;
+	struct dir_ent *new_dir;
+	struct dir *dir;
+
+	TRACE("squashfs_opendir: inode start block 0x%x, offset 0x%x\n",
+		block_start, offset);
+
+	*i = s_ops.read_inode(block_start, offset);
+
+	dir = malloc(sizeof(struct dir));
+	if(dir == NULL)
+		EXIT_UNSQUASH("squashfs_opendir: malloc failed!\n");
+
+	dir->dir_count = 0;
+	dir->cur_entry = 0;
+	dir->mode = (*i)->mode;
+	dir->uid = (*i)->uid;
+	dir->guid = (*i)->gid;
+	dir->mtime = (*i)->time;
+	dir->xattr = (*i)->xattr;
+	dir->dirs = NULL;
+
+	if ((*i)->data == 3)
+		/*
+		 * if the directory is empty, skip the unnecessary
+		 * lookup_entry, this fixes the corner case with
+		 * completely empty filesystems where lookup_entry correctly
+		 * returning -1 is incorrectly treated as an error
+		 */
+		return dir;
+
+	start = sBlk.s.directory_table_start + (*i)->start;
+	bytes = lookup_entry(directory_table_hash, start);
+
+	if(bytes == -1)
+		EXIT_UNSQUASH("squashfs_opendir: directory block %d not "
+			"found!\n", block_start);
+
+	bytes += (*i)->offset;
+	size = (*i)->data + bytes - 3;
+
+	while(bytes < size) {
+		if(swap) {
+			struct squashfs_dir_header sdirh;
+			memcpy(&sdirh, directory_table + bytes, sizeof(sdirh));
+			SQUASHFS_SWAP_DIR_HEADER_4_BE(&dirh, &sdirh);
+		} else
+			memcpy(&dirh, directory_table + bytes, sizeof(dirh));
+
+		dir_count = dirh.count + 1;
+		TRACE("squashfs_opendir: Read directory header @ byte position "
+			"%d, %d directory entries\n", bytes, dir_count);
+		bytes += sizeof(dirh);
+
+		/* dir_count should never be larger than 256 */
+		if(dir_count > 256)
+			goto corrupted;
+
+		while(dir_count--) {
+			if(swap) {
+				struct squashfs_dir_entry sdire;
+				memcpy(&sdire, directory_table + bytes,
+					sizeof(sdire));
+				SQUASHFS_SWAP_DIR_ENTRY_4_BE(dire, &sdire);
+			} else
+				memcpy(dire, directory_table + bytes,
+					sizeof(*dire));
+			bytes += sizeof(*dire);
+
+			/* size should never be larger than SQUASHFS_NAME_LEN */
+			if(dire->size > SQUASHFS_NAME_LEN)
+				goto corrupted;
+
+			memcpy(dire->name, directory_table + bytes,
+				dire->size + 1);
+			dire->name[dire->size + 1] = '\0';
+			TRACE("squashfs_opendir: directory entry %s, inode "
+				"%d:%d, type %d\n", dire->name,
+				dirh.start_block, dire->offset, dire->type);
+			if((dir->dir_count % DIR_ENT_SIZE) == 0) {
+				new_dir = realloc(dir->dirs, (dir->dir_count +
+					DIR_ENT_SIZE) * sizeof(struct dir_ent));
+				if(new_dir == NULL)
+					EXIT_UNSQUASH("squashfs_opendir: "
+						"realloc failed!\n");
+				dir->dirs = new_dir;
+			}
+			strcpy(dir->dirs[dir->dir_count].name, dire->name);
+			dir->dirs[dir->dir_count].start_block =
+				dirh.start_block;
+			dir->dirs[dir->dir_count].offset = dire->offset;
+			dir->dirs[dir->dir_count].type = dire->type;
+			dir->dir_count ++;
+			bytes += dire->size + 1;
+		}
+	}
+
+	return dir;
+
+corrupted:
+	free(dir->dirs);
+	free(dir);
+	return NULL;
+}
+
+int read_uids_guids_4_be()
+{
+	int res, i;
+	int bytes = SQUASHFS_ID_BYTES(sBlk.s.no_ids);
+	int indexes = SQUASHFS_ID_BLOCKS(sBlk.s.no_ids);
+	long long id_index_table[indexes];
+	long long s_id_index_table[indexes];
+
+	TRACE("read_uids_guids: no_ids %d\n", sBlk.s.no_ids);
+
+	id_table = malloc(bytes);
+	if(id_table == NULL) {
+		ERROR("read_uids_guids: failed to allocate id table\n");
+		return FALSE;
+	}
+
+	res = read_fs_bytes(fd, sBlk.s.id_table_start,
+		SQUASHFS_ID_BLOCK_BYTES(sBlk.s.no_ids), s_id_index_table);
+	if(res == FALSE) {
+		ERROR("read_uids_guids: failed to read id index table\n");
+		return FALSE;
+	}
+	SQUASHFS_SWAP_LONG_LONGS_4_BE(id_index_table, s_id_index_table, indexes);
+
+	for(i = 0; i < indexes; i++) {
+		int expected = ( ((i + 1) != indexes) ? SQUASHFS_METADATA_SIZE :
+					bytes & (SQUASHFS_METADATA_SIZE - 1) );
+		res = read_block(fd, id_index_table[i], NULL, expected,
+			((char *) id_table) + i * SQUASHFS_METADATA_SIZE);
+		if(res == FALSE) {
+			ERROR("read_uids_guids: failed to read id table block"
+				"\n");
+			return FALSE;
+		}
+	}
+
+	{
+		/*
+		 *
+		 * Swapping the id table content could be done at the stack too,
+		 * but this is an one-time job and the overhead using malloc/free
+		 * my be ignored
+		 *
+		 */
+		unsigned int *s_id_table;
+		s_id_table = malloc(bytes);
+		if(s_id_table == NULL) {
+			ERROR("read_uids_guids: failed to allocate memory for id table swapping\n");
+			return FALSE;
+		}
+		memcpy(s_id_table, id_table, bytes);
+		SQUASHFS_SWAP_INTS_4_BE(id_table, s_id_table, sBlk.s.no_ids);
+		free(s_id_table);
+	}
+
+	return TRUE;
+}
--- squashfs-tools/unsquashfs.c
+++ squashfs-tools/unsquashfs.c
@@ -26,6 +26,7 @@
 #include "unsquashfs.h"
 #include "squashfs_swap.h"
 #include "squashfs_compat.h"
+#include "squashfs_compat_4_be.h"
 #include "compressor.h"
 #include "xattr.h"
 #include "unsquashfs_info.h"
@@ -51,7 +52,7 @@
 struct compressor *comp;
 
 int bytes = 0, swap, file_count = 0, dir_count = 0, sym_count = 0,
-	dev_count = 0, fifo_count = 0;
+	dev_count = 0, fifo_count = 0, no_be_swap = 0;
 char *inode_table = NULL, *directory_table = NULL;
 struct hash_table_entry *inode_table_hash[65536], *directory_table_hash[65536];
 int fd;
@@ -663,7 +664,7 @@
 	int offset = 2, res, compressed;
 	int outlen = expected ? expected : SQUASHFS_METADATA_SIZE;
 	
-	if(swap) {
+	if(swap && !no_be_swap) {
 		if(read_fs_bytes(fd, start, 2, &c_byte) == FALSE)
 			goto failed;
 		c_byte = (c_byte >> 8) | ((c_byte & 0xff) << 8);
@@ -1802,6 +1803,26 @@
 		comp = lookup_compressor_id(sBlk.s.compression);
 		return TRUE;
 	}
+	else if (swap) {
+		struct squashfs_super_block ssBlk_4;
+		TRACE("Trying swapped big endian SQUASHFS 4\n");
+		SQUASHFS_SWAP_SUPER_BLOCK_4_BE(&ssBlk_4, &sBlk_4);
+		if (ssBlk_4.s_magic == SQUASHFS_MAGIC && ssBlk_4.s_major == 4 &&
+			ssBlk_4.s_minor == 0) {
+			ERROR("Reading a big endian SQUASHFS 4 filesystem "
+				"on %s\n", source);
+			s_ops.squashfs_opendir = squashfs_opendir_4_be;
+			s_ops.read_fragment = read_fragment_4_be;
+			s_ops.read_fragment_table = read_fragment_table_4_be;
+			s_ops.read_block_list = read_block_list_2;
+			s_ops.read_inode = read_inode_4_be;
+			s_ops.read_uids_guids = read_uids_guids_4_be;
+			memcpy(&sBlk, &ssBlk_4, sizeof(ssBlk_4));
+			no_be_swap = 1;
+			comp = lookup_compressor_id(sBlk.s.compression);
+			return TRUE;
+		}
+	}
 
 	/*
  	 * Not a Squashfs 4 superblock, try to read a squashfs 3 superblock
--- squashfs-tools/unsquashfs.h
+++ squashfs-tools/unsquashfs.h
@@ -226,6 +226,7 @@
 extern struct super_block sBlk;
 extern squashfs_operations s_ops;
 extern int swap;
+extern int no_be_swap;
 extern char *inode_table, *directory_table;
 extern struct hash_table_entry *inode_table_hash[65536],
 	*directory_table_hash[65536];
@@ -268,6 +269,14 @@
 extern struct dir *squashfs_opendir_3(unsigned int, unsigned int,
 	struct inode **);
 
+/* unsquash-4-be.c */
+extern int read_fragment_table_4_be(long long *);
+extern void read_fragment_4_be(unsigned int, long long *, int *);
+extern struct inode *read_inode_4_be(unsigned int, unsigned int);
+extern struct dir *squashfs_opendir_4_be(unsigned int, unsigned int,
+	struct inode **);
+extern int read_uids_guids_4_be();
+
 /* unsquash-4.c */
 extern int read_fragment_table_4(long long *);
 extern void read_fragment_4(unsigned int, long long *, int *);
